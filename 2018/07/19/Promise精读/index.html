<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Promise精读"><meta name="keywords" content="Javascript"><meta name="author" content="AddOneG,undefined"><meta name="copyright" content="AddOneG"><title>Promise精读 | AddOneG</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#语法"><span class="toc-number">1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#描述"><span class="toc-number">2.</span> <span class="toc-text">描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise执行原理"><span class="toc-number">4.</span> <span class="toc-text">Promise执行原理</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://p5sf6v0wz.bkt.clouddn.com/avatar.jpg"></div><div class="author-info__name text-center">AddOneG</div><div class="author-info__description text-center">心似双丝网，中有千千结</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">48</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">31</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">21</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://blog.triplez.cn/" target="_blank">TripleZ</a><a class="author-info-links__name text-center" href="http://karlrixon.link/" target="_blank">karlrixon</a><a class="author-info-links__name text-center" href="http://qrzbing.cn/" target="_blank">a-Lie-Z</a><a class="author-info-links__name text-center" href="https://primykq.top/" target="_blank">Primykq</a><a class="author-info-links__name text-center" href="https://blog.zeddyu.info/" target="_blank">Zedd</a><a class="author-info-links__name text-center" href="https://yuwenjie.cc/" target="_blank">Seiry</a><a class="author-info-links__name text-center" href="https://mountainlovers.github.io/" target="_blank">Mountain_lovers</a><a class="author-info-links__name text-center" href="https://blog.rexskz.info/" target="_blank">Rex</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">AddOneG</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Promise精读</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Javascript/"> Javascript</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,483</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></span></div><div id="post-content"><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote>
<p>new Promise( function(resolve, reject) {…} /<em> executor </em>/  );</p>
</blockquote>
<p><strong>executor</strong></p>
<p>executor是带有 <code>resolve</code> 和 <code>reject</code> 两个参数的函数 。Promise构造函数执行时立即调用<code>executor</code> 函数， <code>resolve</code> 和 <code>reject</code> 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。<code>resolve</code> 和 <code>reject</code> 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。</p>
<p>如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>Promise</code> 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p>
<p>一个 Promise有以下几种状态:</p>
<ul>
<li><strong>pending:</strong> 初始状态，既不是成功，也不是失败状态</li>
<li><strong>fulfilled:</strong> 意味着操作成功完成</li>
<li><strong>rejected:</strong> 意味着操作失败</li>
</ul>
<p><code>pending</code> 状态的 Promise 对象可能触发<code>fulfilled</code> 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（<code>rejected</code>）并传递失败信息。当其中任一种情况出现时，Promise 对象的 <code>then</code> 方法绑定的处理方法（<code>handlers</code>）就会被调用（<code>then</code>方法包含两个参数：<code>onfulfilled</code> 和 <code>onrejected</code>，它们都是 Function 类型。当Promise状态为<code>fulfilled</code>时，调用 <code>then</code> 的 <code>onfulfilled</code> 方法，当Promise状态为<code>rejected</code>时，调用 <code>then</code> 的 <code>onrejected</code> 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）</p>
<p>因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用</p>
<blockquote>
<p>如果一个promise对象处在<code>fulfilled</code>或<code>rejected</code>状态而不是<code>pending</code>状态，那么它也可以被称为<code>settled</code>状态。你可能也会听到一个术语<code>resolved</code> ，它表示promise对象处于<code>fulfilled</code>状态。</p>
</blockquote>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>Promise.all(iterable)</code></p>
<p>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里<strong>所有的promise对象都成功的时候才会触发成功</strong>,一旦有任何一个iterable里面的promise对象<strong>失败则立即触发该promise对象的失败</strong>。触发成功状态以后，会把一个<strong>包含iterable里所有promise返回值的数组</strong>作为成功回调的返回值，顺序跟iterable的<strong>顺序保持一致</strong>；如果这个新的promise对象触发了失败状态，它会把iterable里<strong>第一个触发失败</strong>的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理<strong>多个promise对象的状态集合</strong>。</p>
<p><code>Promise.race(iterable)</code></p>
<p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象</p>
<blockquote>
<p>即iterable数组中哪个Promise最先被resolve，就把哪个结果返回到Promise.race(iterable).then()中，不管其结果是成功还是失败</p>
</blockquote>
<p><code>Promise.reject(reason)</code><br>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p>
<p><code>Promise.resolve(value)</code><br>返回一个以给定值解析后的Promise对象。但如果这个值是个<code>thenable</code>（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；如果传入的value本身就是promise对象，则该对象作为Promise.resolve方法的返回值返回；否则以该值为成功状态返回promise对象</p>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFirstPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)</span></span><br><span class="line">    <span class="comment">//在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">"成功!"</span>); <span class="comment">//代码正常执行！</span></span><br><span class="line">    &#125;, <span class="number">250</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myFirstPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">successMessage</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//successMessage的值是上面调用resolve(...)方法传入的值.</span></span><br><span class="line">    <span class="comment">//successMessage参数不一定非要是字符串类型，这里只是举个例子</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Yay! "</span> + successMessage);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 250ms后输出"Yay! 成功"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Promise执行原理"><a href="#Promise执行原理" class="headerlink" title="Promise执行原理"></a>Promise执行原理</h2><p>先放一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve(3);</span><br><span class="line">    Promise.resolve().then(()=&gt; console.log(4))</span><br><span class="line">&#125;).then(num =&gt; &#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">// 1 2 4 3</span><br></pre></td></tr></table></figure>
<ol>
<li><p>当你执行resolve时，如果参数为<code>thenable</code>(见上文Promise.resolve方法)，则会进入一个Promise链处理(这里跳过)；否则进入下一步</p>
</li>
<li><p>根据Promise的构造函数可以看到，state状态初始化为pending</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">resolver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> resolver !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'resolver must be a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">  <span class="keyword">this</span>.queue = [];</span><br><span class="line">  <span class="keyword">this</span>.outcome = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (resolver !== INTERNAL) &#123;</span><br><span class="line">    safelyResolveThenable(<span class="keyword">this</span>, resolver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现当你<code>new Promise</code>的时候这个<code>resolver</code>就会被调用，传进来的函数支持两个参数，分别是resolve和reject回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolver = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (success) resolve();</span><br><span class="line">    <span class="keyword">else</span> reject();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(resolver);</span><br></pre></td></tr></table></figure>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/promise-res.png" alt=""></p>
<p>thenable函数就是我们传给它的resolver，然后传递onSuccess和onError，分别是我们在resolver里面写的resolve和reject这两个参数，如果我们调了它的resolve即onSuccess(或者onError)函数，就去设置当前Promise对象的state，outcome(resolve的值)等属性</p>
<ol>
<li>上面的到此为止为同步操作，接下来我们看看<code>then</code>里发生了什么</li>
</ol>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/promise-then.png" alt=""></p>
<p>then接受两个参数，分别为成功回调和失败回调。我们在resolver中已经设置好了state，在这里就会通过If语句进入不同的函数，假设我们这里传入了成功回调，于是执行<code>unwrap</code>函数</p>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/promise-unwrap.png" alt=""></p>
<p>在167行执行then里传给Promise的成功回调，并传递结果outcom</p>
<p>这段代码是包在一个<code>immediate</code>函数里的，它可以实现一个nextTick的功能，即在当前代码逻辑单元同步执行完了之后立刻执行，相当于setTimeout 0。immediate里面会调一个scheduleDrain（drain是排水的意思）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immediate</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue.push(task) === <span class="number">1</span> &amp;&amp; !draining) &#123;</span><br><span class="line">    scheduleDrain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mutation = global.MutationObserver || global.WebKitMutationObserver;</span><br><span class="line"><span class="keyword">var</span> scheduleDrain = <span class="literal">null</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 浏览器环境，IE11以上支持</span></span><br><span class="line">  <span class="keyword">if</span> (Mutation) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// Node.js环境</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!global.setImmediate &amp;&amp; <span class="keyword">typeof</span> global.MessageChannel !== <span class="string">'undefined'</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 低浏览器版本解决方案</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'document'</span> <span class="keyword">in</span> global &amp;&amp; <span class="string">'onreadystatechange'</span> <span class="keyword">in</span> global.document.createElement(<span class="string">'script'</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后实在没办法了，用最次的setTimeout</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(nextTick, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会对兼容性进行判断，优先使用MutationObserver，然后是使用script标签的方式，这种到IE6都支持，最后用setTimeout 0。</p>
<p>关于Mutation可以查看<a href="">MDN</a>，可以用它来监听DOM结点的变化，如增删、属性变化等。Immediate是这么实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Mutation) &#123;</span><br><span class="line">  <span class="keyword">var</span> called = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> observer = <span class="keyword">new</span> Mutation(nextTick);</span><br><span class="line">  <span class="keyword">var</span> element = global.document.createTextNode(<span class="string">''</span>);</span><br><span class="line">  <span class="comment">// 监听节点的data属性的变化</span></span><br><span class="line">  observer.observe(element, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 让data属性发生变化，在0/1之间不断切换，</span></span><br><span class="line">    <span class="comment">// 进而触发observer执行nextTick函数</span></span><br><span class="line">    element.data = (called = ++called % <span class="number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用nextTick回调注册一个observer观察者，然后创建一个DOM节点element，成为observer的观察对象，观察它的data属性。当需要执行nextTick函数的时候，就调一下scheduleDrain改变data属性，就会触发观察者的回调nextTick。它是异步执行的，在当前代码单元执行完之后立刻之行，但又是在setTimeout 0之前执行的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// Promise.resolve().then(()=&gt; console.log(4))</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 2 3 5</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行immediate的时候把成功回调push到一个全局的数组queue里面，而nextTick是把这些回调按顺序执行</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  draining = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> i, oldQueue;</span><br><span class="line">  <span class="keyword">var</span> len = queue.length;</span><br><span class="line">  <span class="keyword">while</span> (len) &#123;</span><br><span class="line">    oldQueue = queue;</span><br><span class="line">    <span class="comment">// 把queue清空</span></span><br><span class="line">    queue = [];</span><br><span class="line">    i = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 执行当前所有回调</span></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">      oldQueue[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    len = queue.length;</span><br><span class="line">  &#125;</span><br><span class="line">  draining = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会先把排水的变量draining设置成true，然后处理完成之后再设置成false，我们再回顾一下刚刚执行immediate的判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immediate</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue.push(task) === <span class="number">1</span> &amp;&amp; !draining) &#123;</span><br><span class="line">    scheduleDrain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当queue为空时，push一个变量进来，这个时候queue只有1个元素，返回值就为1。所以如果之前已经push过了，那么这里就不用再触发nextTick，因为第一次的push会把所有queue回调元素都执行的，只要保证后面的操作有被push到这个queue里面就好了。</p>
<ol>
<li>在最开始的例子中，resolver是异步调用的，这样在走到then的时候state还是pending状态，这样的话就不会进入unwrap</li>
</ol>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/promise-asres.png" alt=""></p>
<p>它会创建一个QueueItem然后放到当前Promise对象的queue属性里面（注意这里的queue和上面说的immediate里全局的queue是两个不同的变量）。然后异步执行结束调用resolve，这个时候queue不为空了：</p>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/promise-final.png" alt=""></p>
<p>就会执行queue队列里面的成功回调。因为then是可以then多次的，所以成功回调可能会有多个。它也是调用immediate，在nextTick的时候执行的</p>
<p>也就是说如果是同步resolve的，是通过MutationObserver/Setimeout 0之类的方式在当前的代码单元执行完之后立刻执行成功回调；而如果是异步resolve的，是先把成功回调放到当前Promise对象的一个队列里面，等到异步结束了执行resolve的时候再用同样的方式在nextTick调用成功回调</p>
<blockquote>
<p>文章参考于<a href="https://juejin.im/post/5aa3f7b9f265da23766ae5ae" target="_blank" rel="noopener">从一道Promise执行顺序的题目看Promise实现</a>和<code>MDN</code></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">AddOneG</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/19/Promise精读/">http://yoursite.com/2018/07/19/Promise精读/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Javascript/">Javascript</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2018/07/19/async-await通读/"><span>async/await通读</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By AddOneG</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>