<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Javascript引擎之属性访问优化"><meta name="keywords" content="Javascript"><meta name="author" content="AddOneG,undefined"><meta name="copyright" content="AddOneG"><title>Javascript引擎之属性访问优化 | AddOneG</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预热-JS内存机制"><span class="toc-number">2.</span> <span class="toc-text">预热 - JS内存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存模型"><span class="toc-number">2.1.</span> <span class="toc-text">内存模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shape"><span class="toc-number">3.</span> <span class="toc-text">Shape</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础"><span class="toc-number">3.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过渡链"><span class="toc-number">3.2.</span> <span class="toc-text">过渡链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存联缓（ICs）"><span class="toc-number">3.3.</span> <span class="toc-text">内存联缓（ICs）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有效存储数组"><span class="toc-number">4.</span> <span class="toc-text">有效存储数组</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://p5sf6v0wz.bkt.clouddn.com/avatar.jpg"></div><div class="author-info__name text-center">AddOneG</div><div class="author-info__description text-center">心似双丝网，中有千千结</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">47</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">31</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">21</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://blog.triplez.cn/" target="_blank">TripleZ</a><a class="author-info-links__name text-center" href="http://karlrixon.link/" target="_blank">karlrixon</a><a class="author-info-links__name text-center" href="http://qrzbing.cn/" target="_blank">a-Lie-Z</a><a class="author-info-links__name text-center" href="https://primykq.top/" target="_blank">Primykq</a><a class="author-info-links__name text-center" href="https://blog.zeddyu.info/" target="_blank">Zedd</a><a class="author-info-links__name text-center" href="https://yuwenjie.cc/" target="_blank">Seiry</a><a class="author-info-links__name text-center" href="https://mountainlovers.github.io/" target="_blank">Mountain_lovers</a><a class="author-info-links__name text-center" href="https://blog.rexskz.info/" target="_blank">Rex</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">AddOneG</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Javascript引擎之属性访问优化</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Javascript/"> Javascript</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1,420</span><span class="post-meta__separator">|</span><span>Reading time: 5 min</span></span></div><div id="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在看Javascript引擎的时候看到了<code>Shape</code>这个东西， 在这里理解并且延伸一下</p>
<h2 id="预热-JS内存机制"><a href="#预热-JS内存机制" class="headerlink" title="预热 - JS内存机制"></a>预热 - JS内存机制</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。简单来理解的话，其中基础数据类型大多数保存在栈中(闭包除外)，对象保存在堆中，常量保存在池中。</p>
<ul>
<li>对于栈中的数据，根据先进后出来取，若想取下层的数据，就要先将上层的数据取出</li>
<li>对于堆中的数据，Js是不允许直接访问的，我们实际操作的都是对象的引用而不是它的本身，例如<code>var a = { b: 20 }</code>，当我们操作<code>{ b: 20 }</code>时，实际上是从栈中访问<code>a</code>来获取对象的地址引用，再从堆中获取我们需要的数据</li>
</ul>
<blockquote>
<p>其他一些细节知识这里就懒得写的</p>
</blockquote>
<h2 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>我们无时不刻都在访问属性，那么对于JS来说，快速的属性访问就是必不可少的。这时，对于几个拥有相同属性的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>它们有相同的键值对，我们可以说它们有相同的<code>Shape</code>(即<code>key</code>)，对于这种数据，JS如果在每个对象中都存储这些重复的数据，就会造成大量重复且不必要的内存开销。所以Javascript引擎会将这些对象的<code>Shape</code>和<code>Value</code>分开存储</p>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/js-shape.png" alt=""></p>
<p>这样对于相同的对象只需要存储一个<code>Shape</code>就可以了，每一个具有相同<code>Shape</code>的对象都会指向这个<code>Shape</code>实例</p>
<blockquote>
<p>所有JavaScript引擎都使用Shape作为优化，但它们并不都称之为Shape</p>
</blockquote>
<ul>
<li>学术论文称之为Hidden Classes</li>
<li>V8称之为Maps</li>
<li>Chakra称之为Types</li>
<li>JavaScriptCore称之为Structures</li>
<li>SpiderMonkey称之为Shapes，演讲中统一使用了Shape</li>
</ul>
<h3 id="过渡链"><a href="#过渡链" class="headerlink" title="过渡链"></a>过渡链</h3><p>如果我们为一个对象添加或者删除了一个熟悉，那么Javascript引擎如何找到这个对象的新的Shape？其实很简单</p>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/js-shape-trans.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line">obj1.a = <span class="number">1</span></span><br><span class="line">obj1.b = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>大家都是聪明人，一眼就能看懂吧，但是我们甚至不需要存储一个完整的<code>Shape</code>，我们只需要知道新引入进来的属性即可</p>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/js-shape-trans-more2.png" alt=""></p>
<p>如果你要找obj1.a，那么只需要顺着过渡链找到引用了<code>a</code>的<code>Shape</code>即可</p>
<p>如果我们无法创建一个过渡链会怎样？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line">obj1.a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</span><br><span class="line">obj2.b = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>也很简单，构建一个树形分支结构即可，建立一个过渡树</p>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/js-shape-tree.png" alt=""></p>
<p>对于一种特殊情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line">obj1.a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p5sf6v0wz.bkt.clouddn.com/js-shape=tree-empty.png" alt=""></p>
<blockquote>
<p>对于初始化就包含属性的对象，其过渡链跳过了empty，优化缩短了过渡链</p>
</blockquote>
<h3 id="内存联缓（ICs）"><a href="#内存联缓（ICs）" class="headerlink" title="内存联缓（ICs）"></a>内存联缓（ICs）</h3><p>JavaScript引擎使用ICs来记住在何处查找对象属性的信息，以减少查找次数。假如有一个获取对象内部值的函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> o.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16411f1b7217d045?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>第一个<code>get_by_id</code>指令从第一个参数（arg1）加载属性“x”，并将结果存储到loc0中。第二个指令返回我们存储到的LoC0。<br>JSC还将内联缓存嵌入到<code>get_by_id</code>指令中，该指令由两个未初始化的槽组成</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16411f6118ecaea0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>现在假设我们使用{x：“a”}参数来调用getX。如我们所知，这个对象指向有属性“x”的Shape，并且该Shape存储了属性“x”的偏移量和描述对象。当第一次执行该函数时，get_by_id指令查找属性“x”，并发现该值被存储在偏移量0</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16411f68e5c06ab2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>嵌入到get_by_id指令中的IC记住了这个属性是从哪个Shape以及偏移量中找到的</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16411f70abbe30f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>对于后续的运行，IC只需要比较Shape，如果它与以前相同，只需从存储的偏移量中加载值即可。具体地说，如果JavaScript引擎看到对象指向了IC之前记录的Shape，那么就不需要重新去查找，可以完全跳过昂贵的属性查找。这比每次查找属性要快得多。</p>
<h2 id="有效存储数组"><a href="#有效存储数组" class="headerlink" title="有效存储数组"></a>有效存储数组</h2><p>数组使用数组索引来存储属性。这些属性的值称为数组元素。为每个数组元素存储描述对象是不明智的。数组索引属性默认为可写、可枚举和可配置，JavaScript引擎将数组元素与其他属性分开存储。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">  <span class="string">'#jsconfeu'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>引擎存储的数组长度为1，并指向包含length的Shape，偏移值为0。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16411ff1f8046d1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16411ffa76bf36bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>每个数组都有一个单独的元素后备存储区，它包含所有数组索引的属性值。JavaScript引擎不必为每个数组元素存储任何描述对象，因为它们通常都是可写的、可枚举的和可配置的。<br>如果更改数组元素的描述对象，会怎么样？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Please don’t ever do this!</span></span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">  [],</span><br><span class="line">  <span class="string">'0'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    value: <span class="string">'Oh noes!!1'</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的代码段定义了一个名为“0”的属性（恰好是一个数组索引），但它将属性设置为非默认值。</p>
<p>在这样的极端情况下，JavaScript引擎将整个元素后备存储区作为字典，映射描述对象到每个数组索引。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/18/1641200f5b4b4c5f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>即使只有一个数组元素有非默认描述对象，整个数组的元素后备存储区也会进入这个缓慢而低效的模式。避免在元素索引上使用Object.defineProperty！</p>
<blockquote>
<p>文章改编于<a href="https://juejin.im/post/5b275178f265da59a23f19cf" target="_blank" rel="noopener">《【JSConf EU 2018】JavaScript引擎: 精粹部分》</a></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">AddOneG</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/06/24/Javascript引擎之属性访问优化/">http://yoursite.com/2018/06/24/Javascript引擎之属性访问优化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Javascript/">Javascript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/19/async-await通读/"><i class="fa fa-chevron-left">  </i><span>async/await通读</span></a></div><div class="next-post pull-right"><a href="/2018/06/15/软件杯H5端-视频尬舞机-开发记录/"><span>软件杯H5端'视频尬舞机'开发记录</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By AddOneG</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>