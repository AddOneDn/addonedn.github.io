<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JS高级技巧(简洁版)"><meta name="keywords" content="前端,Javascript"><meta name="author" content="AddOneG,undefined"><meta name="copyright" content="AddOneG"><title>JS高级技巧(简洁版) | AddOneG</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#高级函数"><span class="toc-number">1.</span> <span class="toc-text">高级函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安全的类型检测"><span class="toc-number">1.1.</span> <span class="toc-text">安全的类型检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">1.1.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">1.1.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype-toString"><span class="toc-number">1.1.3.</span> <span class="toc-text">Object.prototype.toString</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域安全的构造函数"><span class="toc-number">1.2.</span> <span class="toc-text">作用域安全的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#惰性载入函数"><span class="toc-number">1.3.</span> <span class="toc-text">惰性载入函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数绑定"><span class="toc-number">1.4.</span> <span class="toc-text">函数绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数柯里化"><span class="toc-number">1.5.</span> <span class="toc-text">函数柯里化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#防篡改对象"><span class="toc-number">2.</span> <span class="toc-text">防篡改对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不可扩展对象"><span class="toc-number">2.1.</span> <span class="toc-text">不可扩展对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#密封的对象"><span class="toc-number">2.2.</span> <span class="toc-text">密封的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冻结的对象"><span class="toc-number">2.3.</span> <span class="toc-text">冻结的对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高级定时器"><span class="toc-number">3.</span> <span class="toc-text">高级定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重复的定时器"><span class="toc-number">3.1.</span> <span class="toc-text">重复的定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Yielding-Processes"><span class="toc-number">3.2.</span> <span class="toc-text">Yielding Processes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数节流-Throttle"><span class="toc-number">3.3.</span> <span class="toc-text">函数节流(Throttle)</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://p5sf6v0wz.bkt.clouddn.com/avatar.jpg"></div><div class="author-info__name text-center">AddOneG</div><div class="author-info__description text-center">我本嘉宾，何惧无笙</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">21</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://blog.triplez.cn/" target="_blank">TripleZ</a><a class="author-info-links__name text-center" href="http://karlrixon.link/" target="_blank">karlrixon</a><a class="author-info-links__name text-center" href="http://qrzbing.cn/" target="_blank">a-Lie-Z</a><a class="author-info-links__name text-center" href="https://primykq.top/" target="_blank">Primykq</a><a class="author-info-links__name text-center" href="https://blog.zeddyu.info/" target="_blank">Zedd</a><a class="author-info-links__name text-center" href="https://yuwenjie.cc/" target="_blank">Seiry</a><a class="author-info-links__name text-center" href="https://mountainlovers.github.io/" target="_blank">Mountain_lovers</a><a class="author-info-links__name text-center" href="https://blog.rexskz.info/" target="_blank">Rex</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">AddOneG</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">JS高级技巧(简洁版)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Javascript/"> Javascript</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,937</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></span></div><div id="post-content"><h1 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h1><p>由于在<code>JS</code>中，所有的函数都是对象，所以使用函数指针十分简单，也是这些东西使<code>JS</code>函数有趣且强大</p>
<h2 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h2><p><code>JS</code>内置的类型检测机制并不是完全可靠的</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>操作符返回一个字符串，表示未经计算的操作数的类型，在大多数情况下很靠谱，但是当然还有例外</p>
<p>正则表达式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> /s/ === <span class="string">'function'</span>; <span class="comment">// Chrome 1-12 , 不符合 ECMAScript 5.1</span></span><br><span class="line"><span class="keyword">typeof</span> /s/ === <span class="string">'object'</span>; <span class="comment">// Firefox 5+ , 符合 ECMAScript 5.1</span></span><br></pre></td></tr></table></figure></p>
<p>NULL<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span>; <span class="comment">// 从一开始出现JavaScript就是这样的</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在 <code>JavaScript</code> 最初的实现中，<code>JavaScript</code> 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 <code>0x00</code>），因此，<code>null</code>的类型标签也成为了 0，<code>typeof null</code>就错误的返回了<code>object</code></p>
</blockquote>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>运算符用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性</p>
<p>语法</p>
<blockquote>
<p>object instanceof constructor(要检测的对象 instanceof 构造函数)</p>
</blockquote>
<p>但是在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">window</span>.frames[<span class="number">0</span>].Array        <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>Array.prototype !== window.frames[0].Array.prototype</code>，因此你必须使用 <code>Array.isArray(myObj)</code> 或者 <code>Object.prototype.toString.call(myObj) === &quot;[object Array]&quot;</code>来判断<code>myObj</code>是否是数组</p>
<p>解决以上两个问题的方案就是<code>Object.prototype.toString</code></p>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>方法返回一个表示该对象的字符串</p>
<p>可以通过<code>toString()</code> 来获取每个对象的类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code>的形式来调用，传递要检查的对象作为第一个参数，称为<code>thisArg</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line">toString.call(<span class="regexp">/s/</span>); <span class="comment">// [object RegExp]</span></span><br><span class="line">toString.call([]); <span class="comment">// [object Array]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h2><p>构造函数其实就是一个使用<code>new</code>操作符调用的函数。当使用<code>new</code>调用时，构造函数内用到的<code>this</code>对象会指向新创建的对象实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">"addone"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">person.name <span class="comment">// addone</span></span><br></pre></td></tr></table></figure>
<p>当你使用<code>new</code>操作符的时候，就会创建一个新的<code>Person</code>对象，同时分配这些属性，但是如果你没有使用<code>new</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = Person(<span class="string">"addone"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">person1.name <span class="comment">// Cannot read property 'name' of undefined</span></span><br><span class="line"><span class="built_in">window</span>.name <span class="comment">// addone</span></span><br></pre></td></tr></table></figure>
<p>这是因为<code>this</code>是在执行时确认的，当你没有使用<code>new</code>，那么<code>this</code>在当前情况下就被解析成了<code>window</code>，属性就被分配到<code>window</code>上了</p>
<p>作用域安全的构造函数在进行更改前，首先确认<code>this</code>对象是正确类型的实例，如果不是，就创建新的对象并且返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;     </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"addone"</span>, <span class="number">20</span>);</span><br><span class="line">person1.name <span class="comment">// addone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = Person(<span class="string">"addone"</span>, <span class="number">20</span>);</span><br><span class="line">person2.name <span class="comment">// addone</span></span><br></pre></td></tr></table></figure>
<p><code>this instanceof Person</code>检查了<code>this</code>对象是不是<code>Person</code>的实例，如果是则继续，不是则调用<code>new</code></p>
<h2 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h2><p>假如你要写一个函数，里面有一些判断语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'aaa'</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'bbb'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你的<code>a</code>和<code>b</code>是不变的，那么这个函数不论执行多少次，结果都是不变的，但是每次执行还要进行<code>if</code>判断，这就造成了不必要的浪费。</p>
<p>惰性载入表示函数执行的分支只会发生一次，这里有两种解决方式。</p>
<p><strong>在函数被调用时再处理函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">        foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'aaa'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'bbb'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样进入每个分支后都会对<code>foo</code>进行赋值，覆盖了之前的函数，之后每次调用<code>foo</code>就不会再执行<code>if</code>判断</p>
<p><strong>在声明函数时就指定适当的函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'aaa'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'bbb'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>这里创建一个匿名，自执行的函数，用来确定应该使用哪一个函数来实现。</p>
<blockquote>
<p>惰性函数的优点就是只在第一次执行分支时牺牲一点点性能</p>
</blockquote>
<h2 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h2><p>请使用<code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>
<p><strong>thisArg</strong></p>
<p>当绑定函数被调用时，该参数会作为原函数运行时的 <code>this</code> 指向。当使用<code>new</code> 操作符调用绑定函数时，该参数无效</p>
<p><strong>arg1,arg2,…</strong></p>
<p>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法</p>
<p><strong>返回</strong></p>
<p> 由指定的this值和初始化参数改造的原函数拷贝</p>
<p> <strong>一个例子</strong></p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">   name: <span class="string">'addone'</span>,</span><br><span class="line">   click: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">EventUtil.addHandle(btn, <span class="string">'click'</span>, person.click);</span><br></pre></td></tr></table></figure>
<p> 这里创建了一个<code>person</code>对象，然后将<code>person.click</code>方法分配给<code>DOM</code>按钮的事件处理程序，当你点击按按钮时，会打印出<code>undefiend</code>，原因是执行时<code>this</code>指向了<code>DOM</code>按钮而不是<code>person</code></p>
<p> 解决方案： 将<code>this</code>强行指向<code>person</code></p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandle(btn, <span class="string">'click'</span>, person.click.bind(person));</span><br></pre></td></tr></table></figure>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>函数柯里化是把接受多个参数的函数转变成接受单一参数的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryAdd</span>(<span class="params">num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">1</span>, num2);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 5</span></span><br><span class="line">curryAdd(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子用来方便理解柯里化的概念</p>
</blockquote>
<p>下面是创建函数柯里化的通用方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">let</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数是要进行柯里化的函数，其他参数是要传入的值。这里使用<code>Array.prototype.slice.call(arguments, 1)</code>来获取第一个参数后的所有参数(外部)。在返回的函数中，同样调用<code>Array.prototype.slice.call(arguments)</code>让<code>innerArgs</code>来存放所有的参数(内部)，然后用<code>concat</code>将内部外部参数组合，用<code>apply</code>传递给函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> curryAdd1 = curry(add, <span class="number">1</span>);</span><br><span class="line">curryAdd1(<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curryAdd2 = curry(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">curryAdd2(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h1 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h1><p><code>Javascript</code>中任何对象都可以被同一环境中运行的代码修改，所以开发人员有时候需要定义<strong>防篡改对象（tamper-proof object)</strong> 来保护自己</p>
<h2 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h2><p>默认情况下所有对象都是可以扩展的(添加属性和方法)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'addone'</span> &#125;;</span><br><span class="line">person.age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>第二行为<code>person</code>对象扩展了<code>age</code>属性，当然你可以阻止这一行为，使用<code>Object.preventExtensions()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'addone'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(person);</span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">person.age <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>你还可以用<code>Object.isExtensible()</code>来判断对象是不是可扩展的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'addone'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(person);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(person); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请记住这是<strong>不可扩展!!</strong>，即不能添加属性或方法</p>
</blockquote>
<h2 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h2><p>密封对象不可扩展，且不能删除属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'addone'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(person);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"></span><br><span class="line">person.age <span class="comment">// undefined</span></span><br><span class="line">person.name <span class="comment">// addone</span></span><br></pre></td></tr></table></figure>
<p>相对的也有<code>Object.isSealed()</code>来判断是否密封</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'addone'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.isSealed(person); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(person);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.isSealed(person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="冻结的对象"><a href="#冻结的对象" class="headerlink" title="冻结的对象"></a>冻结的对象</h2><p>这是最严格的防篡改级别，冻结的对象即不可扩展，又密封，且不能修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'addone'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">person.name = <span class="string">'addtwo'</span></span><br><span class="line"></span><br><span class="line">person.age <span class="comment">// undefined</span></span><br><span class="line">person.name <span class="comment">// addone</span></span><br></pre></td></tr></table></figure>
<p>同样也有<code>Object.isFrozen</code>来检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'addone'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.isSealed(person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.isFrozen(person); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.isSealed(person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.isFrozen(person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上三种方法在严格模式下进行错误操作均会导致抛出错误</p>
</blockquote>
<h1 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h1><p><strong>阅读前提</strong></p>
<p>大概理解<code>setTimeout</code>的基本执行机制和<code>js</code>事件机制</p>
<h2 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h2><p>当你使用<code>setInterval</code>重复定义多个定时器的时候，可能会出现<strong>某个定时器代码在代码再次被添加到执行队列之前还没有完成执行</strong>，导致定时器代码连续执行多次。</p>
<p>机智<code>Javascript</code>引擎解决了这个问题，使用<code>setInterval()</code>的时候，仅当没有该定时器的其他代码实例时，才会将定时器代码添加到队列中。但这还会导致一些问题:</p>
<ul>
<li>某些间隔被跳过</li>
<li>间隔可能比预期的小</li>
</ul>
<p>为了避免这个两个问题，你可以使用链式<code>setTimeout()</code>调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    TODO();</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="built_in">arguments</span>.callee, interval);</span><br><span class="line">&#125;, interval)</span><br></pre></td></tr></table></figure>
<p><code>arguments.callee</code>获取了当前执行函数的引用，然后为其设置另外一个定时器，这样就确保在下一次定时器代码执行前，必须等待指定的间隔。</p>
<h2 id="Yielding-Processes"><a href="#Yielding-Processes" class="headerlink" title="Yielding Processes"></a>Yielding Processes</h2><p>浏览器对长时间运行的脚本进行了制约，如果代码运行超过特定的时间或者特定语句数量就不会继续执行。</p>
<p>如果你发现某个循环占用了大量的时间，那么对于下面这两个问题</p>
<ul>
<li>该处理是否必须同步完成?</li>
<li>数据是否必须按顺序完成?</li>
</ul>
<p>如果你的两个答案都是”否”，那么你可以使用一种叫做<strong>数组分块(array chunking)</strong> 的技术。基本思路是为要处理的项目创建一个队列，然后使用定时器取出下一个要出处理的项目进行处理，然后再设置另一个定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">array, process, context</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 取出下一个项目进行处理</span></span><br><span class="line">        <span class="keyword">let</span> item = array.shift();</span><br><span class="line">        process.call(item);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里接受三个参数，要处理的数组，处理的函数，运行该函数的环境(可选)，这里设置间隔<code>100ms</code>是个效果不错的选择</p>
<blockquote>
<p>如果你一个函数需要50ms以上时间完成，那么最好看看能否将任务分割成一系列可以使用定时器的小任务</p>
</blockquote>
<h2 id="函数节流-Throttle"><a href="#函数节流-Throttle" class="headerlink" title="函数节流(Throttle)"></a>函数节流(Throttle)</h2><p>节流的目的是防止某些操作执行的太快。比如在调整浏览器大小的时候会出发<code>onresize</code>事件，如果在其内部进行一些<code>DOM</code>操作，这种高频率的更爱可能会使浏览器崩溃。为了避免这种情况，可以采取函数节流的方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>)</span>&#123;</span><br><span class="line">    clearTimeout(method.tId);</span><br><span class="line">    method.tId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        method.call(context);</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里接受两个参数，要执行的函数，执行的环境。执行时先清除之前的定时器，然后将当前定时器赋值给方法的<code>tId</code>，之后调用<code>call</code>来确定函数的执行环境。</p>
<p>一个应用的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeDiv</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span><br><span class="line">    div.style.height = div.offsetWidth + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    throttle(resizeDiv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个就不用讲了吧2333</p>
</blockquote>
<p><strong>文章参考于《JavaScript高级程序设计(第三版)》</strong></p>
<p>如果你觉得我的理解有问题或者整理的太简略，那么我强烈安利你自己去读一下这本书~</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">AddOneG</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/05/07/你需要知道的JS高级技巧/">http://yoursite.com/2018/05/07/你需要知道的JS高级技巧/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端</a><a class="post-meta__tags" href="/tags/Javascript/">Javascript</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2018/05/06/前端开发者如何快速的把UI撸出来-讽刺版/"><span>前端开发者如何快速的把UI撸出来?(讽刺版)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By AddOneG</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>