<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从“零”开始 ：Spring MVC]]></title>
    <url>%2F2018%2F05%2F06%2F%E4%BB%8E%E2%80%9C%E9%9B%B6%E2%80%9D%E5%BC%80%E5%A7%8B-%EF%BC%9ASpring-MVC%2F</url>
    <content type="text"><![CDATA[该系列博客由我的同学汤茂行独立完成，仅在这里提供链接，欢迎访问博客地址]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICS2017 Programming Assignment 2.2-2.3]]></title>
    <url>%2F2018%2F05%2F06%2FICS2017-Programming-Assignment-2-2-2-3%2F</url>
    <content type="text"><![CDATA[PA2.2 程序，运行时的环境与AM运行更多的程序让项目默认编译到x86-nemu中的AM中1234// nexus-am/Makefile.checkARCH ?= x86-nemuARCHS = $(shell ls $(AM_HOME)/am/arch/) 然后在nexus-am/tests/cputest中执行 1make ALL=xxx run xxx为程序名(无.c后缀) 实现更多的指令在完成更多指令之前我们要先完成rtl.h中的辅助函数 1234567#define make_rtl_setget_eflags(f) \ static inline void concat(rtl_set_, f) (const rtlreg_t* src) &#123; \ cpu.eflags.f = *src; \ &#125; \ static inline void concat(rtl_get_, f) (rtlreg_t* dest) &#123; \ *dest = cpu.eflags.f; \ &#125; 根据提示简单的完成标志位赋值 1234static inline void rtl_not(rtlreg_t* dest) &#123; // dest &lt;- ~dest rtl_li(dest,~(*dest));&#125; 取反 12345static inline void rtl_update_ZF(const rtlreg_t* result, int width) &#123; // eflags.ZF &lt;- is_zero(result[width * 8 - 1 .. 0]) assert (width == 4 || width == 2 || width == 1); cpu.eflags.ZF = (*result &amp; ~(0xffffffff &lt;&lt; (8 * width - 1) &lt;&lt; 1)) == 0;&#125; 根据提示更新ZF位，同时判断长度width 12345static inline void rtl_update_SF(const rtlreg_t* result, int width) &#123; // eflags.SF &lt;- is_sign(result[width * 8 - 1 .. 0]) assert (width == 4 || width == 2 || width == 1); cpu.eflags.SF = (*result &gt;&gt; (8 * width - 1)) &amp; 0x1;&#125; 根据提示更新SF位，同时判断长度width 完成指令主要任务是完成nemu/src/cpu/exec/下每个文件的TODO，先在该目录下执行ls看一下文件 1all-instr.h arith.c cc.c control.c data-mov.c exec.c logic.c prefix.c special.c system.c 接下来我们按ls展示的文件顺序进行分析 all-instr.hall-instr.h为你写的函数定义的文件，先看看在文件完成后定义的全部指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354include "cpu/exec.h"make_EHelper(mov);make_EHelper(operand_size);make_EHelper(cltd);make_EHelper(cwtl);make_EHelper(idiv);make_EHelper(div);make_EHelper(sbb);make_EHelper(dec);make_EHelper(shl);make_EHelper(sar);make_EHelper(or);make_EHelper(adc);make_EHelper(dec);make_EHelper(mul);make_EHelper(imul);make_EHelper(imul1);make_EHelper(imul2);make_EHelper(jmp_rm);make_EHelper(jmp);make_EHelper(inc);make_EHelper(leave);make_EHelper(cltd);make_EHelper(jcc);make_EHelper(test);make_EHelper(movzx);make_EHelper(movsx);make_EHelper(setcc);make_EHelper(nop);make_EHelper(xchg);make_EHelper(and);make_EHelper(leave);make_EHelper(cltd);make_EHelper(dec);make_EHelper(cmp);make_EHelper(neg);make_EHelper(not);make_EHelper(or);make_EHelper(shr);make_EHelper(sar);make_EHelper(lea);make_EHelper(add);make_EHelper(inv);make_EHelper(nemu_trap);make_EHelper(call);make_EHelper(call_rm);make_EHelper(push);make_EHelper(sub);make_EHelper(pop);make_EHelper(xor);make_EHelper(ret); arith.cAdd1234567891011121314151617make_EHelper(add) &#123; rtl_add(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); rtl_sltu(&amp;t0, &amp;t2, &amp;id_dest-&gt;val); rtl_set_CF(&amp;t0); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_not(&amp;t0); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;t2); rtl_and(&amp;t0, &amp;t0, &amp;t1); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template2(add);&#125; 查看i386手册，ADD执行两个操作数（DEST和SRC）的整数相加。 加法结果被分配给第一个操作数（DEST），并相应地设置标志位，当立即字节被添加到字或双字操作数时，立即值被符号扩展为字或双字的大小的操作数，发现其与Adc相似，只需修改部分即可，然后填入opcode table中 12345make_group(gp1, EX(add),..../* 0x00 */ IDEXW(G2E, add, 1), IDEX(G2E, add), IDEXW(E2G, add, 1), IDEX(E2G, add),/* 0x04 */ IDEXW(I2a, add, 1), IDEX(I2a, add), EMPTY, EMPTY, 译码函数查询decode.c,同时对照i386手册填写即可，以下不在赘述 Sub1234567891011121314151617make_EHelper(sub) &#123; rtl_sub(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); rtl_sltu(&amp;t0, &amp;id_dest-&gt;val, &amp;t2); rtl_set_CF(&amp;t0); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;t2); rtl_and(&amp;t0, &amp;t0, &amp;t1); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template2(sub);&#125; SUB从第一个操作数（DEST）中减去第二个操作数（SRC）。 第一个操作数分配了相减的结果，并相应地设置标志。当从字操作数中减去一个立即字节值时，立即值首先被符号扩展为目标操作数的大小。根据Add指令相反的写Sub即可，也可以参考Sbb指令 12/* 0x28 */ IDEXW(G2E, sub, 1), IDEX(G2E, sub), IDEXW(E2G, sub, 1), IDEX(E2G, sub),/* 0x2c */ IDEXW(I2a, sub, 1), IDEX(I2a, sub), EMPTY, EMPTY, Cmp12345678910111213141516make_EHelper(cmp) &#123; rtl_sub(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_update_ZFSF(&amp;t0, id_dest-&gt;width); rtl_sltu(&amp;t1, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_set_CF(&amp;t1); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;t0); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_and(&amp;t0, &amp;t1, &amp;t0); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template2(cmp);&#125; Cmp指令很简单，与Sub十分类似只是不需要写回，所以只要把operand_write(id_dest, &amp;)去掉即可 123456make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp)）/* 0x38 */ IDEXW(G2E, cmp, 1), IDEX(G2E, cmp), IDEXW(E2G, cmp, 1), IDEX(E2G, cmp),/* 0x3c */ IDEXW(I2a, cmp, 1), IDEX(I2a, cmp), EMPTY, EMPTY, Inc12345678910111213make_EHelper(inc) &#123; rtl_addi(&amp;t0, &amp;id_dest-&gt;val, 1); operand_write(id_dest, &amp;t0); rtl_update_ZFSF(&amp;t0, id_dest-&gt;width); rtl_eqi(&amp;t1, &amp;id_dest-&gt;val, 0xffffffff); rtl_set_CF(&amp;t1); rtl_slt(&amp;t1, &amp;t0, &amp;id_dest-&gt;val); rtl_set_OF(&amp;t1); print_asm_template1(inc);&#125; INC在操作数上加1。 它不会更改进位标志。 要影响进位标志，请使用第二个操作数为1的ADD指令。解释很明确，使用Addi指令，然后更新标志位即可 123456make_group(gp4, EX(inc), EX(dec), EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)/* 0x40 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc),/* 0x44 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), Dec1234567891011121314make_EHelper(dec) &#123; rtl_subi(&amp;t2, &amp;id_dest-&gt;val, 1); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;t2); rtl_and(&amp;t0, &amp;t0, &amp;t1); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template1(dec);&#125; DEC从操作数中减去1。 DEC不会更改进位标志。 要影响进位标志，请使用立即操作数为1的SUB指令。这里和上面的Inc类似，使用subi指令，然后照着Inc反着写Dec，更新标志位即可 123456make_group(gp4, EX(inc), EX(dec), EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)/* 0x48 */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec),/* 0x4c */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), Neg1234567891011121314151617make_EHelper(neg) &#123; rtl_mv(&amp;t0, &amp;id_dest-&gt;val); rtl_not(&amp;t0); rtl_addi(&amp;t0, &amp;t0, 1); operand_write(id_dest, &amp;t0); rtl_eq0(&amp;t1, &amp;id_dest-&gt;val); rtl_set_CF(&amp;t1); rtl_update_ZFSF(&amp;t0, id_dest-&gt;width); rtl_xor(&amp;t1, &amp;t0, &amp;id_dest-&gt;val); rtl_not(&amp;t1); rtl_msb(&amp;t1, &amp;t1, id_dest-&gt;width); rtl_set_OF(&amp;t1); print_asm_template1(neg);&#125; Neg用其二进制补码替代寄存器或存储器操作数的值。操作数从零中减去，结果放在操作数中。进位标志被设置为1，除非操作数为零，在这种情况下，进位标志被清除为0。根据描述调用相应的rtl函数即可 123make_group(gp3, IDEX(test_I, test), EMPTY, EX(not), EX(neg), EX(mul), EX(imul1), EX(div), EX(idiv)) control.cret12345make_EHelper(ret) &#123; rtl_pop(&amp;decoding.jmp_eip); decoding.is_jmp = 1; print_asm("ret");&#125; RET将控制权转交给位于堆栈上的返回地址。地址通常由CALL指令放置在堆栈上，并返回到CALL之后的指令。简单来说就是把jmp_eip推出然后设置跳转即可 1/* 0xc0 */ IDEXW(gp2_Ib2E, gp2, 1), IDEX(gp2_Ib2E, gp2), EMPTY, EX(ret), data-mov.cleave123456make_EHelper(leave) &#123; rtl_mv(&amp;cpu.esp, &amp;cpu.ebp); rtl_pop(&amp;cpu.ebp); print_asm("leave");&#125; LEAVE反转ENTER指令的动作。通过将帧指针复制到堆栈指针，LEAVE释放过程为其局部变量使用的堆栈空间。旧的帧指针被弹出到BP或EBP中，恢复调用者的帧。 随后的RET指令将删除所有推送到退出过程堆栈上的参数。简单来说就是将ebp赋值给esp然后推出ebp，调用rtl函数直接完成 1/* 0xc8 */ EMPTY, EX(leave), EMPTY, EMPTY, cltd123456789101112131415161718192021222324make_EHelper(cltd) &#123; if (decoding.is_operand_size_16) &#123; rtl_lr(&amp;t0, R_AX, 2); if ((int32_t)(int16_t)(uint16_t)t0 &lt; 0) &#123; rtl_addi(&amp;t1, &amp;tzero, 0xffff); rtl_sr(R_DX, 2, &amp;t1); &#125; else &#123; rtl_sr(R_DX, 2, &amp;tzero); &#125; &#125; else &#123; rtl_lr(&amp;t0, R_EAX, 4); if ((int32_t)t0 &lt; 0) &#123; rtl_addi(&amp;t1, &amp;tzero, 0xffffffff); rtl_sr(R_EDX, 4, &amp;t1); &#125; else &#123; rtl_sr(R_EDX, 4, &amp;tzero); &#125; &#125; print_asm(decoding.is_operand_size_16 ? "cwtl" : "cltd");&#125; CLD清除方向标志。 没有其他标志或寄存器受到影响。 CLD执行后，字符串操作会增加它们使用的索引寄存器（SI和/或DI)。 1/* 0x98 */ EX(cwtl), EX(cltd), EMPTY, EMPTY, logic.ctest1234567make_EHelper(test) &#123; rtl_and(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_set_CF(&amp;tzero); rtl_set_OF(&amp;tzero); rtl_update_ZFSF(&amp;t2,id_dest-&gt;width); print_asm_template2(test);&#125; TEST计算其两个操作数的按位逻辑“与”。如果两个操作数的相应位都是1，结果为1; 否则，每一位都是0.操作的结果被丢弃，只有标志被修改。所以将两个操作数and之后仅设置标志位即可 12345make_group(gp3, IDEX(test_I, test), EMPTY, EX(not), EX(neg), EX(mul), EX(imul1), EX(div), EX(idiv))/* 0x84 */ IDEXW(G2E, test ,1), IDEX(G2E, test), EMPTY, EMPTY, and12345678make_EHelper(and) &#123; rtl_and(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_set_CF(&amp;tzero); rtl_set_OF(&amp;tzero); rtl_update_ZFSF(&amp;t2,id_dest-&gt;width); print_asm_template2(and);&#125; 如果操作数的两个相应位都是1，AND指令的结果的每一位都是1; 否则，它变成0。与Test类似，只需添加将结果写回即可。 123456make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp))/* 0x20 */ IDEXW(G2E, and, 1), IDEX(G2E, and), IDEXW(E2G, and, 1), IDEX(E2G, and),/* 0x24 */ IDEXW(I2a, and, 1), IDEX(I2a, and), EMPTY, EMPTY, or12345678make_EHelper(or) &#123; rtl_or(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_set_CF(&amp;tzero); rtl_set_OF(&amp;tzero); rtl_update_ZFSF(&amp;id_dest-&gt;val,id_dest-&gt;width); print_asm_template2(xor);&#125; OR计算其两个操作数的包含OR，并将结果放入第一个操作数中。 如果操作数的相应位都是0，结果的每一位都是0; 否则，每一位都是1。与And指令相同，只需将rtl_and修改为rtl_or即可 12345make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp))/* 0x08 */ IDEXW(G2E, or, 1), IDEX(G2E, or), IDEXW(E2G, or, 1), IDEX(E2G, or), sar12345678make_EHelper(sar) &#123; // unnecessary to update CF and OF in NEMU rtl_sar(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); print_asm_template2(sar);&#125; SAR向下移动操作数的位。低阶位移入进位标志。SAR执行有符号的分割，向负无穷大舍入（与IDIV不同; 高位保持不变。先判断操作数宽度进行扩展，然后调用rtl_sar函数，将结果写回并更新符号位。 12345678make_EHelper(shr) &#123; // unnecessary to update CF and OF in NEMU rtl_shr(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); print_asm_template2(shr);&#125; SHR与SAR类似,SHR执行未标记的划分; 高位被设置为0。写法与Sar类似，调用rtl_shr函数后写回，更新标志位 12345678make_EHelper(shl) &#123; // unnecessary to update CF and OF in NEMU rtl_shl(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); print_asm_template2(shl);&#125; SAL(或其同义词SHL）向上移动操作数的位。 高位移入进位标志，低位设为0。与上面两个指令类似，调用rtl_shl函数，将结果写回，更新标志位 以上三个函数根据提示不需要更新CF和OF位 123make_group(gp2, EMPTY, EMPTY, EMPTY, EMPTY, EX(shl), EX(shr), EMPTY, EX(sar)) setcc1234567make_EHelper(setcc) &#123; uint8_t subcode = decoding.opcode &amp; 0xf; rtl_setcc(&amp;t2, subcode); operand_write(id_dest, &amp;t2); print_asm("set%s %s", get_cc_name(subcode), id_dest-&gt;str);&#125; 在这里可以看到调用了rtl_setcc，我们要去cc.c文件中对指令进行补全 cc.c12345678910111213141516171819202122232425262728293031switch (subcode &amp; 0xe) &#123; case CC_O: rtl_li(dest, cpu.eflags.OF); break; case CC_B: rtl_li(dest, cpu.eflags.CF); break; case CC_E: rtl_get_ZF(&amp;t0); rtl_eqi(dest, &amp;t0, 1); break; case CC_NE: rtl_get_ZF(&amp;t0); rtl_neq0(dest, &amp;t0); break; case CC_BE: rtl_li(dest, ((cpu.eflags.CF) || (cpu.eflags.ZF))); break; case CC_S: rtl_li(dest, cpu.eflags.SF); break; case CC_L: rtl_li(dest, (cpu.eflags.SF != cpu.eflags.OF)); break; case CC_LE:&#123; rtl_li(dest, ((cpu.eflags.ZF) || (cpu.eflags.SF != cpu.eflags.OF))); break; &#125; default: panic("should not reach here"); case CC_P: panic("n86 does not have PF");&#125; 这里根据i386补全了部分需要用到的指令: CC_O: 将OF赋值给操作数 CC_B: 将CF赋值给操作数 CC_E: 获取ZF, 然后判断ZF是否为1，若是则dest为1，否则为0 CC_NE: 获取ZF, 然后判断ZF是否不等于0，若是则dest为1，否则为0 CC_BE: 将CF和ZF取或后结果赋值给dest CC_S: 将SF赋值给操作数 CC_L: 判断SF和OF是否相等，将结果赋值给dest CC_LE: 将ZF和SF是否不等于OF的结果取或，然后赋值给dest 最后附上完整的exec文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/* 0x80, 0x81, 0x83 */make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp))/* 0xc0, 0xc1, 0xd0, 0xd1, 0xd2, 0xd3 */make_group(gp2, EX(rol), EMPTY, EMPTY, EMPTY, EX(shl), EX(shr), EMPTY, EX(sar))/* 0xf6, 0xf7 */make_group(gp3, IDEX(test_I, test), EMPTY, EX(not), EX(neg), EX(mul), EX(imul1), EX(div), EX(idiv))/* 0xfe */make_group(gp4, EX(inc), EX(dec), EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)/* 0xff */make_group(gp5, EXW(inc, 2), EX(dec), EX(call_rm), EX(call), EX(jmp_rm), EMPTY, EX(push), EMPTY)/* 0x0f 0x01*/make_group(gp7, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)opcode_entry opcode_table [512] = &#123; /* 0x00 */ IDEXW(G2E, add, 1), IDEX(G2E, add), IDEXW(E2G, add, 1), IDEX(E2G, add), /* 0x04 */ IDEXW(I2a, add, 1), IDEX(I2a, add), EMPTY, EMPTY, /* 0x08 */ IDEXW(G2E, or, 1), IDEX(G2E, or), IDEXW(E2G, or, 1), IDEX(E2G, or), /* 0x0c */ IDEXW(I2a, or, 1), IDEX(I2a, or), EMPTY, EX(2byte_esc), /* 0x10 */ IDEXW(G2E, adc, 1), IDEX(G2E, adc), IDEXW(E2G, adc, 1), IDEX(E2G, adc), /* 0x14 */ IDEXW(I2a, adc, 1), IDEX(I2a, adc), EMPTY, EMPTY, /* 0x18 */ IDEXW(G2E, sbb, 1), IDEX(G2E, sbb), IDEXW(E2G, sbb, 1), IDEX(E2G, sbb), /* 0x1c */ IDEXW(I2a, sbb, 1), IDEX(I2a, sbb), EMPTY, EMPTY, /* 0x20 */ IDEXW(G2E, and, 1), IDEX(G2E, and), IDEXW(E2G, and, 1), IDEX(E2G, and), /* 0x24 */ IDEXW(I2a, and, 1), IDEX(I2a, and), EMPTY, EMPTY, /* 0x28 */ IDEXW(G2E, sub, 1), IDEX(G2E, sub), IDEXW(E2G, sub, 1), IDEX(E2G, sub), /* 0x2c */ IDEXW(I2a, sub, 1), IDEX(I2a, sub), EMPTY, EMPTY, /* 0x30 */ IDEX(G2E, xor), IDEX(G2E, xor), IDEX(E2G, xor), IDEX(E2G, xor), /* 0x34 */ IDEX(I2a, xor), IDEX(I2r, xor), EMPTY, EMPTY, /* 0x38 */ IDEXW(G2E, cmp, 1), IDEX(G2E, cmp), IDEXW(E2G, cmp, 1), IDEX(E2G, cmp), /* 0x3c */ IDEXW(I2a, cmp, 1), IDEX(I2a, cmp), EMPTY, EMPTY, /* 0x40 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), /* 0x44 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), /* 0x48 */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), /* 0x4c */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), /* 0x50 */ IDEX(r, push), IDEX(r, push), IDEX(r, push), IDEX(r, push), /* 0x54 */ IDEX(r, push), IDEX(r, push), IDEX(r, push), IDEX(r, push), /* 0x58 */ IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), /* 0x5c */ IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), /* 0x60 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x64 */ EMPTY, EMPTY, EX(operand_size), EMPTY, /* 0x68 */ IDEX(push_SI, push), EMPTY, IDEXW(push_SI, push, 1), EMPTY, /* 0x6c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x70 */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x74 */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x78 */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x7c */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x80 */ IDEXW(I2E, gp1, 1), IDEX(I2E, gp1), EMPTY, IDEX(SI2E, gp1), /* 0x84 */ IDEXW(G2E, test ,1), IDEX(G2E, test), EMPTY, EMPTY, /* 0x88 */ IDEXW(mov_G2E, mov, 1), IDEX(mov_G2E, mov), IDEXW(mov_E2G, mov, 1), IDEX(mov_E2G, mov), /* 0x8c */ EMPTY, IDEX(lea_M2G, lea), EMPTY, EMPTY, /* 0x90 */ EX(nop), EMPTY, EMPTY, EMPTY, /* 0x94 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x98 */ EX(cwtl), EX(cltd), EMPTY, EMPTY, /* 0x9c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa0 */ IDEXW(O2a, mov, 1), IDEX(O2a, mov), IDEXW(a2O, mov, 1), IDEX(a2O, mov), /* 0xa4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa8 */ IDEXW(I2a, test, 1), IDEX(I2a, test), EMPTY, EMPTY, /* 0xac */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xb0 */ IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), /* 0xb4 */ IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), /* 0xb8 */ IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), /* 0xbc */ IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), /* 0xc0 */ IDEXW(gp2_Ib2E, gp2, 1), IDEX(gp2_Ib2E, gp2), EMPTY, EX(ret), /* 0xc4 */ EMPTY, EMPTY, IDEXW(mov_I2E, mov, 1), IDEX(mov_I2E, mov), /* 0xc8 */ EMPTY, EX(leave), EMPTY, EMPTY, /* 0xcc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd0 */ IDEXW(gp2_1_E, gp2, 1), IDEX(gp2_1_E, gp2), IDEXW(gp2_cl2E, gp2, 1), IDEX(gp2_cl2E, gp2), /* 0xd4 */ EMPTY, EMPTY, EX(nemu_trap), EMPTY, /* 0xd8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xdc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe8 */ IDEX(I, call), IDEX(J, jmp), EMPTY, IDEXW(J, jmp, 1), /* 0xec */ IDEXW(in_dx2a, in, 1), IDEX(in_dx2a, in), IDEXW(out_a2dx, out, 1), IDEX(out_a2dx, out), /* 0xf0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf4 */ EMPTY, EMPTY, IDEXW(E, gp3, 1), IDEX(E, gp3), /* 0xf8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xfc */ EMPTY, EMPTY, IDEXW(E, gp4, 1), IDEX(E, gp5), /*2 byte_opcode_table */ /* 0x00 */ EMPTY, IDEX(gp7_E, gp7), EMPTY, EMPTY, /* 0x04 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x08 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x0c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x10 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x14 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x18 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x1c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x20 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x24 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x28 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x2c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x30 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x34 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x38 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x3c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x40 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x44 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x48 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x4c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x50 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x54 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x58 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x5c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x60 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x64 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x68 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x6c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x70 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x74 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x78 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x7c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x80 */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x84 */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x88 */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x8c */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x90 */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0x94 */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0x98 */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0x9c */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0xa0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xac */ EMPTY, EMPTY, EMPTY, IDEX(E2G, imul2), /* 0xb0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xb4 */ EMPTY, EMPTY, IDEXW(mov_E2G, movzx, 1), IDEXW(mov_E2G, movzx, 2), /* 0xb8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xbc */ EMPTY, EMPTY, IDEXW(mov_E2G, movsx, 1), IDEXW(mov_E2G, movsx, 2), /* 0xc0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xc4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xc8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xcc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xdc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xec */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xfc */ EMPTY, EMPTY, EMPTY, EMPTY&#125;; 基础设置(2)思考题 Differential Testing能帮你节省多少时间呢? 能节省我至少10个小时 Differential Testing先在nemu/include/common.h中定义DIFF_TEST 12#define DEBUG#define DIFF_TEST 然后在nemu/src/monitor/diff-test/diff-test.c文件中的difftest_step函数中 12345678910if(cpu.eip != r.eip)&#123; diff = true; printf("eip: nemu: 0x%x qemu: 0x%x \n",cpu.eip,r.eip);&#125;for(int i = 0 ; i &lt; 8 ; i++)&#123; if(reg_l(i) != r.array[i])&#123; diff = true; printf("%s: nemu: 0x%x qemu: 0x%x \n",regsl[i],reg_l(i),r.array[i]); &#125;&#125; 这里对eip和八个寄存器进行遍历比较，如果发现值不同则设置diff = true停止客户程序运行 一键回归测试在nemu目录执行 1bash runall.sh 全部样例跑通 思考题 你觉得该如何捕捉死循环 对程序设置最大运行时间，如果超过该时间则判断程序进入死循环 PA2.3 输入输出思考题 如果代码中的地址0x8049000最终被映射到一个设备寄存器，去掉volatile可能会带来什么问题? 变量如果加了 volatile 修饰，则会从内存重新装载内容，而不是直接从寄存器拷贝内容，去掉volatile会导致错误发生 实现Hello World1234567891011121314151617181920make_EHelper(in) &#123; t2 = pio_read(id_src-&gt;val, id_src-&gt;width); operand_write(id_dest, &amp;t2); print_asm_template2(in);#ifdef DIFF_TEST diff_test_skip_qemu();#endif&#125;make_EHelper(out) &#123; pio_write(id_dest-&gt;val, id_dest-&gt;width, id_src-&gt;val); print_asm_template2(out);#ifdef DIFF_TEST diff_test_skip_qemu();#endif&#125; in与out类似，分别调用pio_read和pio_write函数并传入相应参数即可，这里设置了is_skip_qemu标志来跳过QEMU检查，完成指令后在all-instr.h中定义 12make_EHelper(rol);make_EHelper(out); 在exec.c中填写opcode table 1/* 0xec */ IDEXW(in_dx2a, in, 1), IDEX(in_dx2a, in), IDEXW(out_a2dx, out, 1), IDEX(out_a2dx, out), 时钟在nexus-am/am/arch/x86-nemu/src/ioe.c中 1234567void _ioe_init() &#123; boot_time = inl(RTC_PORT);&#125;unsigned long _uptime() &#123; return inl(RTC_PORT) - boot_time;&#125; 可以看出inl(RTC_PORT)获取当前时间，boot_time为上一次时间，将两者相减返回即可 看看NEMU跑多快Dhrystone Coremark Microbench ref测试 test测试 键盘12345678int _read_key() &#123; uint32_t key_code = _KEY_NONE; if(inb(I8042_STATUS_PORT))&#123; key_code = inl(I8042_DATA_PORT); &#125; return key_code;&#125; 这里先判断端口I8042_STATUS_PORT是否开启，若开启则获取当前keycode即inl(I8042_DATA_PORT)，否则返回_KEY_NONE 思考题 如何检测多个键被同时按下？ 当检测到一个键被按下的时候，去检测此时其他是否有按键被按下 在一些90年代的游戏中，很多渐入渐出的效果都是通过调色板实现的，聪明的你知道其中的玄机么？ 将颜色模拟成类似透明的白色盖在其他颜色上面，模拟出渐变的颜色 添加内存映射I/O在nemu/src/memory/memory.c文件中 12345678910111213141516uint32_t paddr_read(paddr_t addr, int len) &#123; int port = is_mmio(addr); if(port != -1)&#123; return mmio_read(addr, len, port); &#125; return pmem_rw(addr, uint32_t) &amp; (~0u &gt;&gt; ((4 - len) &lt;&lt; 3));&#125;void paddr_write(paddr_t addr, int len, uint32_t data) &#123; int port = is_mmio(addr); if(port != -1)&#123; mmio_write(addr, len, data, port); &#125;else&#123; memcpy(guest_to_host(addr), &amp;data, len); &#125;&#125; 先用is_mmio函数判断物理地址是否被映射到I/O空间，对于paddr_read若返回-1则访问pmem，否则使用mmio_read函数读取port位置的内存，对于paddr_write，若不返回-1则调用mmio_write将数据写入port位置内存 实现IOE(3)123456void _draw_rect(const uint32_t *pixels, int x, int y, int w, int h) &#123; int i; for(i = 0; i &lt; h; i++) &#123; memcpy(fb + (y + i) * _screen.width + x, pixels + i * w, w * 4); &#125;&#125; 将pixels指定的的矩形像素绘制到屏幕中以(x, y)和(x+w, y+h)两点连线为对角线的矩形区域 必答题编译与链接 去掉static，去掉inline或去掉两者，然后重新进行编译，你会发现错误，请分别解释为什么会发生这些错误？你有办法证明你的想法么 当函数被声明static后，它只在定义它的源文件内有效，其他源文件无法访问，所以用来解决不同文件函数重名问题，如果去掉进行编译的话，若不同文件有相同函数名则会报错，证明可以将不同文件中的函数名里添加文件名进行区分，若不报错则想法正确 inline修饰的函数变为内联函数,同时和static类似，只有本地文件可见，允许多个文件内重复定义相同名的函数，错误与static类似，可能会报重复定义的错误，证明可以将不同文件中的函数名里添加文件名进行区分，若不报错则想法正确 编译与链接 在nemu/include/common.h中添加volatile static int dummy;后重新编译NEMU,请问重新编译后的NEMU有多少个dummy变量的实体，你是如何得到这个结果的 有1个。因为在这里用volatile定义了一个dummy 在上一问题条件下在nemu/include/debug.h中添加volatile static int dummy;,请问重新编译后的NEMU有多少个dummy变量的实体，与上题中dummy实体数目进行比较，并解释本题的结果 有2个。因为两个文件中都使用了volatile进行dummy的定义，所以不会发生冲突，为2个。 修改添加的代码，为两处dummy变量进行初始化volatile static int dummy = 0;,然后重新编译NEMU,你发现了什么问题？为什么之前没有出现这个问题 会报错。因为当volatile修饰的dummy被赋予了确定的值之后，两个dummy就指向了同一个内存地址，会发生重复定义的错误。 了解Makefile 请你描述在nemu目录下敲入make后，make程序如何组织.c和.h文件，最终生成可执行文件nemu/build/nemu(这个问题包含两个方面: makefile的工作方式和编译链接的过程) 在当前目录下找名字叫Makefile或makefile的文件 如果找到，它会找文件中的第一个目标文件，并把这个文件作为最终的目标文件 如果文件不存在，或是文件所依赖的后面的.o文件的文件修改时间要比这个文件新，那么，他就会执行后面所定义的命令来生成h这个文件，这个也就是重编译 如果文件所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。 .c文件和.h文件存在，于是make会生成 .o 文件 make会一层一层去找文件的依赖关系，直到最终编译出第一个目标文件，若是过程中出现了错误，make会直接退出并报错，直到最后生成可执行文件nemu]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成-程序的转换及机器级表示]]></title>
    <url>%2F2018%2F05%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[AT&amp;T汇编指令学习(GCC) 源/目的操作数顺序:AT&amp;T语法格式表示为:opcode src, dest: “操作码 源, 目标” 操作数长度标识:在AT&amp;T语法中,通过在指令后添加后缀来指明该指令运算对象的尺寸.后缀 b 指明运算对象是一个字节(byte)后缀 w 指明运算对象是一个字(word)后缀 l 指明运算对象是一个双字(long) 常数/立即数格式 在AT&amp;T语法中 对立即数,须在其前加前缀 $ 来指明 在常数前也必须加一个前缀字符 * 内存寻址方式 SECTION:DISP(BASE, INDEX, SCALE)，段:偏移量(基地址,变址,比例因子) 基本的行内汇编格式 asm(&quot;statements&quot;)例如：asm(&quot;nop&quot;); `asm(“movl %eax,%ebx”);asm 和 asm是完全一样的. 如果有多行汇编，则每一行都要加上\n\t` 常用指令 数据传送指令：move,push,pop 加载有效地址指令：leal 一元操作指令：inc(加1),dec(减1)，neg(取负)，not(取补) 二元操作指令：add,sub,imul,idivl(有符号除法),xor,or,and 移位指令：sal(左移),shl,sar(算数右移),shr(逻辑右移) 跳转指令：jmp,je,jne,js,jns,jg,jl,ja,jb,jbe… 几道题第一题对于以下 AT&amp;T格式汇编指令，根据操作数的长度确定对应指令助记符中的长度后缀，并说明每个操作数的寻址方式12345678mov 8(%ebp, %ebx, 4), %axmov %al, 12(%ebp)add (, %ebx, 4), %ebxor (%ebx), %dhpush $0xF8mov $0xFFF0, %eaxtest %cx,%cxlea 8(%ebx, %esi), %eax 参考答案 12345678w，基址+比例变址+偏移，寄存器b，寄存器，基址+偏移l，比例变址，寄存器b，基址，寄存器l，立即数，栈l，立即数，寄存器w，寄存器，寄存器l，基址+变址+偏移，寄存器 第二题假设x和ptr声明如下 123src_type x;dst_type ptr;*ptr = (dst_type)x; 若 x 存储在寄存器 EAX 或 AX 或 AL 中，ptr 存储在寄存器 EDX 中，写出实现上述赋值语句的机器级代码。要求用 AT&amp;T 格式汇编指令表示机器级代码 src_type dst_type 机器级表示 1234567char int movsbl %al, (%edx)int char movb %al, (%edx)int unsigned movl %eax, (%edx)short int movswl %ax, (%edx)unsigned char unsigned movzbl %al, (%edx)char unsigned movsbl %al, (%edx)int int movl %eax, (%edx) 关于Mov movb,movw,movl 分别表示：传送字节，传送字，传送双字 movsbw,movsbl,movswl,将做了符号扩展的字节传送到字，将做了符号扩展的字节传送到双字，将做了符号扩展的字传送到双字 movzbw,movzbl,movzwl,将做了零扩展的字节传送到字,将做了零扩展的字节传送到双字,将做了零扩展的字传送到双字]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能需要的一些微信小程序开发知识点]]></title>
    <url>%2F2018%2F05%2F03%2F%E6%88%91%E5%9C%A8%E5%86%99%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[背景一直以来进行了比较多的微信小程序开发… 总会接触到一些和官方组件或api相关或其无法解决的需求，于是决定在这里小小的整理一下自己的实现(次序不分先后) 自定义组件的使用 创建右键新建Component 引用在你需要引用的文件的json中定义 12345678"注释": "前面为组件名，后面为路径，这里仅供参考"&#123; "usingComponents": &#123; "Menu": "../Components/Menu/Menu", "Loading": "../Components/Loading/Loading" &#125;&#125; 传入属性 在组件的js中定义你需要的属性名,类型及默认值1234567properties: &#123; theme: &#123; type: String, value: 'gray' &#125; ...&#125;, 注意properties为父组件要传入的数据，组件自身状态还是在data中 然后在wxml中引用即可1&lt;Menu theme="&#123;&#123;theme&#125;&#125;"&gt;&lt;/Menu&gt; 一键换肤先创建一个color.wxss来存你的皮肤样式(文件名和位置随意) 12345678910/* 黑色主题 */.bg-black&#123; background-color: #363636;&#125;.col-black-title&#123; color: #ffffff;&#125;.col-black-name&#123; color: #c3c3c3;&#125; class名中必须带一个标志来区分不同主题，推荐使用颜色的英文名..然后在app.wxss中引用 12// ~ 为你的文件路径@import '~/color.wxss'; 之后在app.js的globalData中定义一个字段储存你当前主题 1234globalData: &#123; themeArr: ['gray', 'black', 'green', 'orange', 'pink', 'blue'], theme: 'black' // gray, black, green, orange, pink, blue&#125; 然后在js里引用app.js，然后在onLoad里获取theme后setData即可，这里贴上代码 12345678&lt;Menu theme="&#123;&#123;theme&#125;&#125;"&gt;&lt;/Menu&gt;&lt;block wx:for="&#123;&#123;themeArr&#125;&#125;" wx:key="&#123;&#123;index&#125;&#125;"&gt; &lt;view class="theme-view-item bg-&#123;&#123;item&#125;&#125; select-&#123;&#123;item == theme&#125;&#125;" bindtap='changeTheme' data-theme="&#123;&#123;item&#125;&#125;" &gt;&lt;/view&gt;&lt;/block&gt; 123456789.theme-view-item&#123; width: 80rpx; height: 40rpx; margin: 20rpx; border-radius: 10rpx;&#125;.select-true&#123; transform: scale(1.2,1.2);&#125; 1234567891011121314151617181920212223var app = getApp()Page(&#123; data: &#123; theme: '', themeArr: app.globalData.themeArr &#125;, onLoad: function (options) &#123; this.setData(&#123; theme: app.globalData.theme &#125;) &#125;, changeTheme(e)&#123; var theme = e.currentTarget.dataset.theme app.globalData.theme = theme this.setData(&#123; theme: theme &#125;) &#125;&#125;) 来个效果图 这里你也可以使用storage来保存theme 加载更多使用scroll-view 12345&lt;scroll-view scroll-y bindscrolltolower='toLow' style="height: &#123;&#123;height&#125;&#125;px"&gt; scroll-y允许纵向滚动，bindscrolltolower定义了滚动到底部时应该执行的函数，style中使用了js中获取的屏幕可用高度 使用scroll-y需要指定scroll的高度 1234567891011121314onLoad: function (options) &#123; wx.getSystemInfo(&#123; success: (res) =&gt; &#123; this.setData(&#123; height: res.windowHeight &#125;) &#125; &#125;)&#125;,toLow()&#123; this.setData(&#123; isLoading: true &#125;)&#125;, 然后在scroll下面放你的loading组件就可以了.. 12345678910&lt;scroll-view scroll-y bindscrolltolower='toLow' style="height: &#123;&#123;height&#125;&#125;px"&gt; ...... &lt;view hidden="&#123;&#123;!isLoading&#125;&#125;"&gt; &lt;Loading&gt;&lt;/Loading&gt; &lt;/view&gt;&lt;/scroll-view&gt; 下拉刷新这个功能用到的都是官方的api，先在app.json中定义允许下拉刷新 1234"window": &#123; ...... "enablePullDownRefresh": true&#125; 然后在你的js文件中定义相应的函数 1234onPullDownRefresh: function () &#123; ...... wx.stopPullDownRefresh()&#125;, 这个点可以看官方文档 自适应rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx= 375px = 750物理像素，1rpx = 0.5px = 1物理像素 如果不懂的话不用考虑太多，在用px的时候将其大小翻倍使用rpx即可 【微信小程序】——rpx、px、rem等尺寸间关系浅析 阻止事件冒泡假设有如下结构 123&lt;view class='A' bindtap='funcA'&gt; &lt;view class='B' bindtap='funcB'&gt;&lt;/view&gt;&lt;/view&gt; 我们在A,B上定义了两个独立的点击事件，懂得事件冒泡的童鞋会发现，如果点击B的话，不仅会执行funcB还会执行funcA，那么如何避免这个问题? 很简单，只需要将不需要冒泡的的绑定函数改成catchtap 123&lt;view class='A' bindtap='funcA'&gt; &lt;view class='B' catchtap='funcB'&gt;&lt;/view&gt;&lt;/view&gt; 如何去掉Button的默认边框将button自带的position: relative去掉即可 小程序登录接入流程一张图]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在mac上使用vscode编写markdown出现控制字符问题]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%85%B3%E4%BA%8E%E5%9C%A8mac%E4%B8%8A%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99markdown%E5%87%BA%E7%8E%B0%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景如题….遇到过无数次，所以今天终于决定解决一下 问题先放一个问题图 这是我的一篇GitHub上的README文件，能看到有好几个莫名的特殊字符 在网上搜了一下，在vscode设置中开启 12//控制编辑器是否应呈现控制字符&quot;editor.renderControlCharacters&quot;: true 然后就能看到这个鬼畜的东西 能看到那个小小的BS，搜了一下发现它是ASCII码中的退格符的Unicode表示法(所有ASCII控制字符都有一个图形外观)，其实这个Bug是chromium的，但是因为vscode底层是electron，electron底层又用的chromium，就导致vscode也有了这个Bug 至于什么情况会发生呢？ 你需要满足以下几条条件: 使用Mac 在Mac上使用vscode(其他编辑器不知道有没有这个Bug) 在上面两种条件满足的情况下写markdown文件 在上面三种条件满足的情况下开启preview，就像这样 凑齐这几个条件真是难为我了 解决方案 去掉上文四个条件中的至少一条 开启&quot;editor.renderControlCharacters&quot;: true，看到这玩意就删掉 本文资料来源于知乎Mac 上的 VSCode 编写 Markdown 总是出现隐藏字符？]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自写一个react-like项目]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%87%AA%E5%86%99%E4%B8%80%E4%B8%AAreact-like%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[背景之前自学了一阵子React源码(文章)，感觉自己对Component和setState,所以这里决定写一个React-Like项目加深一下对React的理解 开始 项目使用了transform-react-jsx来进行JSX和JS的转换 组件既然是写React，那就先定义一下React基本结构 12345678910// src/react/index.jsimport Component from './Component.js'import createElement from './CreateReactElement.js'const React = &#123; Component, createElement&#125;export default React; 其中Component为基本组件作为父类,createElement来创建组件 1234567891011121314151617// src/react/Component.jsimport &#123; enqueueSetState &#125; from './StateQueue'class Component &#123; constructor(props)&#123; this.isComponent = true // 是否为组件 this.isReplace = false // 是否是更新的组件 this.props = props this.state = &#123;&#125; &#125; setState(partialState)&#123; enqueueSetState(partialState, this) &#125;&#125;export default Component; 这里进行了一些基本的初始化, 还定义了setState方法，其中调用了enqueueSetState(后话)进行组件更新 12345678910111213141516171819202122232425262728// src/react/CreateReactElement.jsfunction createElement(tag, attrs, children)&#123; var props = &#123;&#125; var attrs = attrs || &#123;&#125; const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; props.children = childArray; &#125; return &#123; tag, attrs, props, key: attrs.key || null &#125;&#125;export default createElement; 这里同样进行一些初始化操作，但是对传进来的children进行了特殊的处理，利用arguments获得children长度，之后决定是转化成数组还是直接写到porps上去，最后将所有属性作为对象返回，当用户创建React对象时会自动调用这个函数 渲染同样我们先定义一个ReactDom对象 1234567891011// src/react-dom/index.jsimport render from './Render'const ReactDOM = &#123; render: ( nextElement, container ) =&gt; &#123; return render( nextElement, container ); &#125;&#125;export default ReactDOM; 在这里定义了一个大名鼎鼎的render函数，传入两个参数分别为当前的元素和要插入的容器，然后调用Render文件中的render方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// src/react-dom/Render.jsimport &#123; createComponent, setComponentProps&#125; from './Diff'import setAttribute from './Dom'/**入口render方法 * @param &#123;ReactElement&#125; nextElement 要插入到DOM中的组件 * @param &#123;DOMElement&#125; container 要插入到的容器 */export function render(nextElement, container)&#123; if(nextElement == null || container == null) return; if(nextElement.isComponent)&#123; const component = nextElement; if (component._container) &#123; if (component.componentWillUpdate)&#123; component.componentWillUpdate(); &#125; else if (component.componentWillMount) &#123; component.componentWillMount(); &#125; &#125; component._container = container; nextElement = component.render() &#125; const type = typeof nextElement if(type === 'string' || type === 'number')&#123; let textNode = document.createTextNode(nextElement); return container.appendChild(textNode); &#125; if(typeof nextElement.tag === 'function')&#123; let component = createComponent(nextElement.tag, nextElement.attrs) setComponentProps(component,nextElement.attrs, container) return render(component.base, container); &#125; const dom = document.createElement(nextElement.tag) if(nextElement.attrs)&#123; Object.keys(nextElement.attrs).map(key =&gt; &#123; setAttribute(key, nextElement.attrs[key], dom) &#125;) &#125; if(nextElement.props)&#123; if(typeof nextElement.props.children == 'object')&#123; nextElement.props.children.forEach(item =&gt; &#123; render(item, dom) &#125;) &#125;else&#123; render(nextElement.props.children, dom) &#125; &#125; if(nextElement._component)&#123; if(nextElement._component.isReplace)&#123; var arr = Array.from(nextElement._component.parentNode.childNodes) arr.map((item,index) =&gt; &#123; if(isSameDom(item,dom))&#123; return container.replaceChild(dom, nextElement._component.parentNode.children[index]) &#125; &#125;) &#125; &#125; return container.appendChild(dom)&#125;function isSameDom(item, dom)&#123; return (item.nodeName == dom.nodeName &amp;&amp; item.nodeType == dom.nodeType &amp;&amp; item.nextSibling == dom.nextSibling)&#125;export default render; 代码比较长，我们这里分段分析一下 123456const type = typeof nextElementif(type === 'string' || type === 'number')&#123; let textNode = document.createTextNode(nextElement); return container.appendChild(textNode);&#125; 如果元素类型为string或number则直接创建TextNode并直接append到container中里 12345if(typeof nextElement.tag === 'function')&#123; let component = createComponent(nextElement.tag, nextElement.attrs) setComponentProps(component,nextElement.attrs, container) return render(component.base, container);&#125; 如果元素的tag类型为function即为React组件，则调用Diff中的方法来创建组件(后话) 1234567const dom = document.createElement(nextElement.tag)if(nextElement.attrs)&#123; Object.keys(nextElement.attrs).map(key =&gt; &#123; setAttribute(key, nextElement.attrs[key], dom) &#125;)&#125; 如果都不是的话即为普通元素，则直接调用document.createElement创建Dom，之后遍历attrs调用setAttribute来设置属性，Object.keys将对象转化成数组方便遍历，接下来我们看一下setAttribute方法 12345678910111213141516171819202122232425function setAttribute(key, value, dom)&#123; if(key === 'className')&#123; key = 'class' &#125; if(typeof value === 'function')&#123; dom[key.toLowerCase()] = value || ''; &#125;else if(key === 'style')&#123; if(typeof value === 'string')&#123; dom.style.cssText = value || ''; &#125;else if(typeof value === 'object')&#123; for (let name in value) &#123; dom.style[name] = typeof value[name] === 'number' ? value[name] + 'px' : value[name]; &#125; &#125; &#125;else&#123; if(value)&#123; dom.setAttribute(key, value); &#125;else&#123; dom.removeAttribute(key, value); &#125; &#125;&#125;export default setAttribute; 先将className转化为class 若绑定的类型为function则转化成小写后写入dom属性 若key为style，则分类讨论，若属性为string则写入cssText，若为object则判断其是否为number，若是则自动在后面添加px，然后写入style 若为其他则直接调用原生setAttribute方法 若属性值为空则在dom上删除该属性 123456789if(nextElement.props)&#123; if(typeof nextElement.props.children == 'object')&#123; nextElement.props.children.forEach(item =&gt; &#123; render(item, dom) &#125;) &#125;else&#123; render(nextElement.props.children, dom) &#125;&#125; 顺着render往下看，这里遍历元素的子元素递归渲染 1234567891011if(nextElement._component)&#123; if(nextElement._component.isReplace)&#123; var arr = Array.from(nextElement._component.parentNode.childNodes) arr.map((item,index) =&gt; &#123; if(isSameDom(item,dom))&#123; return container.replaceChild(dom, nextElement._component.parentNode.children[index]) &#125; &#125;) &#125;&#125;return container.appendChild(dom) 最后判断两次render的组件是否为同一个，若为同一个则调用replaceChild方法进行替换，否则appendChild到容器中 回到上面nextElement.tag === &#39;function&#39;中，其中有两个函数createComponent和setComponentProps 12345678910111213141516// src/react-dom/Diff.jsexport function createComponent(component, props)&#123; let instance; if(component.prototype &amp;&amp; component.prototype.render)&#123; instance = new component(props) &#125;else&#123; instance = new component(props) instance.constructor = component instance.render = function() &#123; return this.constructor(props) &#125; &#125; return instance;&#125; 第一个if判断是不是class创建的组件，若是则直接new一个，若不是则为函数返回组件，调整一下constructor以及render方法，然后将新组件返回 123456789101112131415// src/react-dom/Diff.jsexport function setComponentProps(component, props, container)&#123; if (!component.base)&#123; if (component.componentWillMount) component.componentWillMount(); &#125;else if(component.componentWillReceiveProps)&#123; component.componentWillReceiveProps(props); &#125; component.props = props; component.parentNode = container renderComponent(component, container)&#125; 首先判断组件的base是否存在，若存在则判断是否为初次挂载，否则判断是否为接受新的props，然后将props即render中的attrs和container作为成员添加到component上，parentNode用来定位父元素方便更新，然后调用renderComponent进行组件挂载或者更新 123456789101112131415161718192021222324252627// src/react-dom/Diff.jsexport function renderComponent(component, container)&#123; let base; if ( component.base &amp;&amp; component.componentWillUpdate ) &#123; component.componentWillUpdate(); &#125; base = component.render() if (component.base) &#123; if (component.componentDidUpdate)&#123; component.componentDidUpdate(); &#125; &#125;else if(component.componentDidMount) &#123; component.componentDidMount(); &#125; component.base = base; base._component = component; if(!container)&#123; component.isReplace = true render(base, component.parentNode) &#125;&#125; base为createComponent中的component渲染后结果，然后进行一下简单的生命周期判断，最后判断container是否为空，若为空则为更新组件，把component.parentNode作为container传回render State更新在文章开始提到过，Component中的setState方法调用了enqueueSetState 1234567891011121314151617181920212223242526// src/react/StateQueue.jsconst batchingUpdates = [] // 需要更新的状态const dirtyComponent = [] // 需要更新的组件var isbatchingUpdates = false // 是否处于更新状态function callbackQueue(fn)&#123; return Promise.resolve().then(fn);&#125;export function enqueueSetState(partialState, component)&#123; if(!isbatchingUpdates)&#123; callbackQueue(flushBatchedUpdates) &#125; isbatchingUpdates = true batchingUpdates.push(&#123; partialState, component &#125;) if(!dirtyComponent.some(item =&gt; item === component))&#123; dirtyComponent.push(component) &#125;&#125; isbatchingUpdates判断事务是否处于更新状态(初始值为false)，若不为更新则调用callbackQueue来执行flushBatchedUpdates函数来更新组件，然后设置更新状态为true，将当前状态和组件添加到batchingUpdates中，最后判断dirtyComponent中是否有当前组件，若无则添加进去 callbackQueue使用了Promise来达到延时模拟setState的功能 1234567891011121314151617181920212223242526// src/react/StateQueue.jsfunction flushBatchedUpdates()&#123; let queueItem, componentItem; while(queueItem = batchingUpdates.shift())&#123; const &#123; partialState, component &#125; = queueItem; if(!component.prevState)&#123; component.prevState = Object.assign(&#123;&#125;, partialState) &#125; if(typeof partialState == 'function')&#123; Object.assign(component.state, partialState(component.prevState, component.props)) &#125;else&#123; Object.assign(component.state, partialState) &#125; component.prevState = component.state &#125; while(componentItem = dirtyComponent.shift())&#123; renderComponent(componentItem) &#125; isbatchingUpdates = false&#125; 遍历batchingUpdates数组排头(shift自查)，获取其中组件和状态，判断组件的前一个状态，若无之前的状态，则将空对象和当前状态合并设为该组件的初始状态，若💰一状态为function，则调用该函数并将返回值和之前状态合并，若不为函数则直接合并，然后设置组件的上一状态为其之前的状态，最后遍历dirtyComponent更新组件，完成后设置isbatchingUpdates为false 至此，基本功能完成 代码请移步GitHub仓库]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码自阅读(长篇)]]></title>
    <url>%2F2018%2F04%2F18%2FReact%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1%E7%99%BD%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[背景准备有时间写一个类react的框架，所以先读一下react的源码 开始这里先自己用parcel简单搭建了一个React环境又随便写了点组件 组件1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import MyNav from '../components/MyNav'class MainContainer extends Component &#123; componentDidMount()&#123; console.log(&lt;MyNav&gt;&lt;/MyNav&gt;) &#125; render() &#123; return ( &lt;div&gt; &lt;MyNav&gt;&lt;/MyNav&gt; &lt;/div&gt; ); &#125;&#125;export default MainContainer; 这里随便写了一个Js, 然后打印了一下MyNav组件 很明显这是一个Js对象而不是Dom 如果在里面嵌套一个子元素… console.log(&lt;MyNav&gt;&lt;div&gt;Hello&lt;/div&gt;&lt;/MyNav&gt;) 我们会发现在props里多了一个children成员，同样也是一个JS对象 如果再多嵌套一下的话(这里写的好看点) 12345678console.log( &lt;MyNav&gt; &lt;div&gt; Hello &lt;span&gt;React&lt;/span&gt; &lt;/div&gt; &lt;/MyNav&gt;) 可以看到这里会在props里面无限的套下去，同时如果一个元素内嵌了多个子元素的话，这些子元素在props的children里会以数组的方式存在 在这里不禁唱起：套马滴汉子你威武雄壮~ 那我们不如就顺着这个问题深入，先看一下React.js 12345678const React = &#123; ...... //省略 Component, createElement: __DEV__ ? createElementWithValidation : createElement, ...... //省略&#125; 我们先看一下Component 123456789101112/* node_modules/react/cjs/react.development.js*/function Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer. this.updater = updater || ReactNoopUpdateQueue;&#125; 组件extends的Components就是继承的这玩意 这里没什么好说的，一个构造函数，重点是看看那个children到底是怎么个回事 然后看一哈createElement 123456789101112131415161718192021222324252627282930313233343536373839/* node_modules/react/cjs/react.development.js*/function createElement(type, config, children) &#123; var propName; // Reserved names are extracted var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; ..... // 省略 // Children can be more than one argument, and those are transferred onto // the newly allocated props object. var childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; ...... //省略 return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);&#125; 东西都在这里，代码也很容易理解，这里初始化了一堆东西（你可以很清晰的看到children的处理方式)，最后用ReactElement这个工厂函数返回一个React元素 Object.freeze这里就不讲了 有兴趣的去百度一哈 那么问题来了..Component是继承来的，那这个createElement是什么时候执行的呢? 常规思路是在render里, 那就去看一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344var ReactMount = &#123; /**入口render方法 * @param &#123;ReactElement&#125; nextElement 要插入到DOM中的组件 * @param &#123;DOMElement&#125; container 要插入到的容器 * @param &#123;?function&#125; callback 回调 * @return &#123;ReactComponent&#125; Component instance rendered in `container`.返回ReactComponent */ render: function (nextElement, container, callback) &#123; return ReactMount._renderSubtreeIntoContainer( null, nextElement, container, callback, ); &#125;, ...... /** * 将ReactElement插入DOM中，并返回ReactElement对应的ReactComponent。 * ReactElement是React元素在内存中的表示形式，可以理解为一个数据类，包含type，key，refs，props等成员变量 * ReactComponent是React元素的操作类，包含mountComponent(), updateComponent()等很多操作组件的方法 */ /* parentComponent: 当前组件的父组件 nextElement: 要插入的组件 container: 要插入的容器 callback: 回调函数 */ _renderSubtreeIntoContainer: function ( parentComponent, nextElement, container, callback, ) &#123; callback = callback === undefined ? null : callback; var nextWrappedElement = React.createElement(TopLevelWrapper, &#123; child: nextElement, &#125;); &#125; ......&#125; 在render里可以看到用React的成员方法createElement创建了一个元素返回给了nextWrappedElement 我们跟踪一下nextWrappedElement 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取要插入到的容器的前一次的ReactComponent，这是为了做DOM diffvar prevComponent = getTopLevelWrapperInContainer(container);if (prevComponent) &#123; var prevWrappedElement = prevComponent._currentElement; var prevElement = prevWrappedElement.props.child; // shouldUpdateReactComponent方法判断是否需要更新,它只对同一DOM层级，type相同，key(如果有)相同的组件做DOM diff， if (shouldUpdateReactComponent(prevElement, nextElement)) &#123; var publicInst = prevComponent._renderedComponent.getPublicInstance(); var updatedCallback = callback &amp;&amp; function () &#123; validateCallback(callback); callback.call(publicInst); &#125;; ReactMount._updateRootComponent( prevComponent, nextWrappedElement, nextContext, container, updatedCallback, ); return publicInst; &#125; else &#123; //直接unmount ReactMount.unmountComponentAtNode(container); &#125; // 对于ReactDOM.render()调用，prevComponent为null var reactRootElement = getReactRootElementInContainer(container); var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement); var containerHasNonRootReactChild = hasNonRootReactChild(container); var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild; var component = ReactMount._renderNewRootComponent( nextWrappedElement, container, shouldReuseMarkup, nextContext, callback, )._renderedComponent.getPublicInstance(); return component;&#125; 简单梳理一下这个函数: 先拿到前一次的ReactComponent做dom diff，然后shouldUpdateReactComponent判断一下是否需要更新，如果需要的话就diff之后_updateRootComponent，否则直接卸载；然后调用_renderNewRootComponent渲染新的组件，这两个函数都有上文提到的nextWrappedElement作为参数 到这里问题差不多就解决啦，不过我决定弄个图来直观的表现一哈 至于instantiateReactComponent创建的四种组件感觉没什么深入的必要，这里就不讨论了 事务上面组件那一节讨论的Component下面还有几行代码 123456Component.prototype.setState = function(partialState, callback) &#123; this.updater.enqueueSetState(this, partialState); if (callback) &#123; this.updater.enqueueCallback(this, callback, 'setState'); &#125; &#125;; 这里传入两个参数，分别为新的state和回调函数，这里的updater是在Component中定义的this.updater = updater || ReactNoopUpdateQueue 这里我们看一下enqueueSetState是啥 12345678910111213141516enqueueSetState: function(publicInstance, partialState)&#123; var internalInstance = getInternalInstanceReadyForUpdate( publicInstance, 'setState' ); if (!internalInstance) &#123; return; &#125; // 更新队列合并操作 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); enqueueUpdate(internalInstance); &#125; getInternalInstanceReadyForUpdate获取了当前组件并赋给了internalInstance，然后判断internalInstance的_pendingStateQueue(state更新队列)是否为空，若为空则初始化为数组，然后将partialState即新的state推入，然后调用enqueueUpdate 123456789function enqueueUpdate(component) &#123; if (!batchingStrategy.isBatchingUpdates) &#123; batchingStrategy.batchedUpdates(enqueueUpdate, component); return; &#125; dirtyComponents.push(component); &#125; 当batchingStrategy.isBatchingUpdates为false，即不处于更新状态的时候，调用batchedUpdates对组件进行更新，否则将组件推入dirtyComponents中 但是让我们先看一下batchingStrategy是个啥.. 1234567891011121314var ReactDefaultBatchingStrategy = &#123; isBatchingUpdates: false, batchedUpdates: function(callback, a, b, c, d, e) &#123; var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; if (alreadyBatchingUpdates) &#123; callback(a, b, c, d, e); &#125; else &#123; transaction.perform(callback, null, a, b, c, d, e); &#125; &#125;,&#125; 这里初始状态为false，在batchedUpdates中拿到此时ReactDefaultBatchingStrategy的isBatchingUpdates赋给alreadyBatchingUpdates，然后将其设置为true;如果alreadyBatchingUpdates为true则直接执行回调函数，否则进行transaction.perform Transaction上面都是铺垫，这里就进入真正的事务里了~ 先放一张官方源码的解析图  事务就是把方法用wrapper封装起来，再通过事务的perform方法进行调用，从图里可以看出在执行被包裹的方法前后分别执行initialize和close，一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加 上文的perform(callback)即perform(enqueueUpdate)，这里再放一张网上随便偷来的流程图帮助理解 我们看一下上文的两个wrapper 12345678910111213var RESET_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function()&#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false &#125;&#125;var FLUSH_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function()&#123; ReactUpdates.flushBatchedUpdates.bind(ReactUpdates) &#125;&#125; RESET_BATCHED_UPDATES即是一个wrapper，从图可以看出它应该是用来修改isBatchingUpdates的值，需要更新的时候设置为更新，更新结束后恢复状态，这样不仅可以节省渲染，还能防止enqueueUpdate的递归调用导致死循环 那么在dirtyComponents中是如何进行组件更新的呢? 这里涉及到另一个wrapper即FLUSH_BATCHED_UPDATES，我们看一下flushBatchedUpdates 12345678910var flushBatchedUpdates = function() &#123; while(dirtyComponents.length || asapEnqueued)&#123; if(dirtyComponents.length)&#123; var transaction = ReactUpdatesFlushTransaction.getPooled() transaction.perform(runBatchedUpdates,null,transaction) ReactUpdatesFlushTransaction.release(transaction) &#125; ...... &#125;&#125; flushBatchedUpdates遍历了dirtyComponents，然后用事务执行runBatchedUpdates方法 搜了一下，这个函数主要执行以下两步 一是通过执行updateComponent方法来更新组件 二是若setState方法传入了回调函数则将回调函数存入callbackQueue队列 先看一下updateComponent源码 能看到两个比较重要的函数名componentWillReceiveProps和shouldComponentUpdate，但是根据nextState让我们先看一下_processPendingState这个函数 理解一下: 更新队列为null则直接返回原来state 若队列不为null则返回(大于1则合并) 在updateComponent中，如果shouldUpdate为true,则执行_performComponentUpdate 这里能看到componentWillUpdate这个生命周期函数，没什么深入的必要，我们看看上文中最后的更新函数_updateRenderedComponent 拿到新旧组件信息后传给shouldUpdateReactComponent，根据返回值true or false决定是更新旧组件还是卸载旧组件挂载新组件]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之MVC,MVP,MVVM]]></title>
    <url>%2F2018%2F04%2F16%2FMVC-MVVM-MVP%2F</url>
    <content type="text"><![CDATA[MVCMVC是模型(Model)－视图(View)－控制器(Controller)的缩写，是设计模式中最常用的软件架构 Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的 View：视图，为用户提供使用界面，与用户直接进行交互。 Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应 MVC中只有单向通信 用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等 服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理 Model处理后，将处理结果再交给Controller Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端 MVPMVP是Model-View-Presenter，即将MVC中的控制器Controller换成了Presenter负责逻辑的处理 Presenter: 中介者，连接Model和View层 MVC和MVP的区别是：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller 各部分之间都是双向通信 View 接收用户交互请求 View 将请求转交给 Presenter Presenter 操作Model进行数据更新 Model 通知Presenter数据发生变化 Presenter 更新View数据 MVVMMVVM是Model-View-ViewModel，和MVP的区别在于Presenter换成了ViewModel负责逻辑处理 Model 层，对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model View 层，作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明 ViewModel 层把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新 MVVM的优点是低耦合、可重用性、独立开发 双线数据绑定 View 接收用户交互请求 View 将请求转交给ViewModel ViewModel 操作Model数据更新 Model 更新完数据，通知ViewModel数据发生变化 ViewModel 更新View数据]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Camp - 简明Git入门|笔记记录]]></title>
    <url>%2F2018%2F04%2F15%2FGit-Camp-%E7%AE%80%E6%98%8EGit%E5%85%A5%E9%97%A8-%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[What is Git ?Super popular Version Conntrol System Reasons to Love Git HistoryManage history CollaborationNo waiting,Continue working Feature branchesBranches Tree Why should we learn Git?No Why Where do we begin1234567891011mkdir coding-netcd coding-nettouch index.htmlgit initgit add .git commit -m 'init' History Back 123git status //查看一下状态 git checkout -- . 如果此时你电脑坏了还能找回么? 不能，因为现在还只是本地状态，一切都只现存在你电脑里 Solution: Push 插曲Svn 和 Git 拥有权限管理的功能，每个人只能看到管理员允许自己看到的代码，但是当Svn服务器挂掉后，每个人只有部分的代码，但是Git中每个人都有全部的代码 Master杂项 Master指向可以规定 Master与Branch平级 Clone后Head指向Master Branch杂项12345git branch -b feature //创建并切换到feature分支git checkout master //切换到Mastergit branch -D xxx //删除xxx分支 如果删除feature分支，那么这个节点还存在么? 存在，feature只是一个指向该节点的指针，删除后节点依然存在，只不过没有指针指向它，最后会被Git垃圾回收机制清理 分支提交 12345git push origin // 将当前分支推送到origin主机的对应分支git push origin aaa:bbb //远程创建bbb分支并将aaa推入git push -u origin master // 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了 因为是入门的Git Camp，虽然自己都会了，但还是收获颇多 还混了一个洋葱猴..]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二新人的一次搜狐前端实习电面]]></title>
    <url>%2F2018%2F04%2F13%2F%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%9C%E7%8B%90%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[背景暑假想找一份实习，碰巧看到了学长的搜狐内推，就把自己的没有诚意的简历投了过去，过了一个多星期收到了电话面试的邮件(十分怀疑是学长面子比较大)。 问题 这里只挑几个重点的问题记录一下(我记得的..) React和Vue相同点 都使用了Virtual DOM 组件化 不同点 React使用JSX渲染页面，Vue使用简单的模板 React不是MVVM,而Vue是,拥有双向数据绑定,允许插值表达式 React中只能用setState修改状态,Vue中可直接修改data React Native与Weex Promise Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected。状态转变只能是 pending -&gt; fulfilled 或者 pending -&gt; rejected。状态转变不可逆 then 方法可以被同一个 promise 调用多次 then 方法必须返回一个 promise。规范里没有明确说明返回一个新的 promise 还是复用老的 promise（即 return this），大多数实现都是返回一个新的 promise，而且复用老的 promise可能改变内部状态，这与规范也是相违背的 值穿透 这里还问了一下具体实现，我只答上了nextTick() 原型链举个例子: 在一个对象上寻找成员的时候，如果没有找到就继续顺着proto往上找，如果最后没找到就报错(直到Object.prototype)balabala… 继承原型链 12// B 继承 AB.prototype = new A() Class 123456class B extends A&#123; constructor(props) &#123; //调用实现父类的构造函数 super(props); &#125;&#125; Undifined 和 Null这是Js的两个基本类型..balabala.. 什么时候这两者会出现? Undifined是未赋值..当你定义了一个变量但是没赋值，或者像是变量提升这种balabala.. Null在我看来是一个指向Object的指针..因为Typeof Null = Objectbalabala… 面试官: 那什么时候Null会出现? 我TM竟然没答上来..当时心里就是一阵凉凉，后来我一想Null不就是没赋值的引用类型么.. 读过什么源码么读过React的setState和Node的setImmediate… 但是考虑到自己水平问题这里就一笔带过了..然后嘴欠提了句感觉读源码对自己现阶段帮助不大，面试官还问了问为什么，我又好不容易圆回来23333 你使用的Html5和Css3新特性Html5 audio，video，canvas，datalist.. Canvas用的比较多，用其模仿过草莓音乐节的宣传视频动画datalist在懒加载的时候有经常用.. Css3 选择器，Animation，Transition，Transform… 然后让我描述了一下看见一个动画如何去实现它..balabala.. 我觉得没人能完全答上来所有的…主要还是说一下自己用的比较多的 总结面试方面 面了大约40-50分钟左右，技术点自我感觉扯上了80%左右，没答上的也尽量扯一点(除了一些自己真的听都没听过的)。感觉问的技术面不是很广(可能因为是实习生)，原生方面问的比较多..但是没问一些更深入一点的，自己比较擅长的Css和React方面也问的比较少(难过)，浏览器和Http方面没问，整体来说面试难度不大..可能考虑到我只是个大二来实习的😂 自己方面人生第一次电话面试..全程紧张，大脑间歇性暂时性空白，许多自己会的没有完美地答出来很遗憾，自己会的想表现出来的没问也有点遗憾，其中还有几次尴尬的寂静(最怕空气突然安静)，不出意外自己应该是凉了QAQ。 但是想想自己大二还有时间补救，赶紧把这篇博客整理出来反思一下自己，诸君共勉吧~ 一些补充 这篇文章好像省略了绝大部分问题(我真的记不起来了) 后来Leader又问了我许多项目相关的问题，但是请看下一条 本文只记录了我记得的中认为有价值(其实是我觉得可以写出来的)的问题 面试官还是不错滴 本文比较适合找实习工作的小萌新 本文随我的记忆实时更新..]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式]]></title>
    <url>%2F2018%2F04%2F12%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 应用场景 某些管理类，保证资源的一致访问性。 创建对象时耗时过多或耗费资源过多，但又经常用到的对象； 工具类对象 频繁访问数据库或文件的对象。 123456789101112131415161718192021222324class CreateUser &#123; constructor(name) &#123; this.name = name; this.getName(); &#125; getName() &#123; return this.name; &#125;&#125;// 代理实现单例模式var ProxyMode = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new CreateUser(name); &#125; return instance; &#125;&#125;)();// 测试单体模式的实例var a = new ProxyMode("aaa");var b = new ProxyMode("bbb");// 因为单体模式是只实例化一次，所以下面的实例是相等的console.log(a === b); //true 策略模式 策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。 策略模式的目的就是将算法的使用算法的实现分离开来。一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。 应用场景 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 1234567891011121314151617/*策略类*/var levelOBJ = &#123; "A": function(money) &#123; return money * 4; &#125;, "B" : function(money) &#123; return money * 3; &#125;, "C" : function(money) &#123; return money * 2; &#125; &#125;;/*环境类*/var calculateBouns =function(level,money) &#123; return levelOBJ[level](money);&#125;;console.log(calculateBouns('A',10000)); // 40000 代理模式 代理模式的定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。 常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。 应用场景 当我们想要隐藏某个类时，可以为其提供代理类 当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中进行权限判断来进行不同权限的功能调用） 当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行） 12345678910111213141516171819202122var imgFunc = (function() &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function() &#123; var img = new Image(); img.onload = function() &#123; imgFunc.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; imgFunc.setSrc('./loading,gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('./pic.png'); 中介者模式 中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。 应用场景 当一组对象要进行沟通或者业务上的交互，但是其关系却又很复杂混乱时，可以采用此模式 当一个对象与其他的对象要进行紧密的交互，但又想服用该对象而不依赖其他的对象时 想创造一个运行于多个类之间的对象，又不想生成新的子类时 123456789101112131415161718192021222324252627282930313233343536var goods = &#123; //手机库存 'red|32G': 3, 'red|64G': 1, 'blue|32G': 7, 'blue|32G': 6,&#125;;//中介者var mediator = (function() &#123; var colorSelect = document.getElementById('colorSelect'); var memorySelect = document.getElementById('memorySelect'); var numSelect = document.getElementById('numSelect'); return &#123; changed: function(obj) &#123; switch(obj)&#123; case colorSelect: //TODO break; case memorySelect: //TODO break; case numSelect: //TODO break; &#125; &#125; &#125;&#125;)();colorSelect.onchange = function() &#123; mediator.changed(this);&#125;;memorySelect.onchange = function() &#123; mediator.changed(this);&#125;;numSelect.onchange = function() &#123; mediator.changed(this);&#125;; 装饰者模式 装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。 例如：现有4种型号的自行车分别被定义成一个单独的类，如果给每辆自行车都加上前灯、尾灯、铃铛这3个配件，如果用类继承的方式，需要创建4*3=12个子类。但如果通过装饰者模式，只需要创建3个类。 应用场景 原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求 函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性 123456789101112131415161718192021222324252627Function.prototype.before = function(beforefn) &#123; var self = this; //保存原函数引用 return function()&#123; //返回包含了原函数和新函数的 '代理函数' beforefn.apply(this, arguments); //执行新函数，修正this return self.apply(this,arguments); //执行原函数 &#125;&#125;Function.prototype.after = function(afterfn) &#123; var self = this; return function()&#123; var ret = self.apply(this,arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;var func = function() &#123; console.log('2');&#125;//func1和func3为挂载函数var func1 = function() &#123; console.log('1');&#125;var func3 = function() &#123; console.log('3');&#125;func = func.before(func1).after(func3);func(); 以上来源于JavaScript设计模式 未完待续…]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现折叠展开菜单]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[背景在这篇文章《2018年设计趋势指南》中发现一款菜单不错，就想着用微信小程序实现 先上个动图 开始正题上方Nav基本flex布局再加个padding不需要多讲吧? 提一下，微信小程序里input的placeholder样式是写在placeholder-style里或使用placeholder-class 下方菜单 每个小卡片遵从flex布局，设置width: 50%，别忘了flex-wrap: wrap 每个小卡片内部同为flex布局并设置垂直居中，想了想还是科普下: 123456.main-view-item&#123; display: flex; justify-content: center; align-items: center; width: 50%;&#125; flex真他娘的好用 至于里面的图片是从iconfont上拿的，调这几个配色的时间是我布局时间的几十倍…. 动画 微信小程序的动画只能用JS，常规手段不可用，来个头脑风暴hack起来 观察每个卡片的折叠方向后，为每个卡片添加初始rotate使其反向折叠，我在这里定义了两个Class 123456.rotateX90&#123; transform: rotateX(-90deg);&#125;.rotateY90&#123; transform: rotateY(-90deg);&#125; 好了这样就看不到卡片了，然后给菜单按钮添加点击事件改变卡片的rotate(动态改变Class)就Ojbk啦,就像这样 1&lt;view class='main-view-item rotateX90 item1 &#123;&#123;item1Style&#125;&#125;' animation='&#123;&#123;item1&#125;&#125;'&gt;&lt;/view&gt; 实际情况应该用wx:for进行循环渲染 12345678910111213var duration = 150var item1 = wx.createAnimation(&#123; duration: duration, transformOrigin: '0 0 0'&#125;)item1.rotateX(90).step()this.setData(&#123; item1: item1, item1Style: 'item1Style'&#125;) 这里注意调整transformOrigin来控制折叠方向，对于后面的卡片在createAnimation中添加delay字段即可(差为duration的等差数列) 是不是很简单嗯? 至于菜单的收回，代码和展开差不多，就是反过来而已，不过有些展开的顺序和transformOrigin需要注意，这里还是贴一个代码吧: 1234567891011121314var duration = 150var item3 = wx.createAnimation(&#123; duration: duration, transformOrigin: '100% 100% 0', delay: duration * 2&#125;)item1.rotateX(90).step()this.setData(&#123; item3: item3, item3Style: ''&#125;) 另外我在data里设置了两个变量isShow和isShowing来判断菜单是否展开或者正在展开，来控制点击事件，差不多像这样 12345678handleClick()&#123; if(this.data.isShowing) return; else if(!this.data.isShow) this.showMenu() else this.hideMenu()&#125; 在动画完成后对isShow和isShowing进行修改即可 欢迎有更好想法的朋友进行讨论~]]></content>
      <categories>
        <category>微信小程序</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个前端开发者的自我折磨(UI)]]></title>
    <url>%2F2018%2F04%2F03%2F%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%8A%98%E7%A3%A8-UI%2F</url>
    <content type="text"><![CDATA[背景偶然看到一篇UI优化文章，发现里面几个UI交互真滴不错，就自己动手撸了一下~ 上动图 代码按钮12345&lt;div class="load-div"&gt; &lt;div class="load-progress"&gt;&lt;/div&gt; &lt;div class="wave-btn wave wave-small"&gt;&lt;/div&gt; &lt;input type="button" class="load-btn load-btn-hover" value="Show!"&gt;&lt;/div&gt; 这里起作用的有3个div,load-progress模拟进度条,wave-btn模拟扩散的波纹,load-btn即为按钮 扩散的波纹123456789101112131415161718192021222324252627282930313233343536.wave &#123; position: absolute; width: 160px; height: 40px; background-color: #b749cd; border-radius: 5px; z-index: 8;&#125;.wave-small &#123; animation: wave-small .8s infinite linear;&#125;.wave-large &#123; animation: wave-large .6s infinite linear;&#125;@keyframes wave-small &#123; 30% &#123; opacity: 0.5; &#125; 100% &#123; transform: scale(1.1, 1.4); opacity: 0; &#125;&#125;@keyframes wave-large &#123; 30% &#123; opacity: 0.5; &#125; 100% &#123; transform: scale(1.3, 1.6); opacity: 0; &#125;&#125; 使用绝对定位让波纹div在button下面避免遮盖,添加动画使div放大的同时变透明,通过30%调整到比较合适的视觉效果 1234567891011const button = document.getElementsByClassName('load-btn')[0]button.onmouseover = () =&gt; &#123; wave.classList.remove('wave-small') wave.classList.add('wave-large')&#125;button.onmouseout = () =&gt; &#123; wave.classList.remove('wave-large') wave.classList.add('wave-small')&#125; 因为hover时button会变大，所以用js进行判断添加不同大小的波纹动画 变化的按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.load-btn &#123; position: relative; width: 160px; height: 40px; font-size: 16px; color: white; background-color: #d159ec; border-radius: 5px; border: none; outline: none; cursor: pointer; z-index: 9;&#125;.loading-btn-size &#123; animation: size-small, size-back; animation-delay: 0s, 1.4s; animation-duration: .1s, .5s; animation-fill-mode: forwards, forwards; animation-timing-function: ease-in, ease;&#125;.load-btn-hover:hover &#123; animation: color-deep .2s ease-in forwards;&#125;@keyframes color-deep &#123; 70% &#123; transform: scale(1.1, 1.1) &#125; to &#123; background-color: #b749cd; transform: scale(1.1, 1.1) &#125;&#125;@keyframes size-small &#123; to &#123; transform: scale(1, .6); &#125;&#125;@keyframes size-back &#123; 50% &#123; transform: scale(1.2, 1.2); &#125; 70% &#123; transform: scale(1.1, 1.1); &#125; 80% &#123; transform: scale(1.2, 1.2); &#125; to &#123; transform: scale(1.1, 1.1); background-color: #74e795; &#125;&#125; hover时放大且颜色变深,这个就不细讲了,点击后缩小scale(1, .6),延时一段时间后变回原大小(比原来大一点)且更换颜色和文本,在size-back中通过调整百分比来模拟弹性 进度条12345678910111213141516171819202122.load-progress &#123; position: absolute; top: 8px; height: 100%; background-color: rgba(0, 0, 0, 0.3); border-radius: 5px; z-index: 10;&#125;.load-progress-x &#123; animation: x-change 1.2s ease-in; animation-delay: .2s;&#125;@keyframes x-change &#123; from &#123; width: 0; &#125; to &#123; width: 160px; &#125;&#125; 设置高度为button缩小后的高度，宽度从0到恢复模拟进度条，用透明黑色覆盖button来模拟进度条样式 展开的列表123456789&lt;div class="list"&gt; &lt;div class="red"&gt;&lt;/div&gt; &lt;div class="orange"&gt;&lt;/div&gt; &lt;div class="yellow"&gt;&lt;/div&gt; &lt;div class="green"&gt;&lt;/div&gt; &lt;div class="qing"&gt;&lt;/div&gt; &lt;div class="blue"&gt;&lt;/div&gt; &lt;div class="purple"&gt;&lt;/div&gt;&lt;/div&gt; HTML不解释 1234567891011121314151617181920.list div&#123; width: 250px; height: 50px; margin-top: 10px; visibility: hidden;&#125;.fade-show&#123; visibility: visible !important; animation: fade-show .5s linear;&#125;@keyframes fade-show&#123; from &#123; opacity: 0; &#125; tp &#123; opacity: 1; &#125;&#125; css没什么好讲的，这里使用visibility: hidden使元素隐形但是仍占据空间 12345678910111213const list = document.getElementsByClassName('list')[0]let i = 0let n = list.lengthlet timer = setInterval(() =&gt; &#123; if(i == n) clearInterval(timer) if(i &lt; n)&#123; list[i].classList.add('fade-show') i++; &#125;&#125;,50) 定时器遍历NodeList添加动画class即可 总结其实写起来并不难，主要是看你的想法，每个人可能都有不同的实现方式，关键是看哪种效率最高]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入React知识点]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%B7%B1%E5%85%A5React%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[背景自己对React方面还没有一个系统的整理，并且自己ReactNative方面比较薄弱，毕竟平时很少用ReactNative进行开发，接触的相关项目也比较少，所以在这里对React的一些知识点进行一些总结，顺便提一下ReactNative方面的知识 开始以下内容基本为个人理解，如有错误欢迎指出 ReactNative相比于原生App的优势和劣势优势 节省编译时间，开发效率快 学习成本极低(对于我) 组件化 热更新 劣势 不太稳定 内存占用较高 React的生命周期详情可以看我写的这篇React生命周期简明宝典 关于setState setState() schedules an update to a component’s state object. When state changes, the component responds by re-rendering 一个简化的setState调用图 首先，setState是异步执行的 setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below.setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below. 这里意思大概就是setState并不总是立即生效..可能会有延迟，但是你可以用componentDidUpdate或者回调函数来解决这个问题 至于setState为什么是异步的，深入的话涉及到React的事务机制，比较高级，本人能力有限这里就不误人子弟了，有兴趣的同学可以去自学一波 如果你写代码的时候发现你set的data并没有立即生效，那么它们很可能被batch update了 setState并不负责更新数据，它只是把state和callback放入_pendingStateQueue和_pendingCallback中，并且把要更新的组件放入dirtyComponents序列 再来个详细一点的图 本人目前只能理解到这里了…这个知识点就先到这了 关于state(状态)和props(属性)stateReact 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致，在React里只需要更新state，然后根据新的state进行渲染。state 的主要作用是用于组件保存、控制、修改自己的可变状态，是一个局部的、只能被组件自身控制的数据源 初始值来源于getInitalState（constructor) 只能在组件内部进行setState 代表组件内部自身的状态，只能在自身组件中存在 props组件中的props是一种父级向子级传递数据的方式，作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改，除非外部传入的props发生改变 尽量减少react组件的state，来降低组件的复杂性以及维护的难度 RefReact 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例 例如: 123456789101112131415161718192021222324var MyComponent = React.createClass(&#123; handleClick: function() &#123; // 使用原生的 DOM API 获取焦点 this.refs.myInput.focus(); &#125;, render: function() &#123; // 当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs return ( &lt;div&gt; &lt;input type="text" ref="myInput" /&gt; &lt;input type="button" value="点我输入框获取焦点" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); Context在某些场景下，你想在整个组件树中传递数据，但却不想手动地在每一层传递属性。你可以直接在 React 中使用context API解决上述问题 绝大多数应用不需要使用context，这只是一个实验性的API，很有可能在未来的React版本中移除 这里有个官方的context例子，代码比较长我就不搬运了 React事件React有一套自己的事件系统，一般来说元素绑定事件都要用到React提供的事件接口 React的事件其实是做了一层事件代理(事件委托)，使用一个统一的事件监听器，当事件发生的时候，在映射里找到真正的处理函数并调用，简化了事件处理和回收机制，提升了效率。 如果你打印一下这个事件，就会发现是一个Proxy对象 如果在React中绑定了原生事件，组件卸载的时候记得解绑，避免内存泄漏 所以尽量避免在React中使用混合事件和Dom事件 高阶组件(HOC)高阶组件（HOC）是React开发中的特有名词，一个函数返回一个React组件，指的就是一个React组包裹着另一个React组件。可以理解为一个生产React组件的工厂 一句话概括：接受一个组件作为参数，返回一个组件的函数 有两种类型的HOC: Props Proxy（pp） HOC对被包裹组件WrappedComponent的props进行操作 Inherbitance Inversion（ii）HOC继承被包裹组件WrappedComponent 例子:12345678910111213// Target 是一个组件，它作为参数传给了Hoc这个函数function Hoc(Target) &#123; class Wrap extends Component &#123; render() &#123; return ( &lt;div className='wrap'&gt; &lt;Target /&gt; &lt;/div&gt; ); &#125; &#125; return Wrap;&#125; 本文随时间更新]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack配置讲解]]></title>
    <url>%2F2018%2F03%2F28%2FWebpack%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景之前讲了讲Parcel搭建React环境…想了想不讲一哈Webpack还真有点过意不去 开始安装1234npm install webpack webpack-cli -g # 或者yarn global add webpack webpack-cli 配置创建package.json文件1234npm install webpack -D # 或者yarn add webpack -D 添加npm scripts1234567&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --mode production&quot;&#125;,&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,&#125; 入口随意创建./src/index.js，此为webpack默认入口文件，若想更改可以对webpack配置文件进行修改 1234567891011121314151617181920212223242526272829module.exports = &#123; entry: './src/index.js' &#125;// 上述配置等同于module.exports = &#123; entry: &#123; main: './src/index.js' &#125;&#125;// 或者配置多个入口module.exports = &#123; entry: &#123; foo: './src/page-foo.js', bar: './src/page-bar.js', // ... &#125;&#125;// 使用数组来对多个文件进行打包module.exports = &#123; entry: &#123; main: [ './src/foo.js', './src/bar.js' ] &#125;&#125; loader 我们可以把 loader 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块 在module.rules中进行修改123456789101112module: &#123; // ... rules: [ &#123; test: /\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀 include: [ path.resolve(__dirname, 'src') // 指定哪些路径下的文件需要经过 loader 处理 ], use: 'babel-loader', // 指定使用的 loader &#125;, ],&#125; 关于loader的安装可以查看网址 plugin 模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成，只需在配置中通过 plugins 字段添加新的 plugin 即可 1234567const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; plugins: [ new UglifyPlugin() ],&#125; 输出 webpack 的输出即指 webpack 最终构建出来的静态文件，使用output字段进行修改 12345678910111213141516171819202122232425262728module.exports = &#123; // ... output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;,&#125;// 或者多个入口生成不同文件module.exports = &#123; entry: &#123; foo: './src/foo.js', bar: './src/bar.js', &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist', &#125;,&#125;// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存module.exports = &#123; // ... output: &#123; filename: '[name].js', path: __dirname + '/dist/[hash]', &#125;,&#125; 小结创建一个简单的配置文件webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path')const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;, module: &#123; rules: [ &#123; test: /\.jsx?/, include: [ path.resolve(__dirname, 'src') ], use: 'babel-loader', &#125;, ], &#125;, // 代码模块路径解析的配置 resolve: &#123; modules: [ "node_modules", path.resolve(__dirname, 'src') ], extensions: [".wasm", ".mjs", ".js", ".json", ".jsx"], &#125;, plugins: [ new UglifyPlugin(), // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码 // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件 // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数 ],&#125; 简单的webpack搭建就到这里]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和setImmediate小姐那销魂的一夜情]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%92%8CSetImmediate%E5%B0%8F%E5%A7%90%E9%82%A3%E9%94%80%E9%AD%82%E7%9A%84%E4%B8%80%E5%A4%9C%E6%83%85%2F</url>
    <content type="text"><![CDATA[背景Rex大佬看完我的那篇一道简单面试题理解JS事件机制（+1白话讲解)后推荐我加上setImmediate这个东东.. 于是这篇博客应运而生~ 简介This method is used to break up long running operations and run a callback function immediately after the browser has completed other operations such as events and display updates. 如果看不懂这段话…那么这篇文章可能不适合你 渐进先来个简单的Node.js的Event loop 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ Event loop的基础知识这里不再讲解.. 想了解的可以看我上面提到的那篇博文 timers: 这个阶段执行setTimeout()和setInterval()设定的回调。 I/O callbacks: 执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。 idle, prepare: 仅内部使用。 poll: 获取新的I/O事件；node会在适当条件下阻塞在这里。 check: 执行setImmediate()设定的回调。 close callbacks: 执行比如socket.on(‘close’, …)的回调。 例子1234567setTimeout(function timeout () &#123; console.log('timeout');&#125;,0);setImmediate(function immediate () &#123; console.log('immediate');&#125;); setTimeout(fn, 0)几乎等价于setTimeout(fn, 1) 结果如何? 答案是不确定，因为不能确定进行到timers的时候1ms是否已经过去，如果没过去那就执行check中的setImmediate了 另外如果在一些特定的上下文中执行，比如fs.readFile，该函数的回调执行是在poll阶段，那么接下来就一定会先执行check中的setImmediate 多次调用 setImmediate 则把回调都放入队列，在 check 阶段都会执行 setImmediate 回调里调用setImmediate ，则放到下次 event loop 未完待续]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas模仿草莓音乐节宣传视频]]></title>
    <url>%2F2018%2F03%2F27%2FCanvas%E6%A8%A1%E4%BB%BF%E8%8D%89%E8%8E%93%E9%9F%B3%E4%B9%90%E8%8A%82%E5%AE%A3%E4%BC%A0%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[简介在掘金上看了一篇文章，作者使用的是导出的svg，然鹅我不会，所以我就想着用canvas撸出来…顺便当复习了 代码 这里只挑一些我认为有价值的地方讲.. 想了想…canvas好像确实没啥值得讲的，主要是撸代码的时候注意绘画的坐标，要考虑健壮性…不然你会发现后期很难维护 animation-fill-mode: both这是个好东西，让最后放大的三个圆在执行动画前不显示样式以及动画结束后保持样式 代码Js太长 这里就只贴Html了12345678910&lt;div class="main"&gt; &lt;canvas id="left-dot" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="left-scroll" height="600" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="right-scroll" height="600" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle-out" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle-inner" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle1" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle2" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle3" height="500" width="700"&gt;&lt;/canvas&gt;&lt;/div&gt; 成品]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcel上手与React开发环境搭建]]></title>
    <url>%2F2018%2F03%2F25%2FParcel%E4%B8%8A%E6%89%8B%E4%B8%8EReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[背景我从不关注代码之外的东西，因为我相信有人会帮我做这些… 之前上手了Parcel感觉还OK，在这里小小的整理一哈 开始操作 安装Parcel 1yarn global add parcel-bundler 创建package.json再顺便加个命令 12345yarn init -y// package.json"scripts": &#123; "start": "parcel index.html"&#125; 安装Babel 1yarn add babel-preset-env 安装node-sass 1yarn add node-sass 接着创建.babelrc 123&#123; "preset": ["env"]&#125; 安装React依赖 12345yarn add reactyarn add react-domyarn add --dev parcel-bundleryarn add --dev babel-preset-envyarn add --dev babel-preset-react 在.babelrc中修改 123&#123; "presets": ["env", "react"]&#125; 再整理一下目录…现在应该是这样的(关键的) 123456789node_modulessrc components containers App.js App.scss.babelrcindex.htmlpackage.json index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Parcel-React&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="./src/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js12345import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); App.js123456789101112131415import React, &#123; Component &#125; from 'react';import './App.scss';class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;h1&gt;Hello Parcel-React&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default App; App.scss123456789$color-red: red;$color-black: black;h1&#123; color: $color-red; cursor: pointer; &amp;:hover&#123; color: $color-black; &#125;&#125; package.json1234567891011121314151617181920&#123; "name": "parcel-test1", "version": "1.0.0", "main": "index.js", "license": "MIT", "scripts": &#123; "start": "parcel index.html" &#125;, "dependencies": &#123; "babel-preset-env": "^1.6.1", "node-sass": "^4.8.3", "react": "^16.2.0", "react-dom": "^16.2.0" &#125;, "devDependencies": &#123; "babel-core": "^6.26.0", "babel-preset-react": "^6.24.1", "parcel-bundler": "^1.6.2" &#125;&#125; 最后npm run一哈 舒服了，终于可以不用手脚架了，自己动手丰衣足食 有什么其他依赖再自己yarn add或npm install就好啦]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>Parcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯前端实现Gif制作]]></title>
    <url>%2F2018%2F03%2F24%2F%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0gif%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[背景受在线Sorry动图制作启发，想自己用纯前端撸一个类似的东西出来，这里地址 开始操作Begin开始没有任何头绪，想着去别人源码那copy一下，发现根本用不上… Next 想法1: 用绝对定位将文字定位到gif上,然后根据gif特定时间点显示特定文字 想法2: 在特定的时间点上用canvas在gif上绘制特定的文字 Next Result想了想，上面两种想法很好实现，但是都只是把动图展示出来，不能把修改后的文字保存到gif里 再Next对gif的每一帧进行处理然后再拼成gif 再Next Result想了想，没什么大问题，那就开干吧 真正开始操作~怎么把处理后的图片拼接成gif是个问题，去google了一波发现gif.js这个玩意，api也很简单，把图片或者canvas传进去然后render一下就ojbk了,来个官方demo 12345678910111213141516171819var gif = new GIF(&#123; workers: 2, quality: 10&#125;);// add a image elementgif.addFrame(imageElement);// or a canvas elementgif.addFrame(canvasElement, &#123;delay: 200&#125;);// or copy the pixels from a canvas contextgif.addFrame(ctx, &#123;copy: true&#125;);gif.on('finished', function(blob) &#123; window.open(URL.createObjectURL(blob));&#125;);gif.render(); 至于如何获得gif的每一帧，我用的mac下的Gif preview 用户点击生成后用类似懒加载的方式加载图片 12345for(let i = 0 ; i &lt; num ; i++)&#123; image = new Image() image.src = `xxxx$&#123;i&#125;/xx.jpg` arr[i] = image&#125; 请求数据量比较大，我先用mac下的Compress All对图片进行压缩，然后再用gzip进一步压缩所有文件(这都是后话了) 接下来调用canvas的drawImage，绘制arr图片数组中的图片，然后用canvas在上面绘制文字，注意绘制的过程使用函数requestAnimationFrame(这坑爬了好久)，关于此函数这里就不讲解了 123456function render()&#123; ctx.drawImage(arr[i],0,0) ...... requestAnimationFrame(render)&#125;render() 然后一个循环把canvas都add进去 123for(let j = 0 ; j &lt; num ; j++)&#123; gif.addFrame(ctx,&#123;delay: 167&#125;)&#125; 这里注意这两块代码执行的顺序，按照正常理解是draw一个add一个但是我发现不行(woc为什么?)，改了半天破罐破摔都draw完后再一股脑add进去发现竟然可以(???)… 我打印了一下执行顺序发现add竟然是在draw之前完成的 因为draw是递归调用，并且draw和add都是同步任务，按照Js单线程来看draw了一次后就轮到add的for循环执行，执行完毕后才会执行递归调用的draw 那么问题来了… 递归调用的draw还没执行，为什么for循环里就能把没绘制的元素状态”add”进去… 于是我看了一波源码 1234567891011121314151617181920212223242526272829303132333435GIF.prototype.addFrame = function(image, options) &#123; var frame, key; if (options == null) &#123; options = &#123;&#125; &#125; frame = &#123;&#125;; frame.transparent = this.options.transparent; for (key in frameDefaults) &#123; frame[key] = options[key] || frameDefaults[key] &#125; if (this.options.width == null) &#123; this.setOption("width", image.width) &#125; if (this.options.height == null) &#123; this.setOption("height", image.height) &#125; if (typeof ImageData !== "undefined" &amp;&amp; ImageData !== null &amp;&amp; image instanceof ImageData) &#123; frame.data = image.data &#125; else if (typeof CanvasRenderingContext2D !== "undefined" &amp;&amp; CanvasRenderingContext2D !== null &amp;&amp; image instanceof CanvasRenderingContext2D || typeof WebGLRenderingContext !== "undefined" &amp;&amp; WebGLRenderingContext !== null &amp;&amp; image instanceof WebGLRenderingContext) &#123; if (options.copy) &#123; frame.data = this.getContextData(image) &#125; else &#123; frame.context = image &#125; &#125; else if (image.childNodes != null) &#123; if (options.copy) &#123; frame.data = this.getImageData(image) &#125; else &#123; frame.image = image &#125; &#125; else &#123; throw new Error("Invalid image") &#125; return this.frames.push(frame)&#125; instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性 很明显, 因为add时候参数没有传copy所以进入frame.context = image，看到context第一感觉是和执行上下文有关系，再打印一遍执行顺序发现gif.on(&#39;finish&#39;)是全部draw完后执行的，结合worker不难推出frame和canvas之间是类似引用的关系并且在子线程中不断执行… 最后就很简单了…render一下就ojbk 考虑到我服务器性能和网速… 我在这整个大函数外面套了个延时器…保证用户加载完图片后才开始drawImage，不然会报错 启动服务器使用node.js的express搭建 总结光是最后这个想法介绍起来都能看出来我踩了很多坑….之前的想法踩了多少坑就不提了23333，并且发现不对后整个代码都要重写emmm，不过收获还是很多，同样的问题不会犯第二次了]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS人人都能写自定义Checkbox（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F23%2FCSS%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89Checkbox%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景那一刻…无数前端开发者想起了自己曾经被Checkbox支配的恐惧…这种在绝大多数浏览器中几乎或完全不能进行样式替代的玩意让开发者们被迫选择默认样式，或者是找一些访问性极差的hack方案… 开始操作 先把基本结构搞出来12&lt;input type="checkbox" id="awesome" /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; 可能有部分人不知道label有啥用: 当label与checkbox关联后，就可以起到触发开关的作用，并且我们可以通过对其添加一些内容(下面会讲解)来模拟checkbox的样式，再把真正的checkbox隐藏，最终达到我们的目的 添加样式123456789101112input[type="checkbox"] + label::before&#123; content: '\a0'; /* 不换行空格 */ display: inline-block; /* 让元素和label处于同一行 */ vertical-align: .1em; /* 设置元素向上偏移.1em */ width: .8em; height: .8em; margin-right: .2em; /* 和label保持一定距离 */ border-radius: .2em; /* 加个圆角 */ background-color: lightcoral; text-indent: .15em; /* 设置元素内content(下文模拟的✓)的缩进 */ line-height: .65; /* 设置行高 */&#125; ‘+’ 选择器指相邻同胞选择器，例子中指选择紧挨在checkbox后面的label~ 对于content这个属性，这里有篇博客大家可以看一下编码 关于em这里就不再讲解啦~ 不过还是推荐大家出门拐拐拐去学习一下emmmmm. 展示 这个淡珊瑚色的框框就是我们设置的label::before 加个选中状态 1234input[type="checkbox"]:checked + label::before&#123; content: '\2713'; background: lightblue;&#125; 展示 这个对勾的位置受到了上面样式text-indent: .15em的影响 这里用到了CSS3的checked伪对象选择器 隐藏默认的checkbox 1234input[type="checkbox"]&#123; position: absolute; clip: rect(0,0,0,0); /* 剪裁绝对定位元素 */&#125; 展示 注意, 这里使用display:none虽然也能隐藏,但是会将checkbox从tab切换焦点的队列中删除(比如你输入完账号密码后使用tab不会使checkbox获得焦点) 结果 Html 12&lt;input type="checkbox" id="awesome" /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; Css 1234567891011121314151617181920input[type="checkbox"] + label::before&#123; content: '\a0'; display: inline-block; vertical-align: .1em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background-color: lightcoral; text-indent: .15em; line-height: .65;&#125;input[type="checkbox"]:checked + label::before&#123; content: '\2713'; background: lightblue;&#125;input[type="checkbox"]&#123; position: absolute; clip: rect(0,0,0,0);&#125; 了解了基础操作后，相信各位能自己独立写一个自定义checkbox啦，各位也可以自由修改content或者添加动画做出酷炫的效果~]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(吐槽)学生把代码作业放到博客里有错么?]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%90%90%E6%A7%BD-%E5%AD%A6%E7%94%9F%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%BD%9C%E4%B8%9A%E6%94%BE%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%87%8C%E6%9C%89%E9%94%99%E4%B9%88%2F</url>
    <content type="text"><![CDATA[起因事情发生在我的周围，某位同学(以下称为X总)把实验课布置的课设某一阶段的代码放到了博客里，并注解了自己的理解等等….听起来是一件值得表扬的事情，然而结果并不如此… 高潮当实验课助教检查收上来的作业报告时，发现有十多个人的代码是相同的…!经过调查，确定了是那些同学上网搜到了X总的博客，发现写的真好还有自己的理解，于是就开心的抄了下来 结果X总和抄作业的同学都受到了扣分或零分的处置，并且X总获得和助教私聊的机会一次(内容不得而知) 调查特派员addone对助教和X总进行了间接调查 助教: 因为我们不会去看是谁写的博客，所以只能对代码相同的同学同样处置 X总: (我: X总下一阶段还写博客么)我K谁还敢写啊.. 舆论群内活跃人员(敢说话的大佬们)倾向于X总 个人想法写博客的X总没有任何错误，错误都在于抄博客的同学，助教应该去找明是谁被抄(本来也不是难事)并且严厉警告那些抄代码的同学，而不是这种酷酷的说:”分不清是谁抄谁”那句”我K谁还敢写啊”真是令人寒心.. 各位看官你们的想法呢?]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码简明宝典]]></title>
    <url>%2F2018%2F03%2F18%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍状态码的职责是当客户端向服务端发送请求时候，描述返回的请求内容 状态码如200 OK ，以三位数字和原因短语组成 状态码 类别 原因短语 1XX informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 本文只介绍具有代表性的14个状态码 2XX成功2XX的响应结果表明请求被正常处理了 200 OK从客户端发来的请求在服务端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变(GET/HEAD) 204 No Content服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体 一般在只需要从客户端往服务端发送信息，而对客户端不需要发送新信息内容的情况下使用 206 Partial Content客户端进行了范围请求，而服务器成功执行了这部分的GET请求 响应报文中包含由Content-Range指定范围的实体内容 3XX 重定向3XX的响应结果表明浏览器需要执行某些特殊的处理来正确处理请求 301 Moved Permanently永久性重定向。请求的资源已经被分配了新的URI，以后应该使用资源现在所指向的URI 如果已经把资源对应URI保存为书签，这时应该按Location首部字段提示的URI重新保存 302 Found临时性重定向。请求的资源已经被分配了新的URI，希望用户(本次)使用新的URI访问 只是临时性质的移动。如果已经把URI保存为书签，不会像301那样去更新，而是仍旧保留返回302状态码的页面对应URI 303 See Other请求对应的资源存在着另一个URI，应使用GET方法定向获取请求资源。 303与302有相同的功能，但是303明确表明应该使用GET方法 304 Not Modified客户端发送附带条件的请求时，服务器允许请求访问资源。但若请求未满足条件，则直接返回304(服务端资源未改变，可直接使用客户端未过期的缓存) 307 Temporary Redirect临时重定向。与302 Found有相同的含义 307会遵照浏览器标准，不会从POST变成GET 4XX 客户端错误4XX的响应结果表明客户端是发生错误的原因所在 400 Bad Request请求报文中存在语法错误，需修改请求内容再次发送 浏览器会像对待200 OK一样对待该状态码 401 Unauthorized发送的请求需要有通过HTTP认证的认证信息，若之前已进行过一次请求，则表示认证失败。 返回该响应必须包含一个适用于被请求资源的WWW-Authenticate首部以质询用户信息。浏览器初次接收到401响应会弹出认证用的对话窗口 403 Forbidden请求资源的访问被服务器拒绝。服务器没有必要给出拒绝的详细理由。 未获得文件系统的访问授权，访问权限出现某些问题等情况都有可能触发403 404 Not Found服务器上无法找到请求的资源 也可在服务端拒绝请求且不想说明理由时使用 5XX 服务器错误5XX的响应结果表明服务器本身发生错误 500 Internal Server Error服务端在执行请求时发生了错误，也有可能是Web应用的Bug或临时故障 503 Service Unavailable服务器处于超负载或正在停机维护，无法处理请求。 补充 返回的状态码可能和信息不对等 URI是什么? 参考于《HTTP图解》]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期简明宝典]]></title>
    <url>%2F2018%2F03%2F16%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍React的生命周期是我们掌握React工作过程所必须掌握的知识，同时也是部分公司的面试考点 概要React严格定义了组件的生命周期，其主要经历了如下三个过程 装载过程(Mount): 组件第一次在DOM树中渲染的过程 更新过程(Update): 组件重新渲染的过程 卸载过程(Unmount): 组件从DOM中删除的过程 装载过程组件第一次被渲染的时候，依次调用的函数为： constructor getInitialState getDefaultProps componentWillMount render componentDidMount 1. constructorES6中每个类的构造函数，要创建一个组件的实例就要调用相应的构造函数。但是并不是每个组件都要定义自己的构造函数，比如无状态的React组件。一个组件调用构造函数，往往是为了两个目的： 初始化state 绑定成员函数的this环境 getInitialState和getDefaultPropsgetInitialState：该函数返回值用来初始化stategetDefaultProps: 该函数返回值用来初始化props 这两者只有用React.createClass方法创造的组件类才会发生作用，并且React.createClass已经被Fb官方废弃，所以这里不细讲了 2. componentWillMount这个函数没什么存在感，因为在这个时候没有任何渲染出来的结果，调用setState修改状态也不会触发重新渲染，并且在这里做的事情完全可以提前到constructor中去做 3. render可以说React组件中最重要的函数，因为React组件的父类React.Component类对除render之外的生命周期函数都有默认实现 render并不做渲染工作，只是返回一个JSX描述的结构，最终由React库根据返回对象决定如何渲染 render应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的，因为纯函数不应该引起状态的改变 4. componentDidMount componentDidMount并不是在render调用后立即调用，其调用的时候render返回的JSX已经渲染了 componentWillMount可以在服务端和浏览器端调用，但是componentDidMount只能在浏览器端调用(因为”装载”过程是不可能在服务端完成的) 异步请求数据一般都在该函数内进行。 更新过程更新过程会依次调用以下生命周期函数： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 更新过程并不总是执行所有函数 1. componentWillReceiveProps只要是父组件的render函数被调用，在render里渲染的子组件就会经历更新过程，不管父组件传递给子组件的props有没有改变，都会触发componentWillReceiveProps。 注意通过setState触发的更新过程不会调用这个函数，不然岂不是死循环了? 2. shouldComponentUpdate应该是除了render之外最重要的函数了。它决定了一个组件什么时候需不需要渲染。render和shouldComponentUpdate是React中唯二需要有返回值的函数，shouldComponentUpdate返回一个布尔值，告诉React是否需要继续更新，若为true则继续，为false则停止更新，不会触发之后的重新渲染。 3. componentWillUpdate即将render时执行，初始化render时不执行。在这里同样不能setState，这个函数调用之后，就会把nextProps和nextState分别设置到rops和state中，紧接着调用render 4. render同上 5. componentDidUpdate组件更新完成后执行，初始化render时不执行 卸载过程卸载过程只有一个函数componentWillUnmount，当react组件要从DOM树上删除前，该函数会被调用，所以这个函数适合做一些清理工作。 eg: 在componentDidMount中用非react方法创建的DOM元素，如果不处理可能会发生内存泄漏，因此可以在该函数中将其清理干净 总结React的生命周期函数并没有想象中的那么复杂 参考于《深入理解React》]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单CSS实现闪烁动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%AE%80%E5%8D%95CSS%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%83%81%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景本文承接自上文《CSS实现文字打字动画（+1白话讲解）》 介绍提到闪烁动画，很多人可能会想起 &lt;blink&gt; 这个标签，亦或者是text-decoration: blink这个东西，但是这两者都有很大的局限性，身为”专业”前端开发者的我们怎么能满足于此呢？所以我们不得不去寻找一些其他的方法。 开始操作原图 字体调回正常啦~ 想法1:让元素变成透明再变回原样 12345678.title&#123; animation: blink 1s 3;&#125;@keyframes blink&#123; to &#123; color: transparent; &#125;&#125; 我们用Chrome开发者工具中的Animation看一看这个动画 可以发现..这个元素在变成透明之后会瞬间显现到原来的样子，很江硬，我想把他变成平滑的显现出来，于是想到了一个办法：通过修改关键帧，让其在循环周期中进行状态切换12345678.title&#123; animation: blink 1s 3;&#125;@keyframes blink&#123; 50% &#123; color: transparent; &#125;&#125; 舒服了一点 但是长了眼睛的读者一定能从图中发现这个动画的过程是加速的，导致这个动画看起来不是很自然 读了我上一篇文章的童鞋们一定会想到steps这个东西~ 让我们来试一哈12345678.title&#123; animation: blink 1s 3 steps(1);&#125;@keyframes blink&#123; 50% &#123; color: transparent; &#125;&#125; 完美 在这里用to的童鞋注意了，steps(1)表示颜色值的切换只发生在动画周期的末尾，所以效果会变成这样 傻了吧，你的动画是一下都不会闪的 回顾上一篇文章末尾提到了添加一个闪烁的光标，那么我们就用上面学到的知识来实现一下吧~12345678910111213141516171819.title&#123; ... width: 17ch; white-space: nowrap; overflow: hidden; border-right: 2px solid; //不指定颜色，使光标和文字颜色一致 animation: typing 10s steps(17), blink 1s steps(1) infinite; //infinite用来使动画无限循环&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125;@keyframes blink&#123; 50% &#123; border-color: transparent; &#125;&#125; 肥肠完美 因为字体等原因效果展示不是肥肠好，但是应该是最优解啦，还可以通过JS进行维护，这里就不讲啦 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器从输入URL到页面加载过程（+1白话精简讲解）]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88-1%E7%99%BD%E8%AF%9D%E7%B2%BE%E7%AE%80%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍:这是一个很常见的问题，我们每天都在经历这件事，但是却不能说出具体的过程，同时这也是前端面试的一个考点，所以每个学习前端的人都应该了解这个过程。 本文以Chrome浏览器为例，其渲染引擎为Webkit 接下来让我们一步一步走 输入URL后可概括为以下几个过程: 浏览器从DNS服务器获取域名的IP地址(DNS解析) 浏览器与该IP服务器建立TCP连接 浏览器发送HTTP请求 服务器接收请求并返回HTTP报文 浏览器接收返回内容 拿到返回内容后先放两张很容易搜到的流程图 可概括为以下几个过程: 渲染引擎同时解析HTML文档和样式(CSS和Style中)，两者分别生成DOM树和CSSOM树 将DOM中的”可见内容”(除head或display: none等等)和CSSOM合并(attachment)成RenderTree(渲染树) RenderTree构建完毕后进行布局(layout)，即为每个节点分配坐标 遍历RenderTree，Painting(绘制)每个节点 解析器遇到 script 标记时会立即解析并执行脚本，文档的解析将停止，直到脚本执行完毕 补充什么是CSSOM? CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动 为什么Script会阻碍文档的解析? 因为这两者公用同一个线程，且Script优先级较高 如何避免上一个问题? defer: 当浏览器遇到具有defer属性的脚本时，它会阻止加载和执行脚本，直到HTML文档中的所有元素都已解析为止 async: 使用 async 属性时，浏览器会异步加载和执行脚本，同时继续解析HTML中的其他元素，包括其他脚本元素 HTML都解析完成后才会绘制RenderTree么? 并不是。浏览器会尽早的把内容显示出来，所以每解析一部分就会绘制一部分。 希望你看完能有所收获]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道简单面试题理解JS事件机制（+1白话讲解)]]></title>
    <url>%2F2018%2F03%2F14%2F%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[定义 同步: 一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去 异步: 进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率 线程: 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位。指运行中的程序的调度单位 单线程: 单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。单线程就是进程里只有一个线程 问题123456789console.log(100)setTimeout(function () &#123; console.log(200)&#125;, 0)console.log(300)输出:// 100// 300// 200 解析 JS为单线程, 但是任务执行分为同步任务和异步任务 代码中console.log为同步任务, setTimeout为异步任务(这些基础东西就不过多解释了) 为了方便理解，我们可以认为JS这条单线程中有两条事件队列, 一条为同步队列(主事件大循环 Event Loop)，一条为异步队列，同步任务在同步队列中依次执行，异步任务在异步队列中依次执行，并且这两个队列是同时执行的。但是，JavaScript引擎只会执行同步队列中的任务，那么异步队列中的任务什么时候执行呢？ JavaScript引擎会不断遍历同步队列，当同步队列为空时，会将异步队列中执行完毕的异步事件的回调函数放入同步队列执行。 回顾现在让我们回来看看上面的面试题就很容易理解了，同步队列中console.log(100)和console.log(300)执行后，console.log(200)被推入同步队列执行，所以结果依次为100-&gt; 300-&gt;200 PS: setTimeout(fun, 0)中的0不是立即执行的意思, 而是同步队列为空时立即将fun推入同步队列 额外1234567var flag = 1setTimeout(function()&#123; flag = 0&#125;, 0)while(flag)&#123; console.log('running')&#125; 结果是什么? 答案为死循环，因为while(flag)中的代码将一直在同步队列中执行，而flag = 0没有机会被推入同步队列]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现文字打字动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F14%2FCSS%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%89%93%E5%AD%97%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍很多时候，我们会有一些奇怪的骚想法，比如让网页中的一些特定文本像敲代码一样一个一个显示出来，有一种命令行的感觉，增加设计感，很多人觉得这个效果要用很长一段JS来实现…. 正好手头有个例子，我决定用CSS实验一下 开始操作原图 emmmmmm…请忽略我的字体 想法1: 让这段文字从宽度0变成实际宽度 123456789.title&#123; ... animation: typing 6s;&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125; emmmm, 忘记禁止折行和剪切超出部分文本了 修改1234567891011.title&#123; ... white-space: nowrap; overflow: hidden; animation: typing 6s;&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125; 看起来还不错，但是还不够，我们希望字符能一个一个出来，想了想，Animation里面有个叫steps的东西，各位可以简单的理解(具体的这里就不介绍啦)为: 里面放多大的数字就是分多少帧执行，比如steps(5)就是将动画分成5帧执行。 就算我们能让动画一帧一帧执行，但是怎么让字符一个一个出现呢? 答案是…. 无人问津的ch单位，这是CSS3的新单位，表示”0”的宽度，到这我想真正的解决方案就出现啦！ 在等宽字体中，”0”字形的宽度和其他所有字形的宽度是一样的 修改123456789101112.title&#123; ... width: 17ch; //别忘了把空格算上! white-space: nowrap; overflow: hidden; animation: typing 6s steps(17); //steps里为你的字符数&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125; 或许我们还需要一个闪烁的光标？那就留着下次讲好了(如果我没忘的话) 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native实现NbaApp]]></title>
    <url>%2F2018%2F03%2F13%2FReact-Native%E5%AE%9E%E7%8E%B0NbaApp%2F</url>
    <content type="text"><![CDATA[介绍本项目为react-native构建的Nba App 设计灵感参考于:灵感来源( 其实就是参考样式 功能简单了很多,因为比较懒233333 功能 nba比分查询 球员数据查询 球队排名查询 项目地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序模仿网易云音乐]]></title>
    <url>%2F2018%2F03%2F13%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[介绍使用微信小程序模仿网易云音乐,接口来源于: 接口地址 功能 网易云账号登录 歌单查看 每日推荐 歌曲随机,单曲,列表循环 歌词滚动 …. 项目地址 图片在github里我就不放在这啦~]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React在线编辑简历]]></title>
    <url>%2F2018%2F03%2F13%2FReact%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[简介闲来无事写了几个小时… 代码还有许多问题, 以及保存为pdf功能未实现 功能 任何地方点击即可修改, 项目可以增加删除 图片就长这个样子 项目地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017自我总结]]></title>
    <url>%2F2018%2F01%2F03%2F2017%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知道该说什么相比于大一，失去了很多，也获得了很多 暑假 自学了Vue全家桶 练手了数个微信小程序 自学后端nodejs 我觉得这是我做过的最正确的决定..告别了jQuery等..这些技术也为我之后学习react等技术铺平了道路,也确定了我向全栈发展的目标 开学后, 我离开了陪伴我将近整个大一的项目组。 我认为这个项目组除了微薄的工资外已经不能给我带来什么了 一些琐碎的事情以及老套的技术栈只会拖累我 氛围也失去了成立之初的热情，当然这是无可避免的 但我仍然感激这个项目组,实话实说,这里帮我度过了小白阶段,我在这的每一次项目都尽职尽责,但为了自己终究会离开 决定 放弃了许多事情, 走好自己的路, 坚持下去, 不好高骛远, 我觉得有句话说的很对：“你只要比昨天的自己更好就行,一辈子都在跟别人攀比是人生的悲剧”。 每天坚持补充前端只是, 不只是会写代码, js深入浏览器原理缓存http等等前端概念技术不断学习 机遇偶然遇见了一份xxxx的招聘信息, 看到远程实习什么什么的就心动了,于是就投了简历。 但是公司要求的react和django我并不会 但是公司给你7天时间自学作为二面结果 思考了一下, 有些机会错过了就不会来了, 于是3天入门, 提前完成任务, 也很顺利的进入公司,老板人很好还给配了macpro 但是 只有看看外面的世界才知道自己有多垃圾 项目难度比想象中大很多 团队协作方式不熟悉 代码太不规范,刚开始几行代码都要review好几次 但是你的付出终会得到回报, 一切都会慢慢变好, 永远不要轻言放弃 展望 好好工作 抓住每个适合自己的机会 拒绝每个不合适的邀请 坚持自己的道路 照顾好她]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++2016上机题及咸鱼代码]]></title>
    <url>%2F2017%2F04%2F22%2FC-2016%E4%B8%8A%E6%9C%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2016年程序设计（2）实验考试题目及弱鸡代码本人C++水平较差,若嫌弃则只看题目即可 （30分）已有二进制文件“student.dat”和“a.dat”，分别存放着10个学生的基本信息。请将“student.dat”文件中第五个学生的所有基本信息连接到 “a.dat”的尾部，并将修改后的文件“a.dat”的内容输出显示在屏幕上。学生信息由以下结构体来描述： 123456struct student&#123; char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生&#125;; （35分）如下student类的成员：（1）请完善该类中的函数；（2）编写主函数，要求：（a）创建student类对象s1（”zhangsan”,80），创建对象s2并用s1初始化s2。（b）输出s1的name，score；输出s2的name，score；（c）利用重载函数实现计算，并在主函数输出s1，s2的分数之和。 123456789101112class student&#123; private: char *name;//学生姓名 intscore;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 intgetScore();//获取分数&#125;; （35分）已知一个抽象类Shape，其定义为： 12345678class Shape&#123; protected: float area; //面积 public: float getarea() &#123; return area; &#125;//获取面积 virtual void calcarea()=0; //计算面积 virtual void show()=0; //显示基本信息&#125;; 要求：(1) 由它派生出圆类Circle，它包含数据成员半径（radius）以及相关的成员函数getradius();还包含一个构造函数，对成员radius进行初始化，并实现继承自Shape的纯虚函数。(2) 再由圆类Circle派生出圆柱类Cylinder，它包含数据成员高度（height）以及相关的成员函数getheight();还包含一个构造函数对成员height进行初始化并显式调用父类Circle类的构造函数，要求覆盖继承自Circle类的函数calcarea()和show()。圆柱类Cylinder继承自Shape类的数据成员area表示圆柱体的表面积。(3) 在main函数中用“圆——半径2.5，圆柱——底面半径2.0，高度6.0”进行测试（π取3.14），调用函数calcarea()计算面积，并调用函数show()输出对象的基本信息，要求Circle类show() 函数输出圆的半径和面积，Cylinder类的show()函数输出圆柱底面圆半径，高度以及表面积。 咸鱼题解,仅供参考和吐槽 第一题123456789101112131415161718192021222324252627282930313233#include&lt;fstream&gt;using namespace std;struct student&#123; char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生&#125;;int main()&#123; student std[10]; fstream stu; stu.open("student.dat",ios::in|ios::binary); if(stu.fail())&#123; cout&lt;&lt;"打开a.dat文件失败"&lt;&lt;endl; exit(0); &#125; for(int i=0;i&lt;5;i++) stu.read((char*)&amp;std[i],sizeof(std[i])); stu.close(); stu.open("b.dat",ios::out|ios::binary|ios::app); stu.write((char*)&amp;std[4],sizeof(std[4])); stu.close(); stu.open("b.dat",ios::in|ios::binary); stu.read((char*)&amp;std,sizeof(std)); for(int i=0;i&lt;7;i++)&#123; stu.read((char*)&amp;std[i],sizeof(std)[i]); cout&lt;&lt;std[i].name&lt;&lt;" "&lt;&lt;std[i].age&lt;&lt;" "&lt;&lt;std[i].gender&lt;&lt;" "&lt;&lt;std[i].num&lt;&lt;endl; &#125; stu.close(); return 0;&#125; 第二题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class student&#123; private: char *name;//学生姓名 int score;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 int getScore();//获取分数&#125;;student::student(char *a,int b)&#123; name = new char[strlen(a)+1]; strcpy(name,a); score = b;&#125;student::student(student &amp;obj)&#123; name = new char[strlen(obj.name)+1]; strcpy(name,obj.name); score = obj.score;&#125;student::~student()&#123; delete []name;&#125;int student::operator+(student &amp;right)&#123; int sum; sum = this-&gt;score + right.score; return sum; &#125;char *student::getName()&#123; return name;&#125;int student::getScore()&#123; return score;&#125;int main()&#123; student s1("zhangsan",80),s2 = s1; int sum; sum = s1 + s2; cout&lt;&lt;s1.getName()&lt;&lt;" "&lt;&lt;s1.getScore()&lt;&lt;endl; cout&lt;&lt;s2.getName()&lt;&lt;" "&lt;&lt;s2.getScore()&lt;&lt;endl; cout&lt;&lt;"总分："&lt;&lt;sum; return 0;&#125; 第三题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;#define pai 3.14class Shape&#123; protected: float area; public: float getArea()&#123; return area; &#125; virtual void calcarea()=0; virtual void show()=0; &#125;;class Circle:public Shape&#123; protected: double radius; public: Circle(double r):Shape()&#123; radius = r; &#125; double getRadius()&#123; return radius; &#125; void calcarea()&#123; area = radius*radius*pai; &#125; void show()&#123; cout&lt;&lt;"半径: "&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;"面积："&lt;&lt;area&lt;&lt;endl; &#125;&#125;;class Cylinder:public Circle&#123; private: double height; public: Cylinder(double height,double r):Circle(r)&#123; this-&gt;height = height; &#125; void calcarea()&#123; area = radius*radius*pai*2 + 2*pai*radius*height; &#125; void show()&#123; cout&lt;&lt;"半径："&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;"高："&lt;&lt;height&lt;&lt;endl; cout&lt;&lt;"表面积："&lt;&lt;area&lt;&lt;endl; &#125; double getHeight()&#123; return height; &#125;&#125;;int main()&#123; Circle c1(2.5); Cylinder c2(6.0,2.0); c1.calcarea();c2.calcarea(); cout&lt;&lt;"圆的信息：";c1.show(); cout&lt;&lt;"--------------"&lt;&lt;endl; cout&lt;&lt;"圆柱的信息：";c2.show(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>上机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于三种css垂直居中]]></title>
    <url>%2F2017%2F04%2F22%2Fcss%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[目的写前端的时候总是忘记垂直居中…每次都要去搜代码 既然有了博客，就干脆整理一下写在这里吧 基于绝对定位123456789main&#123; position: absolute; top: 50%; left: 50%; margin-top: -3em; margin-left: -9em; width: 18em; height: 6em;&#125; 如果借助calc()函数的话…. 1234567main&#123; position: absolute; top: calc(50% - 3em); left: calc(50% - 9em); width: 18em; height: 6em;&#125; PS: 然而这种方法只局限于固定宽高的元素… 所以我们还可以选择translate()变形函数 123456main&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; ..缺陷自寻.. 基于视口单位123456main&#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%);&#125; ..vw,vh这里不再赘述.. PS: 只适用于在视口中居中的场景 基于Flexbox12345678body&#123; display: flex; min-height: 100vh; margin: 0;&#125;main&#123; margin: auto;&#125; 或者… 1234567main&#123; display: flex; align-items: center; justify-content: center; width: 18em; height: 10em;&#125; PS: 要求你的浏览器支持Flexbox…. 或许你可以尝试一下…1align-self: center; 参考: 《CSS揭秘》]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的散文诗-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle3%2F</url>
    <content type="text"><![CDATA[我 想我想把耳朵，贴在溪边的小树上。听小溪清脆地演奏，听小鸟欢快地啼叫。听啊，听——来到梦一般的仙境。我想把鼻子，放在鲜花上。闻鲜花的芳香，嗅生命的清爽。闻啊，闻——使我更加舒爽。我想把双手，装在飞机上。捉住柔软的白云，逮住太阳的光。玩啊，玩——蓝天是我的乐园。我想把自己，变成一条鱼。在海底，与小鱼嬉戏，与海藻玩耍。无忧无虑，尽情畅游。游啊，游——海底就是我的家。我想把自己，化为一只雄鹰。俯看长城的雄伟，再瞧草原的辽阔。飞啊，飞——见证祖国的欣荣繁茂。我想张开双臂，把祖国的山川揽入怀中。尽享山之静，水之美。我想有一百张，一千张嘴，来歌唱我的祖国——祖国，我为你骄傲！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-2]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle2%2F</url>
    <content type="text"><![CDATA[时光匆匆轻轻地打开书本，低声诵起了朱自清的《匆匆》：“燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候……”多么优美，多么富于哲理的话语，我一遍又一遍地读着、读着……屈指一算，已有四千多个日夜从我身边流过，还有三个月就要小学毕业了。如果再过三千多个日夜我就该大学毕业走向社会了，成为一个来建设祖国的建设者了。如何才能做一个合格的小学生呢？如何做才能成为一个合格的建设者呢？我们这代青少年有理想，又有抱负，但不能坐享其成。有些青年靠幻想来度日：想着以后该做什么，怎样为国家做贡献，就是不开始行动，甚至相信天上会掉下馅饼来。让时间在幻想当中白白流失了。有的人，总把事情推到明天再做，要知道“明日复明日，明日何其多。我生待明日，万事成蹉跎”啊！时光冉冉，我已从嗷嗷待哺的婴儿成长到乖巧懂事的六年级学生，时间就这样溜走――早晨，当我开始洗漱时，时间从水盆里溜走；中午，当我放学回家时，时间从脚下溜走；晚上，当我观望星空时，时间从眼前溜走……“光阴似箭，日月如梭。”每时每刻，时间都从我身边溜走，而且去而不返。“一寸光阴一寸金，寸金难买寸光阴。”这使我加倍珍惜它，把握分分秒秒。直至现在，它还在催促我长大，但是我并不感谢它，因为它在催促我长大的同时，也让生命点滴流逝。我总是追赶它，渴望与它同起同作，同止同息，但是，那却是可望而不可及的。今年的春天一定在想——去年的春天寄托了什么样的理想，明年的春天又会是一个怎样的景象？这一切我都无法作答，但愿像欧阳修所说的那样：今年花胜去年红，明年花更好，更与我同！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[addone]]></title>
    <url>%2F2017%2F04%2F20%2Faddone%2F</url>
    <content type="text"><![CDATA[欢迎各位来到我的简单博客 其实这里什么都没有2333333333333333]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle1%2F</url>
    <content type="text"><![CDATA[珍爱生命 让人生更精彩一个生命从春天走过，至少它美丽过； 一个生命从夏天走过，至少它辉煌过； 一个生命从秋天走过，至少它绚烂过； 一个生命从冬天走过，至少它坚强过。吟起这首诗，我自问：“生命是什么？”它不是一场雨，雨下在地上蒸发成水汽还会再落下；它不是一棵小草，小草枯了春天还会再荣；生命是无意间爬上额间的河流，当我们懂得珍惜时，河道已很深，深深的河道里有深深的遗憾。生命犹如单行道，没有回头的机会；生命是宇宙时间，永远无法找到两个相同时刻。“人，最宝贵的东西是生命。生命属于人只有一次。”汶川地震，警察妈妈哺育受灾幼儿；玉树天灾，护士妈妈再现慈爱。珍爱生命，人生将更精彩。感悟生命从连绵上浮起，从一点一滴中渗出，在细微处藏身。生命的长河倒映着红花绿叶、飘零积雪，变迁着湖畔边丝丝色泽，并渐渐地前行。大江东去，璀璨的生命镌刻着历史的痕迹，激荡着颗颗璀璨的明珠。生活中不可能处处有鲜花，时时有掌声。在你留意生命、珍惜生命的旅程中，你会发现，当生命被生活推向极致的地方，往往会展现出一些从容之美，临乱世而不惊，处方舟而不躁，喜迎阴晴圆缺，笑傲风霜雨雪；你更会明白，只有抱着一颗常人的平常之心，去看待生命，去珍惜生命，生命才会更有意义。生命是一种神秘的力量，说它脆弱，它就像薄冰一样不堪一击；说它坚强，它又像大山一般坚韧不拔。像海伦·凯勒，她是一位双耳失聪、双目失明的残疾人，但她凭着自己的毅力和信念，凭着对生命的热爱，先后掌握了四门外语，成为哈佛大学的一名学生，你能不说这是生命所创造的奇迹吗？去追寻你的梦想，去你想去的地方，做一个你想做的人。因为，生命只有一次，亦只得一次机会去做你所想做的事。我们应让自己的生命在理智的搏击中度过，就像落叶、谢花一样，潇洒地来，潇洒地去，做到对生命无怨无悔，让生命之光永远辉煌。珍爱生命吧，哪怕生命只有一霎那，那也让它成为一种永恒！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
</search>
