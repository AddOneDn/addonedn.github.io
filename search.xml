<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[纯前端实现Gif制作]]></title>
    <url>%2F2018%2F03%2F24%2F%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0gif%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[背景受在线Sorry动图制作启发，想自己用纯前端撸一个类似的东西出来，这里地址 开始操作Begin开始没有任何头绪，想着去别人源码那copy一下，发现根本用不上… Next 想法1: 用绝对定位将文字定位到gif上,然后根据gif特定时间点显示特定文字 想法2: 在特定的时间点上用canvas在gif上绘制特定的文字 Next Result想了想，上面两种想法很好实现，但是都只是把动图展示出来，不能保存成修改后的文字保存到gif里 再Next对gif的每一帧进行处理然后再拼成gif 再Next Result想了想，没什么大问题，那就开干吧 真正开始操作~怎么把处理后的图片拼接成gif是个问题，去google了一波发现gif.js这个玩意，api也很简单，把图片或者canvas传进去然后render一下就ojbk了,来个官方demo var gif = new GIF({ workers: 2, quality: 10 }); // add a image element gif.addFrame(imageElement); // or a canvas element gif.addFrame(canvasElement, {delay: 200}); // or copy the pixels from a canvas context gif.addFrame(ctx, {copy: true}); gif.on(&#39;finished&#39;, function(blob) { window.open(URL.createObjectURL(blob)); }); gif.render(); 至于如何获得gif的每一帧，我用的mac下的Gif preview 用户点击生成后用类似懒加载的方式加载图片 for(let i = 0 ; i &lt; num ; i++){ image = new Image() image.src = `xxxx${i}/xx.jpg` arr[i] = image } 请求数据量比较大，我先用mac下的Compress All对图片进行压缩，然后再用gzip进一步压缩所有文件(这都是后话了) 接下来调用canvas的drawImage，绘制arr图片数组中的图片，然后用canvas在上面绘制文字，注意绘制的过程使用函数requestAnimationFrame(这坑爬了好久)，关于此函数这里就不讲解了 function render(){ ctx.drawImage(arr[i],0,0) ...... requestAnimationFrame(render) } render() 然后一个循环把canvas都add进去 for(let j = 0 ; j &lt; num ; j++){ gif.addFrame(ctx,{delay: 167}) } 这里注意这两块代码执行的顺序，按照正常理解是draw一个add一个但是我发现不行(woc为什么?)，改了半天破罐破摔都draw完后再一股脑add进去发现竟然可以(???)… 我打印了一下执行顺序发现add竟然是在draw之前完成的 因为draw是递归调用，并且draw和add都是同步任务，按照Js单线程来看draw了一次后就轮到add的for循环执行，执行完毕后才会执行递归调用的draw 那么问题来了… 递归调用的draw还没执行，为什么for循环里就能把没绘制的元素状态”add”进去… 于是我看了一波源码 GIF.prototype.addFrame = function(image, options) { var frame, key; if (options == null) { options = {} } frame = {}; frame.transparent = this.options.transparent; for (key in frameDefaults) { frame[key] = options[key] || frameDefaults[key] } if (this.options.width == null) { this.setOption(&quot;width&quot;, image.width) } if (this.options.height == null) { this.setOption(&quot;height&quot;, image.height) } if (typeof ImageData !== &quot;undefined&quot; &amp;&amp; ImageData !== null &amp;&amp; image instanceof ImageData) { frame.data = image.data } else if (typeof CanvasRenderingContext2D !== &quot;undefined&quot; &amp;&amp; CanvasRenderingContext2D !== null &amp;&amp; image instanceof CanvasRenderingContext2D || typeof WebGLRenderingContext !== &quot;undefined&quot; &amp;&amp; WebGLRenderingContext !== null &amp;&amp; image instanceof WebGLRenderingContext) { if (options.copy) { frame.data = this.getContextData(image) } else { frame.context = image } } else if (image.childNodes != null) { if (options.copy) { frame.data = this.getImageData(image) } else { frame.image = image } } else { throw new Error(&quot;Invalid image&quot;) } return this.frames.push(frame) } instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性 很明显, 因为add时候参数没有传copy所以进入frame.context = image，看到context第一感觉是和执行上下文有关系，再打印一遍执行顺序发现gif.on(&#39;finish&#39;)是全部draw完后执行的，结合worker不难推出frame和canvas之间是类似引用的关系并且在子线程中不断执行… 最后就很简单了…render一下就ojbk 考虑到我服务器性能和网速… 我在这整个大函数外面套了个延时器…保证用户加载完图片后才开始drawImage，不然会报错 总结光是最后这个想法介绍起来都能看出来我踩了很多坑….之前的想法踩了多少坑就不提了23333，并且发现不对后整个代码都要重写emmm，不过收获还是很多，同样的问题不会犯第二次了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS人人都能写自定义Checkbox（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F23%2FCSS%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89Checkbox%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景那一刻…无数前端开发者想起了自己曾经被Checkbox支配的恐惧…这种在绝大多数浏览器中几乎或完全不能进行样式替代的玩意让开发者们被迫选择默认样式，或者是找一些访问性极差的hack方案… 开始操作 先把基本结构搞出来 &lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot; /&gt; &lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt; 可能有部分人不知道label有啥用: 当label与checkbox关联后，就可以起到触发开关的作用，并且我们可以通过对其添加一些内容(下面会讲解)来模拟checkbox的样式，再把真正的checkbox隐藏，最终达到我们的目的 添加样式 input[type=&quot;checkbox&quot;] + label::before{ content: &#39;\a0&#39;; /* 不换行空格 */ display: inline-block; /* 让元素和label处于同一行 */ vertical-align: .1em; /* 设置元素向上偏移.1em */ width: .8em; height: .8em; margin-right: .2em; /* 和label保持一定距离 */ border-radius: .2em; /* 加个圆角 */ background-color: lightcoral; text-indent: .15em; /* 设置元素内content(下文模拟的✓)的缩进 */ line-height: .65; /* 设置行高 */ } ‘+’ 选择器指相邻同胞选择器，例子中指选择紧挨在checkbox后面的label~ 对于content这个属性，这里有篇博客大家可以看一下编码 关于em这里就不再讲解啦~ 不过还是推荐大家出门拐拐拐去学习一下emmmmm. 展示 这个淡珊瑚色的框框就是我们设置的label::before 加个选中状态input[type=&quot;checkbox&quot;]:checked + label::before{ content: &#39;\2713&#39;; background: lightblue; } 展示 这个对勾的位置受到了上面样式text-indent: .15em的影响 这里用到了CSS3的checked伪对象选择器 隐藏默认的checkboxinput[type=&quot;checkbox&quot;]{ position: absolute; clip: rect(0,0,0,0); /* 剪裁绝对定位元素 */ } 展示 注意, 这里使用display:none虽然也能隐藏,但是会将checkbox从tab切换焦点的队列中删除(比如你输入完账号密码后使用tab不会使checkbox获得焦点) 结果 Html&lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot; /&gt; &lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt; Cssinput[type=&quot;checkbox&quot;] + label::before{ content: &#39;\a0&#39;; display: inline-block; vertical-align: .1em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background-color: lightcoral; text-indent: .15em; line-height: .65; } input[type=&quot;checkbox&quot;]:checked + label::before{ content: &#39;\2713&#39;; background: lightblue; } input[type=&quot;checkbox&quot;]{ position: absolute; clip: rect(0,0,0,0); } 了解了基础操作后，相信各位能自己独立写一个自定义checkbox啦，各位也可以自由修改content或者添加动画做出酷炫的效果~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(吐槽)学生把代码作业放到博客里有错么?]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%90%90%E6%A7%BD-%E5%AD%A6%E7%94%9F%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%BD%9C%E4%B8%9A%E6%94%BE%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%87%8C%E6%9C%89%E9%94%99%E4%B9%88%2F</url>
    <content type="text"><![CDATA[起因事情发生在我的周围，某位同学(以下称为X总)把实验课布置的课设某一阶段的代码放到了博客里，并注解了自己的理解等等….听起来是一件值得表扬的事情，然而结果并不如此… 高潮当实验课助教检查收上来的作业报告时，发现有十多个人的代码是相同的…!经过调查，确定了是那些同学上网搜到了X总的博客，发现写的真好还有自己的理解，于是就开心的抄了下来 结果X总和抄作业的同学都受到了扣分或零分的处置，并且X总获得和助教私聊的机会一次(内容不得而知) 调查特派员addone对助教和X总进行了间接调查 助教: 因为我们不会去看是谁写的博客，所以只能对代码相同的同学同样处置 X总: (我: X总下一阶段还写博客么)我K谁还敢写啊.. 舆论群内活跃人员(敢说话的大佬们)倾向于X总 个人想法写博客的X总没有任何错误，错误都在于抄博客的同学，助教应该去找明是谁被抄(本来也不是难事)并且严厉警告那些抄代码的同学，而不是这种酷酷的说:”分不清是谁抄谁”那句”我K谁还敢写啊”真是令人寒心.. 各位看官你们的想法呢?]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码简明宝典]]></title>
    <url>%2F2018%2F03%2F18%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍状态码的职责是当客户端向服务端发送请求时候，描述返回的请求内容 状态码如200 OK ，以三位数字和原因短语组成 状态码 类别 原因短语 1XX informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 本文只介绍具有代表性的14个状态码 2XX成功2XX的响应结果表明请求被正常处理了 200 OK从客户端发来的请求在服务端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变(GET/HEAD) 204 No Content服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体 一般在只需要从客户端往服务端发送信息，而对客户端不需要发送新信息内容的情况下使用 206 Partial Content客户端进行了范围请求，而服务器成功执行了这部分的GET请求 响应报文中包含由Content-Range指定范围的实体内容 3XX 重定向3XX的响应结果表明浏览器需要执行某些特殊的处理来正确处理请求 301 Moved Permanently永久性重定向。请求的资源已经被分配了新的URI，以后应该使用资源现在所指向的URI 如果已经把资源对应URI保存为书签，这时应该按Location首部字段提示的URI重新保存 302 Found临时性重定向。请求的资源已经被分配了新的URI，希望用户(本次)使用新的URI访问 只是临时性质的移动。如果已经把URI保存为书签，不会像301那样去更新，而是仍旧保留返回302状态码的页面对应URI 303 See Other请求对应的资源存在着另一个URI，应使用GET方法定向获取请求资源。 303与302有相同的功能，但是303明确表明应该使用GET方法 304 Not Modified客户端发送附带条件的请求时，服务器允许请求访问资源。但若请求未满足条件，则直接返回304(服务端资源未改变，可直接使用客户端未过期的缓存) 307 Temporary Redirect临时重定向。与302 Found有相同的含义 307会遵照浏览器标准，不会从POST变成GET 4XX 客户端错误4XX的响应结果表明客户端是发生错误的原因所在 400 Bad Request请求报文中存在语法错误，需修改请求内容再次发送 浏览器会像对待200 OK一样对待该状态码 401 Unauthorized发送的请求需要有通过HTTP认证的认证信息，若之前已进行过一次请求，则表示认证失败。 返回该响应必须包含一个适用于被请求资源的WWW-Authenticate首部以质询用户信息。浏览器初次接收到401响应会弹出认证用的对话窗口 403 Forbidden请求资源的访问被服务器拒绝。服务器没有必要给出拒绝的详细理由。 未获得文件系统的访问授权，访问权限出现某些问题等情况都有可能触发403 404 Not Found服务器上无法找到请求的资源 也可在服务端拒绝请求且不想说明理由时使用 5XX 服务器错误5XX的响应结果表明服务器本身发生错误 500 Internal Server Error服务端在执行请求时发生了错误，也有可能是Web应用的Bug或临时故障 503 Service Unavailable服务器处于超负载或正在停机维护，无法处理请求。 补充 返回的状态码可能和信息不对等 URI是什么? 参考于《HTTP图解》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期简明宝典]]></title>
    <url>%2F2018%2F03%2F16%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍React的生命周期是我们掌握React工作过程所必须掌握的知识，同时也是部分公司的面试考点 概要React严格定义了组件的生命周期，其主要经历了如下三个过程 装载过程(Mount): 组件第一次在DOM树中渲染的过程 更新过程(Update): 组件重新渲染的过程 卸载过程(Unmount): 组件从DOM中删除的过程 装载过程组件第一次被渲染的时候，依次调用的函数为： constructor getInitialState getDefaultProps componentWillMount render componentDidMount 1. constructorES6中每个类的构造函数，要创建一个组件的实例就要调用相应的构造函数。但是并不是每个组件都要定义自己的构造函数，比如无状态的React组件。一个组件调用构造函数，往往是为了两个目的： 初始化state 绑定成员函数的this环境 getInitialState和getDefaultPropsgetInitialState：该函数返回值用来初始化stategetDefaultProps: 该函数返回值用来初始化props 这两者只有用React.createClass方法创造的组件类才会发生作用，并且React.createClass已经被Fb官方废弃，所以这里不细讲了 2. componentWillMount这个函数没什么存在感，因为在这个时候没有任何渲染出来的结果，调用setState修改状态也不会触发重新渲染，并且在这里做的事情完全可以提前到constructor中去做 3. render可以说React组件中最重要的函数，因为React组件的父类React.Component类对除render之外的生命周期函数都有默认实现 render并不做渲染工作，只是返回一个JSX描述的结构，最终由React库根据返回对象决定如何渲染 render应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的，因为纯函数不应该引起状态的改变 4. componentDidMount componentDidMount并不是在render调用后立即调用，其调用的时候render返回的JSX已经渲染了 componentWillMount可以在服务端和浏览器端调用，但是componentDidMount只能在浏览器端调用(因为”装载”过程是不可能在服务端完成的) 异步请求数据一般都在该函数内进行。 更新过程更新过程会依次调用以下生命周期函数： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 更新过程并不总是执行所有函数 1. componentWillReceiveProps只要是父组件的render函数被调用，在render里渲染的子组件就会经历更新过程，不管父组件传递给子组件的props有没有改变，都会触发componentWillReceiveProps。 注意通过setState触发的更新过程不会调用这个函数，不然岂不是死循环了? 2. shouldComponentUpdate应该是除了render之外最重要的函数了。它决定了一个组件什么时候需不需要渲染。render和shouldComponentUpdate是React中唯二需要有返回值的函数，shouldComponentUpdate返回一个布尔值，告诉React是否需要继续更新，若为true则继续，为false则停止更新，不会触发之后的重新渲染。 3. componentWillUpdate即将render时执行，初始化render时不执行。在这里同样不能setState，这个函数调用之后，就会把nextProps和nextState分别设置到rops和state中，紧接着调用render 4. render同上 5. componentDidUpdate组件更新完成后执行，初始化render时不执行 卸载过程卸载过程只有一个函数componentWillUnmount，当react组件要从DOM树上删除前，该函数会被调用，所以这个函数适合做一些清理工作。 eg: 在componentDidMount中用非react方法创建的DOM元素，如果不处理可能会发生内存泄漏，因此可以在该函数中将其清理干净 总结React的生命周期函数并没有想象中的那么复杂 参考于《深入理解React》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单CSS实现闪烁动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%AE%80%E5%8D%95CSS%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%83%81%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景本文承接自上文《CSS实现文字打字动画（+1白话讲解）》 介绍提到闪烁动画，很多人可能会想起 &lt;blink&gt; 这个标签，亦或者是text-decoration: blink这个东西，但是这两者都有很大的局限性，身为”专业”前端开发者的我们怎么能满足于此呢？所以我们不得不去寻找一些其他的方法。 开始操作原图 字体调回正常啦~ 想法1:让元素变成透明再变回原样 .title{ animation: blink 1s 3; } @keyframes blink{ to { color: transparent; } } 我们用Chrome开发者工具中的Animation看一看这个动画 可以发现..这个元素在变成透明之后会瞬间显现到原来的样子，很江硬，我想把他变成平滑的显现出来，于是想到了一个办法：通过修改关键帧，让其在循环周期中进行状态切换 .title{ animation: blink 1s 3; } @keyframes blink{ 50% { color: transparent; } } 舒服了一点 但是长了眼睛的读者一定能从图中发现这个动画的过程是加速的，导致这个动画看起来不是很自然 读了我上一篇文章的童鞋们一定会想到steps这个东西~ 让我们来试一哈 .title{ animation: blink 1s 3 steps(1); } @keyframes blink{ 50% { color: transparent; } } 完美 在这里用to的童鞋注意了，steps(1)表示颜色值的切换只发生在动画周期的末尾，所以效果会变成这样 傻了吧，你的动画是一下都不会闪的 回顾上一篇文章末尾提到了添加一个闪烁的光标，那么我们就用上面学到的知识来实现一下吧~ .title{ ... width: 17ch; white-space: nowrap; overflow: hidden; border-right: 2px solid; //不指定颜色，使光标和文字颜色一致 animation: typing 10s steps(17), blink 1s steps(1) infinite; //infinite用来使动画无限循环 } @keyframes typing{ from { width: 0; } } @keyframes blink{ 50% { border-color: transparent; } } 肥肠完美 因为字体等原因效果展示不是肥肠好，但是应该是最优解啦，还可以通过JS进行维护，这里就不讲啦 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器从输入URL到页面加载过程（+1白话精简讲解）]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88-1%E7%99%BD%E8%AF%9D%E7%B2%BE%E7%AE%80%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍:这是一个很常见的问题，我们每天都在经历这件事，但是却不能说出具体的过程，同时这也是前端面试的一个考点，所以每个学习前端的人都应该了解这个过程。 本文以Chrome浏览器为例，其渲染引擎为Webkit 接下来让我们一步一步走 输入URL后可概括为以下几个过程: 浏览器从DNS服务器获取域名的IP地址(DNS解析) 浏览器与该IP服务器建立TCP连接 浏览器发送HTTP请求 服务器接收请求并返回HTTP报文 浏览器接收返回内容 拿到返回内容后先放两张很容易搜到的流程图 可概括为以下几个过程: 渲染引擎同时解析HTML文档和样式(CSS和Style中)，两者分别生成DOM树和CSSOM树 将DOM中的”可见内容”(除head或display: none等等)和CSSOM合并(attachment)成RenderTree(渲染树) RenderTree构建完毕后进行布局(layout)，即为每个节点分配坐标 遍历RenderTree，Painting(绘制)每个节点 解析器遇到 script 标记时会立即解析并执行脚本，文档的解析将停止，直到脚本执行完毕 补充什么是CSSOM? CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动 为什么Script会阻碍文档的解析? 因为这两者公用同一个线程，且Script优先级较高 如何避免上一个问题? defer: 当浏览器遇到具有defer属性的脚本时，它会阻止加载和执行脚本，直到HTML文档中的所有元素都已解析为止 async: 使用 async 属性时，浏览器会异步加载和执行脚本，同时继续解析HTML中的其他元素，包括其他脚本元素 HTML都解析完成后才会绘制RenderTree么? 并不是。浏览器会尽早的把内容显示出来，所以每解析一部分就会绘制一部分。 希望你看完能有所收获]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道简单面试题理解JS事件机制（+1白话讲解)]]></title>
    <url>%2F2018%2F03%2F14%2F%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[定义 同步: 一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去 异步: 进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率 线程: 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位。指运行中的程序的调度单位 单线程: 单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。单线程就是进程里只有一个线程 问题console.log(100) setTimeout(function () { console.log(200) }, 0) console.log(300) 输出: // 100 // 300 // 200 解析 JS为单线程, 但是任务执行分为同步任务和异步任务 代码中console.log为同步任务, setTimeout为异步任务(这些基础东西就不过多解释了) 为了方便理解，我们可以认为JS这条单线程中有两条事件队列, 一条为同步队列(主事件大循环 Event Loop)，一条为异步队列，同步任务在同步队列中依次执行，异步任务在异步队列中依次执行，并且这两个队列是同时执行的。但是，JavaScript引擎只会执行同步队列中的任务，那么异步队列中的任务什么时候执行呢？ JavaScript引擎会不断遍历同步队列，当同步队列为空时，会将异步队列中执行完毕的异步事件的回调函数放入同步队列执行。 回顾现在让我们回来看看上面的面试题就很容易理解了，同步队列中console.log(100)和console.log(300)执行后，console.log(200)被推入同步队列执行，所以结果依次为100-&gt; 300-&gt;200 PS: setTimeout(fun, 0)中的0不是立即执行的意思, 而是同步队列为空时立即将fun推入同步队列 额外var flag = 1 setTimeout(function(){ flag = 0 }, 0) while(flag){ console.log(&#39;running&#39;) } 结果是什么? 答案为死循环，因为while(flag)中的代码将一直在同步队列中执行，而flag = 0没有机会被推入同步队列]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现文字打字动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F14%2FCSS%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%89%93%E5%AD%97%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍很多时候，我们会有一些奇怪的骚想法，比如让网页中的一些特定文本像敲代码一样一个一个显示出来，有一种命令行的感觉，增加设计感，很多人觉得这个效果要用很长一段JS来实现…. 正好手头有个例子，我决定用CSS实验一下 开始操作原图 emmmmmm…请忽略我的字体 想法1: 让这段文字从宽度0变成实际宽度 .title{ ... animation: typing 6s; } @keyframes typing{ from { width: 0; } } emmmm, 忘记禁止折行和剪切超出部分文本了 修改 .title{ ... white-space: nowrap; overflow: hidden; animation: typing 6s; } @keyframes typing{ from { width: 0; } } 看起来还不错，但是还不够，我们希望字符能一个一个出来，想了想，Animation里面有个叫steps的东西，各位可以简单的理解(具体的这里就不介绍啦)为: 里面放多大的数字就是分多少帧执行，比如steps(5)就是将动画分成5帧执行。 就算我们能让动画一帧一帧执行，但是怎么让字符一个一个出现呢? 答案是…. 无人问津的ch单位，这是CSS3的新单位，表示”0”的宽度，到这我想真正的解决方案就出现啦！ 在等宽字体中，”0”字形的宽度和其他所有字形的宽度是一样的 修改 .title{ ... width: 17ch; //别忘了把空格算上! white-space: nowrap; overflow: hidden; animation: typing 6s steps(17); //steps里为你的字符数 } @keyframes typing{ from { width: 0; } } 或许我们还需要一个闪烁的光标？那就留着下次讲好了(如果我没忘的话) 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native实现NbaApp]]></title>
    <url>%2F2018%2F03%2F13%2FReact-Native%E5%AE%9E%E7%8E%B0NbaApp%2F</url>
    <content type="text"><![CDATA[介绍本项目为react-native构建的Nba App 设计灵感参考于:灵感来源( 其实就是参考样式 功能简单了很多,因为比较懒233333 功能 nba比分查询 球员数据查询 球队排名查询 项目地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序模仿网易云音乐]]></title>
    <url>%2F2018%2F03%2F13%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[介绍使用微信小程序模仿网易云音乐,接口来源于: 接口地址 功能 网易云账号登录 歌单查看 每日推荐 歌曲随机,单曲,列表循环 歌词滚动 …. 项目地址 图片在github里我就不放在这啦~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React在线编辑简历]]></title>
    <url>%2F2018%2F03%2F13%2FReact%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[简介闲来无事写了几个小时… 代码还有许多问题, 以及保存为pdf功能未实现 功能 任何地方点击即可修改, 项目可以增加删除 图片就长这个样子 项目地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017自我总结]]></title>
    <url>%2F2018%2F01%2F03%2F2017%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知道该说什么相比于大一，失去了很多，也获得了很多 暑假 自学了Vue全家桶 练手了数个微信小程序 自学后端nodejs 我觉得这是我做过的最正确的决定..告别了jQuery等..这些技术也为我之后学习react等技术铺平了道路,也确定了我向全栈发展的目标 开学后, 我离开了陪伴我将近整个大一的项目组。 我认为这个项目组除了微薄的工资外已经不能给我带来什么了 一些琐碎的事情以及老套的技术栈只会拖累我 氛围也失去了成立之初的热情，当然这是无可避免的 但我仍然感激这个项目组,实话实说,这里帮我度过了小白阶段,我在这的每一次项目都尽职尽责,但为了自己终究会离开 决定 放弃了许多事情, 走好自己的路, 坚持下去, 不好高骛远, 我觉得有句话说的很对：“你只要比昨天的自己更好就行,一辈子都在跟别人攀比是人生的悲剧”。 每天坚持补充前端只是, 不只是会写代码, js深入浏览器原理缓存http等等前端概念技术不断学习 机遇偶然遇见了一份xxxx的招聘信息, 看到远程实习什么什么的就心动了,于是就投了简历。 但是公司要求的react和django我并不会 但是公司给你7天时间自学作为二面结果 思考了一下, 有些机会错过了就不会来了, 于是3天入门, 提前完成任务, 也很顺利的进入公司,老板人很好还给配了macpro 但是 只有看看外面的世界才知道自己有多垃圾 项目难度比想象中大很多 团队协作方式不熟悉 代码太不规范,刚开始几行代码都要review好几次 但是你的付出终会得到回报, 一切都会慢慢变好, 永远不要轻言放弃 展望 好好工作 抓住每个适合自己的机会 拒绝每个不合适的邀请 坚持自己的道路 照顾好她]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++2016上机题及咸鱼代码]]></title>
    <url>%2F2017%2F04%2F22%2FC-2016%E4%B8%8A%E6%9C%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2016年程序设计（2）实验考试题目及弱鸡代码本人C++水平较差,若嫌弃则只看题目即可 （30分）已有二进制文件“student.dat”和“a.dat”，分别存放着10个学生的基本信息。请将“student.dat”文件中第五个学生的所有基本信息连接到 “a.dat”的尾部，并将修改后的文件“a.dat”的内容输出显示在屏幕上。学生信息由以下结构体来描述：struct student{ char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生 }; （35分）如下student类的成员：（1）请完善该类中的函数；（2）编写主函数，要求：（a）创建student类对象s1（”zhangsan”,80），创建对象s2并用s1初始化s2。（b）输出s1的name，score；输出s2的name，score；（c）利用重载函数实现计算，并在主函数输出s1，s2的分数之和。class student{ private: char *name;//学生姓名 intscore;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 intgetScore();//获取分数 }; （35分）已知一个抽象类Shape，其定义为：class Shape{ protected: float area; //面积 public: float getarea() { return area; }//获取面积 virtual void calcarea()=0; //计算面积 virtual void show()=0; //显示基本信息 }; 要求：(1) 由它派生出圆类Circle，它包含数据成员半径（radius）以及相关的成员函数getradius();还包含一个构造函数，对成员radius进行初始化，并实现继承自Shape的纯虚函数。(2) 再由圆类Circle派生出圆柱类Cylinder，它包含数据成员高度（height）以及相关的成员函数getheight();还包含一个构造函数对成员height进行初始化并显式调用父类Circle类的构造函数，要求覆盖继承自Circle类的函数calcarea()和show()。圆柱类Cylinder继承自Shape类的数据成员area表示圆柱体的表面积。(3) 在main函数中用“圆——半径2.5，圆柱——底面半径2.0，高度6.0”进行测试（π取3.14），调用函数calcarea()计算面积，并调用函数show()输出对象的基本信息，要求Circle类show() 函数输出圆的半径和面积，Cylinder类的show()函数输出圆柱底面圆半径，高度以及表面积。 咸鱼题解,仅供参考和吐槽 第一题#include&lt;fstream&gt; using namespace std; struct student{ char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生 }; int main(){ student std[10]; fstream stu; stu.open(&quot;student.dat&quot;,ios::in|ios::binary); if(stu.fail()){ cout&lt;&lt;&quot;打开a.dat文件失败&quot;&lt;&lt;endl; exit(0); } for(int i=0;i&lt;5;i++) stu.read((char*)&amp;std[i],sizeof(std[i])); stu.close(); stu.open(&quot;b.dat&quot;,ios::out|ios::binary|ios::app); stu.write((char*)&amp;std[4],sizeof(std[4])); stu.close(); stu.open(&quot;b.dat&quot;,ios::in|ios::binary); stu.read((char*)&amp;std,sizeof(std)); for(int i=0;i&lt;7;i++){ stu.read((char*)&amp;std[i],sizeof(std)[i]); cout&lt;&lt;std[i].name&lt;&lt;&quot; &quot;&lt;&lt;std[i].age&lt;&lt;&quot; &quot;&lt;&lt;std[i].gender&lt;&lt;&quot; &quot;&lt;&lt;std[i].num&lt;&lt;endl; } stu.close(); return 0; } 第二题 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; class student{ private: char *name;//学生姓名 int score;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 int getScore();//获取分数 }; student::student(char *a,int b){ name = new char[strlen(a)+1]; strcpy(name,a); score = b; } student::student(student &amp;obj){ name = new char[strlen(obj.name)+1]; strcpy(name,obj.name); score = obj.score; } student::~student(){ delete []name; } int student::operator+(student &amp;right){ int sum; sum = this-&gt;score + right.score; return sum; } char *student::getName(){ return name; } int student::getScore(){ return score; } int main(){ student s1(&quot;zhangsan&quot;,80),s2 = s1; int sum; sum = s1 + s2; cout&lt;&lt;s1.getName()&lt;&lt;&quot; &quot;&lt;&lt;s1.getScore()&lt;&lt;endl; cout&lt;&lt;s2.getName()&lt;&lt;&quot; &quot;&lt;&lt;s2.getScore()&lt;&lt;endl; cout&lt;&lt;&quot;总分：&quot;&lt;&lt;sum; return 0; } 第三题#include&lt;iostream&gt; using namespace std; #define pai 3.14 class Shape{ protected: float area; public: float getArea(){ return area; } virtual void calcarea()=0; virtual void show()=0; }; class Circle:public Shape{ protected: double radius; public: Circle(double r):Shape(){ radius = r; } double getRadius(){ return radius; } void calcarea(){ area = radius*radius*pai; } void show(){ cout&lt;&lt;&quot;半径: &quot;&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;&quot;面积：&quot;&lt;&lt;area&lt;&lt;endl; } }; class Cylinder:public Circle{ private: double height; public: Cylinder(double height,double r):Circle(r){ this-&gt;height = height; } void calcarea(){ area = radius*radius*pai*2 + 2*pai*radius*height; } void show(){ cout&lt;&lt;&quot;半径：&quot;&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;&quot;高：&quot;&lt;&lt;height&lt;&lt;endl; cout&lt;&lt;&quot;表面积：&quot;&lt;&lt;area&lt;&lt;endl; } double getHeight(){ return height; } }; int main(){ Circle c1(2.5); Cylinder c2(6.0,2.0); c1.calcarea();c2.calcarea(); cout&lt;&lt;&quot;圆的信息：&quot;;c1.show(); cout&lt;&lt;&quot;--------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;圆柱的信息：&quot;;c2.show(); return 0; }]]></content>
      <tags>
        <tag>C++</tag>
        <tag>上机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于三种css垂直居中]]></title>
    <url>%2F2017%2F04%2F22%2Fcss%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[目的写前端的时候总是忘记垂直居中…每次都要去搜代码 既然有了博客，就干脆整理一下写在这里吧 基于绝对定位main{ position: absolute; top: 50%; left: 50%; margin-top: -3em; margin-left: -9em; width: 18em; height: 6em; } 如果借助calc()函数的话…. main{ position: absolute; top: calc(50% - 3em); left: calc(50% - 9em); width: 18em; height: 6em; } PS: 然而这种方法只局限于固定宽高的元素… 所以我们还可以选择translate()变形函数 main{ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } ..缺陷自寻.. 基于视口单位main{ width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%); } ..vw,vh这里不再赘述.. PS: 只适用于在视口中居中的场景 基于Flexboxbody{ display: flex; min-height: 100vh; margin: 0; } main{ margin: auto; } 或者… main{ display: flex; align-items: center; justify-content: center; width: 18em; height: 10em; } PS: 要求你的浏览器支持Flexbox…. 或许你可以尝试一下… align-self: center; 参考: 《CSS揭秘》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[addone]]></title>
    <url>%2F2017%2F04%2F20%2Faddone%2F</url>
    <content type="text"><![CDATA[欢迎各位来到我的简单博客 其实这里什么都没有2333333333333333]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的散文诗-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle3%2F</url>
    <content type="text"><![CDATA[我 想我想把耳朵，贴在溪边的小树上。听小溪清脆地演奏，听小鸟欢快地啼叫。听啊，听——来到梦一般的仙境。我想把鼻子，放在鲜花上。闻鲜花的芳香，嗅生命的清爽。闻啊，闻——使我更加舒爽。我想把双手，装在飞机上。捉住柔软的白云，逮住太阳的光。玩啊，玩——蓝天是我的乐园。我想把自己，变成一条鱼。在海底，与小鱼嬉戏，与海藻玩耍。无忧无虑，尽情畅游。游啊，游——海底就是我的家。我想把自己，化为一只雄鹰。俯看长城的雄伟，再瞧草原的辽阔。飞啊，飞——见证祖国的欣荣繁茂。我想张开双臂，把祖国的山川揽入怀中。尽享山之静，水之美。我想有一百张，一千张嘴，来歌唱我的祖国——祖国，我为你骄傲！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-2]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle2%2F</url>
    <content type="text"><![CDATA[时光匆匆轻轻地打开书本，低声诵起了朱自清的《匆匆》：“燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候……”多么优美，多么富于哲理的话语，我一遍又一遍地读着、读着……屈指一算，已有四千多个日夜从我身边流过，还有三个月就要小学毕业了。如果再过三千多个日夜我就该大学毕业走向社会了，成为一个来建设祖国的建设者了。如何才能做一个合格的小学生呢？如何做才能成为一个合格的建设者呢？我们这代青少年有理想，又有抱负，但不能坐享其成。有些青年靠幻想来度日：想着以后该做什么，怎样为国家做贡献，就是不开始行动，甚至相信天上会掉下馅饼来。让时间在幻想当中白白流失了。有的人，总把事情推到明天再做，要知道“明日复明日，明日何其多。我生待明日，万事成蹉跎”啊！时光冉冉，我已从嗷嗷待哺的婴儿成长到乖巧懂事的六年级学生，时间就这样溜走――早晨，当我开始洗漱时，时间从水盆里溜走；中午，当我放学回家时，时间从脚下溜走；晚上，当我观望星空时，时间从眼前溜走……“光阴似箭，日月如梭。”每时每刻，时间都从我身边溜走，而且去而不返。“一寸光阴一寸金，寸金难买寸光阴。”这使我加倍珍惜它，把握分分秒秒。直至现在，它还在催促我长大，但是我并不感谢它，因为它在催促我长大的同时，也让生命点滴流逝。我总是追赶它，渴望与它同起同作，同止同息，但是，那却是可望而不可及的。今年的春天一定在想——去年的春天寄托了什么样的理想，明年的春天又会是一个怎样的景象？这一切我都无法作答，但愿像欧阳修所说的那样：今年花胜去年红，明年花更好，更与我同！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle1%2F</url>
    <content type="text"><![CDATA[珍爱生命 让人生更精彩一个生命从春天走过，至少它美丽过； 一个生命从夏天走过，至少它辉煌过； 一个生命从秋天走过，至少它绚烂过； 一个生命从冬天走过，至少它坚强过。吟起这首诗，我自问：“生命是什么？”它不是一场雨，雨下在地上蒸发成水汽还会再落下；它不是一棵小草，小草枯了春天还会再荣；生命是无意间爬上额间的河流，当我们懂得珍惜时，河道已很深，深深的河道里有深深的遗憾。生命犹如单行道，没有回头的机会；生命是宇宙时间，永远无法找到两个相同时刻。“人，最宝贵的东西是生命。生命属于人只有一次。”汶川地震，警察妈妈哺育受灾幼儿；玉树天灾，护士妈妈再现慈爱。珍爱生命，人生将更精彩。感悟生命从连绵上浮起，从一点一滴中渗出，在细微处藏身。生命的长河倒映着红花绿叶、飘零积雪，变迁着湖畔边丝丝色泽，并渐渐地前行。大江东去，璀璨的生命镌刻着历史的痕迹，激荡着颗颗璀璨的明珠。生活中不可能处处有鲜花，时时有掌声。在你留意生命、珍惜生命的旅程中，你会发现，当生命被生活推向极致的地方，往往会展现出一些从容之美，临乱世而不惊，处方舟而不躁，喜迎阴晴圆缺，笑傲风霜雨雪；你更会明白，只有抱着一颗常人的平常之心，去看待生命，去珍惜生命，生命才会更有意义。生命是一种神秘的力量，说它脆弱，它就像薄冰一样不堪一击；说它坚强，它又像大山一般坚韧不拔。像海伦·凯勒，她是一位双耳失聪、双目失明的残疾人，但她凭着自己的毅力和信念，凭着对生命的热爱，先后掌握了四门外语，成为哈佛大学的一名学生，你能不说这是生命所创造的奇迹吗？去追寻你的梦想，去你想去的地方，做一个你想做的人。因为，生命只有一次，亦只得一次机会去做你所想做的事。我们应让自己的生命在理智的搏击中度过，就像落叶、谢花一样，潇洒地来，潇洒地去，做到对生命无怨无悔，让生命之光永远辉煌。珍爱生命吧，哪怕生命只有一霎那，那也让它成为一种永恒！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
</search>
