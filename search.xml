<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之MVC,MVP,MVVM]]></title>
    <url>%2F2018%2F04%2F16%2FMVC-MVVM-MVP%2F</url>
    <content type="text"><![CDATA[MVCMVC是模型(Model)－视图(View)－控制器(Controller)的缩写，是设计模式中最常用的软件架构 Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的 View：视图，为用户提供使用界面，与用户直接进行交互。 Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应 MVC中只有单向通信 用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等 服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理 Model处理后，将处理结果再交给Controller Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端 MVPMVP是Model-View-Presenter，即将MVC中的控制器Controller换成了Presenter负责逻辑的处理 Presenter: 中介者，连接Model和View层 MVC和MVP的区别是：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller 各部分之间都是双向通信 View 接收用户交互请求 View 将请求转交给 Presenter Presenter 操作Model进行数据更新 Model 通知Presenter数据发生变化 Presenter 更新View数据 MVVMMVVM是Model-View-ViewModel，和MVP的区别在于Presenter换成了ViewModel负责逻辑处理 Model 层，对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model View 层，作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明 ViewModel 层把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新 MVVM的优点是低耦合、可重用性、独立开发 双线数据绑定 View 接收用户交互请求 View 将请求转交给ViewModel ViewModel 操作Model数据更新 Model 更新完数据，通知ViewModel数据发生变化 ViewModel 更新View数据]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Camp - 简明Git入门|笔记记录]]></title>
    <url>%2F2018%2F04%2F15%2FGit-Camp-%E7%AE%80%E6%98%8EGit%E5%85%A5%E9%97%A8-%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[What is Git ?Super popular Version Conntrol System Reasons to Love Git HistoryManage history CollaborationNo waiting,Continue working Feature branchesBranches Tree Why should we learn Git?No Why Where do we beginmkdir coding-net cd coding-net touch index.html git init git add . git commit -m &#39;init&#39; History Back git status //查看一下状态 git checkout -- . 如果此时你电脑坏了还能找回么? 不能，因为现在还只是本地状态，一切都只现存在你电脑里 Solution: Push 插曲Svn 和 Git 拥有权限管理的功能，每个人只能看到管理员允许自己看到的代码，但是当Svn服务器挂掉后，每个人只有部分的代码，但是Git中每个人都有全部的代码 Master杂项 Master指向可以规定 Master与Branch平级 Clone后Head指向Master Branch杂项git branch -b feature //创建并切换到feature分支 git checkout master //切换到Master git branch -D xxx //删除xxx分支 如果删除feature分支，那么这个节点还存在么? 存在，feature只是一个指向该节点的指针，删除后节点依然存在，只不过没有指针指向它，最后会被Git垃圾回收机制清理 分支提交 git push origin // 将当前分支推送到origin主机的对应分支 git push origin aaa:bbb //远程创建bbb分支并将aaa推入 git push -u origin master // 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了 因为是入门的Git Camp，虽然自己都会了，但还是收获颇多 还混了一个洋葱猴..]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二新人的一次搜狐前端实习电面]]></title>
    <url>%2F2018%2F04%2F13%2F%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%9C%E7%8B%90%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[背景暑假想找一份实习，碰巧看到了学长的搜狐内推，就把自己的没有诚意的简历投了过去，过了一个多星期收到了电话面试的邮件(十分怀疑是学长面子比较大)。 问题 这里只挑几个重点的问题记录一下(我记得的..) React和Vue相同点 都使用了Virtual DOM 组件化 不同点 React使用JSX渲染页面，Vue使用简单的模板 React不是MVVM,而Vue是,拥有双向数据绑定,允许插值表达式 React中只能用setState修改状态,Vue中可直接修改data React Native与Weex Promise Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected。状态转变只能是 pending -&gt; fulfilled 或者 pending -&gt; rejected。状态转变不可逆 then 方法可以被同一个 promise 调用多次 then 方法必须返回一个 promise。规范里没有明确说明返回一个新的 promise 还是复用老的 promise（即 return this），大多数实现都是返回一个新的 promise，而且复用老的 promise可能改变内部状态，这与规范也是相违背的 值穿透 这里还问了一下具体实现，我只答上了nextTick() 原型链举个例子: 在一个对象上寻找成员的时候，如果没有找到就继续顺着proto往上找，如果最后没找到就报错(直到Object.prototype)balabala… 继承原型链 // B 继承 A B.prototype = new A() Class class B extends A{ constructor(props) { //调用实现父类的构造函数 super(props); } } Undifined 和 Null这是Js的两个基本类型..balabala.. 什么时候这两者会出现? Undifined是未赋值..当你定义了一个变量但是没赋值，或者像是变量提升这种balabala.. Null在我看来是一个指向Object的指针..因为Typeof Null = Objectbalabala… 面试官: 那什么时候Null会出现? 我TM竟然没答上来..当时心里就是一阵凉凉，后来我一想Null不就是没赋值的引用类型么.. 读过什么源码么读过React的setState和Node的setImmediate… 但是考虑到自己水平问题这里就一笔带过了..然后嘴欠提了句感觉读源码对自己现阶段帮助不大，面试官还问了问为什么，我又好不容易圆回来23333 你使用的Html5和Css3新特性Html5 audio，video，canvas，datalist.. Canvas用的比较多，用其模仿过草莓音乐节的宣传视频动画datalist在懒加载的时候有经常用.. Css3 选择器，Animation，Transition，Transform… 然后让我描述了一下看见一个动画如何去实现它..balabala.. 我觉得没人能完全答上来所有的…主要还是说一下自己用的比较多的 总结面试方面 面了大约40-50分钟左右，技术点自我感觉扯上了80%左右，没答上的也尽量扯一点(除了一些自己真的听都没听过的)。感觉问的技术面不是很广(可能因为是实习生)，原生方面问的比较多..但是没问一些更深入一点的，自己比较擅长的Css和React方面也问的比较少(难过)，浏览器和Http方面没问，整体来说面试难度不大..可能考虑到我只是个大二来实习的😂 自己方面人生第一次电话面试..全程紧张，大脑间歇性暂时性空白，许多自己会的没有完美地答出来很遗憾，自己会的想表现出来的没问也有点遗憾，其中还有几次尴尬的寂静(最怕空气突然安静)，不出意外自己应该是凉了QAQ。 但是想想自己大二还有时间补救，赶紧把这篇博客整理出来反思一下自己，诸君共勉吧~ 一些补充 这篇文章好像省略了绝大部分问题(我真的记不起来了) 后来Leader又问了我许多项目相关的问题，但是请看下一条 本文只记录了我记得的中认为有价值(其实是我觉得可以写出来的)的问题 面试官还是不错滴 本文比较适合找实习工作的小萌新 本文随我的记忆实时更新..]]></content>
      <categories>
        <category>技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式]]></title>
    <url>%2F2018%2F04%2F12%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 应用场景 某些管理类，保证资源的一致访问性。 创建对象时耗时过多或耗费资源过多，但又经常用到的对象； 工具类对象 频繁访问数据库或文件的对象。 class CreateUser { constructor(name) { this.name = name; this.getName(); } getName() { return this.name; } } // 代理实现单例模式 var ProxyMode = (function() { var instance = null; return function(name) { if(!instance) { instance = new CreateUser(name); } return instance; } })(); // 测试单体模式的实例 var a = new ProxyMode(&quot;aaa&quot;); var b = new ProxyMode(&quot;bbb&quot;); // 因为单体模式是只实例化一次，所以下面的实例是相等的 console.log(a === b); //true 策略模式 策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。 策略模式的目的就是将算法的使用算法的实现分离开来。一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。 应用场景 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 /*策略类*/ var levelOBJ = { &quot;A&quot;: function(money) { return money * 4; }, &quot;B&quot; : function(money) { return money * 3; }, &quot;C&quot; : function(money) { return money * 2; } }; /*环境类*/ var calculateBouns =function(level,money) { return levelOBJ[level](money); }; console.log(calculateBouns(&#39;A&#39;,10000)); // 40000 代理模式 代理模式的定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。 常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。 应用场景 当我们想要隐藏某个类时，可以为其提供代理类 当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中进行权限判断来进行不同权限的功能调用） 当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行） var imgFunc = (function() { var imgNode = document.createElement(&#39;img&#39;); document.body.appendChild(imgNode); return { setSrc: function(src) { imgNode.src = src; } } })(); var proxyImage = (function() { var img = new Image(); img.onload = function() { imgFunc.setSrc(this.src); } return { setSrc: function(src) { imgFunc.setSrc(&#39;./loading,gif&#39;); img.src = src; } } })(); proxyImage.setSrc(&#39;./pic.png&#39;); 中介者模式 中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。 应用场景 当一组对象要进行沟通或者业务上的交互，但是其关系却又很复杂混乱时，可以采用此模式 当一个对象与其他的对象要进行紧密的交互，但又想服用该对象而不依赖其他的对象时 想创造一个运行于多个类之间的对象，又不想生成新的子类时 var goods = { //手机库存 &#39;red|32G&#39;: 3, &#39;red|64G&#39;: 1, &#39;blue|32G&#39;: 7, &#39;blue|32G&#39;: 6, }; //中介者 var mediator = (function() { var colorSelect = document.getElementById(&#39;colorSelect&#39;); var memorySelect = document.getElementById(&#39;memorySelect&#39;); var numSelect = document.getElementById(&#39;numSelect&#39;); return { changed: function(obj) { switch(obj){ case colorSelect: //TODO break; case memorySelect: //TODO break; case numSelect: //TODO break; } } } })(); colorSelect.onchange = function() { mediator.changed(this); }; memorySelect.onchange = function() { mediator.changed(this); }; numSelect.onchange = function() { mediator.changed(this); }; 装饰者模式 装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。 例如：现有4种型号的自行车分别被定义成一个单独的类，如果给每辆自行车都加上前灯、尾灯、铃铛这3个配件，如果用类继承的方式，需要创建4*3=12个子类。但如果通过装饰者模式，只需要创建3个类。 应用场景 原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求 函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性 Function.prototype.before = function(beforefn) { var self = this; //保存原函数引用 return function(){ //返回包含了原函数和新函数的 &#39;代理函数&#39; beforefn.apply(this, arguments); //执行新函数，修正this return self.apply(this,arguments); //执行原函数 } } Function.prototype.after = function(afterfn) { var self = this; return function(){ var ret = self.apply(this,arguments); afterfn.apply(this, arguments); return ret; } } var func = function() { console.log(&#39;2&#39;); } //func1和func3为挂载函数 var func1 = function() { console.log(&#39;1&#39;); } var func3 = function() { console.log(&#39;3&#39;); } func = func.before(func1).after(func3); func(); 以上来源于JavaScript设计模式 未完待续…]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现折叠展开菜单]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[背景在这篇文章《2018年设计趋势指南》中发现一款菜单不错，就想着用微信小程序实现 先上个动图 开始正题上方Nav基本flex布局再加个padding不需要多讲吧? 提一下，微信小程序里input的placeholder样式是写在placeholder-style里或使用placeholder-class 下方菜单 每个小卡片遵从flex布局，设置width: 50%，别忘了flex-wrap: wrap 每个小卡片内部同为flex布局并设置垂直居中，想了想还是科普下: .main-view-item{ display: flex; justify-content: center; align-items: center; width: 50%; } flex真他娘的好用 至于里面的图片是从iconfont上拿的，调这几个配色的时间是我布局时间的几十倍…. 动画 微信小程序的动画只能用JS，常规手段不可用，来个头脑风暴hack起来 观察每个卡片的折叠方向后，为每个卡片添加初始rotate使其反向折叠，我在这里定义了两个Class .rotateX90{ transform: rotateX(-90deg); } .rotateY90{ transform: rotateY(-90deg); } 好了这样就看不到卡片了，然后给菜单按钮添加点击事件改变卡片的rotate(动态改变Class)就Ojbk啦,就像这样 &lt;view class=&#39;main-view-item rotateX90 item1 {{item1Style}}&#39; animation=&#39;{{item1}}&#39;&gt;&lt;/view&gt; 实际情况应该用wx:for进行循环渲染 var duration = 150 var item1 = wx.createAnimation({ duration: duration, transformOrigin: &#39;0 0 0&#39; }) item1.rotateX(90).step() this.setData({ item1: item1, item1Style: &#39;item1Style&#39; }) 这里注意调整transformOrigin来控制折叠方向，对于后面的卡片在createAnimation中添加delay字段即可(差为duration的等差数列) 是不是很简单嗯? 至于菜单的收回，代码和展开差不多，就是反过来而已，不过有些展开的顺序和transformOrigin需要注意，这里还是贴一个代码吧: var duration = 150 var item3 = wx.createAnimation({ duration: duration, transformOrigin: &#39;100% 100% 0&#39;, delay: duration * 2 }) item1.rotateX(90).step() this.setData({ item3: item3, item3Style: &#39;&#39; }) 另外我在data里设置了两个变量isShow和isShowing来判断菜单是否展开或者正在展开，来控制点击事件，差不多像这样 handleClick(){ if(this.data.isShowing) return; else if(!this.data.isShow) this.showMenu() else this.hideMenu() } 在动画完成后对isShow和isShowing进行修改即可 欢迎有更好想法的朋友进行讨论~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个前端开发者的自我折磨(UI)]]></title>
    <url>%2F2018%2F04%2F03%2F%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%8A%98%E7%A3%A8-UI%2F</url>
    <content type="text"><![CDATA[背景偶然看到一篇UI优化文章，发现里面几个UI交互真滴不错，就自己动手撸了一下~ 上动图 代码按钮&lt;div class=&quot;load-div&quot;&gt; &lt;div class=&quot;load-progress&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wave-btn wave wave-small&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; class=&quot;load-btn load-btn-hover&quot; value=&quot;Show!&quot;&gt; &lt;/div&gt; 这里起作用的有3个div,load-progress模拟进度条,wave-btn模拟扩散的波纹,load-btn即为按钮 扩散的波纹.wave { position: absolute; width: 160px; height: 40px; background-color: #b749cd; border-radius: 5px; z-index: 8; } .wave-small { animation: wave-small .8s infinite linear; } .wave-large { animation: wave-large .6s infinite linear; } @keyframes wave-small { 30% { opacity: 0.5; } 100% { transform: scale(1.1, 1.4); opacity: 0; } } @keyframes wave-large { 30% { opacity: 0.5; } 100% { transform: scale(1.3, 1.6); opacity: 0; } } 使用绝对定位让波纹div在button下面避免遮盖,添加动画使div放大的同时变透明,通过30%调整到比较合适的视觉效果 const button = document.getElementsByClassName(&#39;load-btn&#39;)[0] button.onmouseover = () =&gt; { wave.classList.remove(&#39;wave-small&#39;) wave.classList.add(&#39;wave-large&#39;) } button.onmouseout = () =&gt; { wave.classList.remove(&#39;wave-large&#39;) wave.classList.add(&#39;wave-small&#39;) } 因为hover时button会变大，所以用js进行判断添加不同大小的波纹动画 变化的按钮.load-btn { position: relative; width: 160px; height: 40px; font-size: 16px; color: white; background-color: #d159ec; border-radius: 5px; border: none; outline: none; cursor: pointer; z-index: 9; } .loading-btn-size { animation: size-small, size-back; animation-delay: 0s, 1.4s; animation-duration: .1s, .5s; animation-fill-mode: forwards, forwards; animation-timing-function: ease-in, ease; } .load-btn-hover:hover { animation: color-deep .2s ease-in forwards; } @keyframes color-deep { 70% { transform: scale(1.1, 1.1) } to { background-color: #b749cd; transform: scale(1.1, 1.1) } } @keyframes size-small { to { transform: scale(1, .6); } } @keyframes size-back { 50% { transform: scale(1.2, 1.2); } 70% { transform: scale(1.1, 1.1); } 80% { transform: scale(1.2, 1.2); } to { transform: scale(1.1, 1.1); background-color: #74e795; } } hover时放大且颜色变深,这个就不细讲了,点击后缩小scale(1, .6),延时一段时间后变回原大小(比原来大一点)且更换颜色和文本,在size-back中通过调整百分比来模拟弹性 进度条.load-progress { position: absolute; top: 8px; height: 100%; background-color: rgba(0, 0, 0, 0.3); border-radius: 5px; z-index: 10; } .load-progress-x { animation: x-change 1.2s ease-in; animation-delay: .2s; } @keyframes x-change { from { width: 0; } to { width: 160px; } } 设置高度为button缩小后的高度，宽度从0到恢复模拟进度条，用透明黑色覆盖button来模拟进度条样式 展开的列表&lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;red&quot;&gt;&lt;/div&gt; &lt;div class=&quot;orange&quot;&gt;&lt;/div&gt; &lt;div class=&quot;yellow&quot;&gt;&lt;/div&gt; &lt;div class=&quot;green&quot;&gt;&lt;/div&gt; &lt;div class=&quot;qing&quot;&gt;&lt;/div&gt; &lt;div class=&quot;blue&quot;&gt;&lt;/div&gt; &lt;div class=&quot;purple&quot;&gt;&lt;/div&gt; &lt;/div&gt; HTML不解释 .list div{ width: 250px; height: 50px; margin-top: 10px; visibility: hidden; } .fade-show{ visibility: visible !important; animation: fade-show .5s linear; } @keyframes fade-show{ from { opacity: 0; } tp { opacity: 1; } } css没什么好讲的，这里使用visibility: hidden使元素隐形但是仍占据空间 const list = document.getElementsByClassName(&#39;list&#39;)[0] let i = 0 let n = list.length let timer = setInterval(() =&gt; { if(i == n) clearInterval(timer) if(i &lt; n){ list[i].classList.add(&#39;fade-show&#39;) i++; } },50) 定时器遍历NodeList添加动画class即可 总结其实写起来并不难，主要是看你的想法，每个人可能都有不同的实现方式，关键是看哪种效率最高]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入React知识点]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%B7%B1%E5%85%A5React%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[背景自己对React方面还没有一个系统的整理，并且自己ReactNative方面比较薄弱，毕竟平时很少用ReactNative进行开发，接触的相关项目也比较少，所以在这里对React的一些知识点进行一些总结，顺便提一下ReactNative方面的知识 开始以下内容基本为个人理解，如有错误欢迎指出 ReactNative相比于原生App的优势和劣势优势 节省编译时间，开发效率快 学习成本极低(对于我) 组件化 热更新 劣势 不太稳定 内存占用较高 React的生命周期详情可以看我写的这篇React生命周期简明宝典 关于setState setState() schedules an update to a component’s state object. When state changes, the component responds by re-rendering 一个简化的setState调用图 首先，setState是异步执行的 setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below.setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below. 这里意思大概就是setState并不总是立即生效..可能会有延迟，但是你可以用componentDidUpdate或者回调函数来解决这个问题 至于setState为什么是异步的，深入的话涉及到React的事务机制，比较高级，本人能力有限这里就不误人子弟了，有兴趣的同学可以去自学一波 如果你写代码的时候发现你set的data并没有立即生效，那么它们很可能被batch update了 setState并不负责更新数据，它只是把state和callback放入_pendingStateQueue和_pendingCallback中，并且把要更新的组件放入dirtyComponents序列 再来个详细一点的图 本人目前只能理解到这里了…这个知识点就先到这了 关于state(状态)和props(属性)stateReact 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致，在React里只需要更新state，然后根据新的state进行渲染。state 的主要作用是用于组件保存、控制、修改自己的可变状态，是一个局部的、只能被组件自身控制的数据源 初始值来源于getInitalState（constructor) 只能在组件内部进行setState 代表组件内部自身的状态，只能在自身组件中存在 props组件中的props是一种父级向子级传递数据的方式，作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改，除非外部传入的props发生改变 尽量减少react组件的state，来降低组件的复杂性以及维护的难度 RefReact 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例 例如: var MyComponent = React.createClass({ handleClick: function() { // 使用原生的 DOM API 获取焦点 this.refs.myInput.focus(); }, render: function() { // 当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;点我输入框获取焦点&quot; onClick={this.handleClick} /&gt; &lt;/div&gt; ); } }); ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&#39;example&#39;) ); Context在某些场景下，你想在整个组件树中传递数据，但却不想手动地在每一层传递属性。你可以直接在 React 中使用context API解决上述问题 绝大多数应用不需要使用context，这只是一个实验性的API，很有可能在未来的React版本中移除 这里有个官方的context例子，代码比较长我就不搬运了 React事件React有一套自己的事件系统，一般来说元素绑定事件都要用到React提供的事件接口 React的事件其实是做了一层事件代理(事件委托)，使用一个统一的事件监听器，当事件发生的时候，在映射里找到真正的处理函数并调用，简化了事件处理和回收机制，提升了效率。 如果你打印一下这个事件，就会发现是一个Proxy对象 如果在React中绑定了原生事件，组件卸载的时候记得解绑，避免内存泄漏 所以尽量避免在React中使用混合事件和Dom事件 高阶组件(HOC)高阶组件（HOC）是React开发中的特有名词，一个函数返回一个React组件，指的就是一个React组包裹着另一个React组件。可以理解为一个生产React组件的工厂 一句话概括：接受一个组件作为参数，返回一个组件的函数 有两种类型的HOC: Props Proxy（pp） HOC对被包裹组件WrappedComponent的props进行操作 Inherbitance Inversion（ii）HOC继承被包裹组件WrappedComponent 例子: // Target 是一个组件，它作为参数传给了Hoc这个函数 function Hoc(Target) { class Wrap extends Component { render() { return ( &lt;div className=&#39;wrap&#39;&gt; &lt;Target /&gt; &lt;/div&gt; ); } } return Wrap; } 本文随时间更新]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack配置讲解]]></title>
    <url>%2F2018%2F03%2F28%2FWebpack%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景之前讲了讲Parcel搭建React环境…想了想不讲一哈Webpack还真有点过意不去 开始安装npm install webpack webpack-cli -g # 或者 yarn global add webpack webpack-cli 配置创建package.json文件 npm install webpack -D # 或者 yarn add webpack -D 添加npm scripts &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack --mode production&quot; }, &quot;devDependencies&quot;: { &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;, } 入口随意创建./src/index.js，此为webpack默认入口文件，若想更改可以对webpack配置文件进行修改 module.exports = { entry: &#39;./src/index.js&#39; } // 上述配置等同于 module.exports = { entry: { main: &#39;./src/index.js&#39; } } // 或者配置多个入口 module.exports = { entry: { foo: &#39;./src/page-foo.js&#39;, bar: &#39;./src/page-bar.js&#39;, // ... } } // 使用数组来对多个文件进行打包 module.exports = { entry: { main: [ &#39;./src/foo.js&#39;, &#39;./src/bar.js&#39; ] } } loader 我们可以把 loader 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块 在module.rules中进行修改 module: { // ... rules: [ { test: /\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀 include: [ path.resolve(__dirname, &#39;src&#39;) // 指定哪些路径下的文件需要经过 loader 处理 ], use: &#39;babel-loader&#39;, // 指定使用的 loader }, ], } 关于loader的安装可以查看网址 plugin 模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成，只需在配置中通过 plugins 字段添加新的 plugin 即可 const UglifyPlugin = require(&#39;uglifyjs-webpack-plugin&#39;) module.exports = { plugins: [ new UglifyPlugin() ], } 输出 webpack 的输出即指 webpack 最终构建出来的静态文件，使用output字段进行修改 module.exports = { // ... output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;bundle.js&#39;, }, } // 或者多个入口生成不同文件 module.exports = { entry: { foo: &#39;./src/foo.js&#39;, bar: &#39;./src/bar.js&#39;, }, output: { filename: &#39;[name].js&#39;, path: __dirname + &#39;/dist&#39;, }, } // 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存 module.exports = { // ... output: { filename: &#39;[name].js&#39;, path: __dirname + &#39;/dist/[hash]&#39;, }, } 小结创建一个简单的配置文件webpack.config.js const path = require(&#39;path&#39;) const UglifyPlugin = require(&#39;uglifyjs-webpack-plugin&#39;) module.exports = { entry: &#39;./src/index.js&#39;, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;bundle.js&#39;, }, module: { rules: [ { test: /\.jsx?/, include: [ path.resolve(__dirname, &#39;src&#39;) ], use: &#39;babel-loader&#39;, }, ], }, // 代码模块路径解析的配置 resolve: { modules: [ &quot;node_modules&quot;, path.resolve(__dirname, &#39;src&#39;) ], extensions: [&quot;.wasm&quot;, &quot;.mjs&quot;, &quot;.js&quot;, &quot;.json&quot;, &quot;.jsx&quot;], }, plugins: [ new UglifyPlugin(), // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码 // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件 // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数 ], } 简单的webpack搭建就到这里]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和setImmediate小姐那销魂的一夜情]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%92%8CSetImmediate%E5%B0%8F%E5%A7%90%E9%82%A3%E9%94%80%E9%AD%82%E7%9A%84%E4%B8%80%E5%A4%9C%E6%83%85%2F</url>
    <content type="text"><![CDATA[背景Rex大佬看完我的那篇一道简单面试题理解JS事件机制（+1白话讲解)后推荐我加上setImmediate这个东东.. 于是这篇博客应运而生~ 简介This method is used to break up long running operations and run a callback function immediately after the browser has completed other operations such as events and display updates. 如果看不懂这段话…那么这篇文章可能不适合你 渐进先来个简单的Node.js的Event loop ┌───────────────────────┐ ┌─&gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │&lt;─────┤ connections, │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ Event loop的基础知识这里不再讲解.. 想了解的可以看我上面提到的那篇博文 timers: 这个阶段执行setTimeout()和setInterval()设定的回调。 I/O callbacks: 执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。 idle, prepare: 仅内部使用。 poll: 获取新的I/O事件；node会在适当条件下阻塞在这里。 check: 执行setImmediate()设定的回调。 close callbacks: 执行比如socket.on(‘close’, …)的回调。 例子setTimeout(function timeout () { console.log(&#39;timeout&#39;); },0); setImmediate(function immediate () { console.log(&#39;immediate&#39;); }); setTimeout(fn, 0)几乎等价于setTimeout(fn, 1) 结果如何? 答案是不确定，因为不能确定进行到timers的时候1ms是否已经过去，如果没过去那就执行check中的setImmediate了 另外如果在一些特定的上下文中执行，比如fs.readFile，该函数的回调执行是在poll阶段，那么接下来就一定会先执行check中的setImmediate 多次调用 setImmediate 则把回调都放入队列，在 check 阶段都会执行 setImmediate 回调里调用setImmediate ，则放到下次 event loop 未完待续]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas模仿草莓音乐节宣传视频]]></title>
    <url>%2F2018%2F03%2F27%2FCanvas%E6%A8%A1%E4%BB%BF%E8%8D%89%E8%8E%93%E9%9F%B3%E4%B9%90%E8%8A%82%E5%AE%A3%E4%BC%A0%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[简介在掘金上看了一篇文章，作者使用的是导出的svg，然鹅我不会，所以我就想着用canvas撸出来…顺便当复习了 代码 这里只挑一些我认为有价值的地方讲.. 想了想…canvas好像确实没啥值得讲的，主要是撸代码的时候注意绘画的坐标，要考虑健壮性…不然你会发现后期很难维护 animation-fill-mode: both这是个好东西，让最后放大的三个圆在执行动画前不显示样式以及动画结束后保持样式 代码Js太长 这里就只贴Html了 &lt;div class=&quot;main&quot;&gt; &lt;canvas id=&quot;left-dot&quot; height=&quot;500&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;left-scroll&quot; height=&quot;600&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;right-scroll&quot; height=&quot;600&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;circle-out&quot; height=&quot;500&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;circle-inner&quot; height=&quot;500&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;circle1&quot; height=&quot;500&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;circle2&quot; height=&quot;500&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;circle3&quot; height=&quot;500&quot; width=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; 成品]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcel上手与React开发环境搭建]]></title>
    <url>%2F2018%2F03%2F25%2FParcel%E4%B8%8A%E6%89%8B%E4%B8%8EReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[背景我从不关注代码之外的东西，因为我相信有人会帮我做这些… 之前上手了Parcel感觉还OK，在这里小小的整理一哈 开始操作 安装Parcel yarn global add parcel-bundler 创建package.json再顺便加个命令 yarn init -y // package.json &quot;scripts&quot;: { &quot;start&quot;: &quot;parcel index.html&quot; } 安装Babel yarn add babel-preset-env 安装node-sass yarn add node-sass 接着创建.babelrc { &quot;preset&quot;: [&quot;env&quot;] } 安装React依赖 yarn add react yarn add react-dom yarn add --dev parcel-bundler yarn add --dev babel-preset-env yarn add --dev babel-preset-react 在.babelrc中修改 { &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;] } 再整理一下目录…现在应该是这样的(关键的) node_modules src components containers App.js App.scss .babelrc index.html package.json index.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Parcel-React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; index.js import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; import App from &#39;./App&#39;; ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;)); App.js import React, { Component } from &#39;react&#39;; import &#39;./App.scss&#39;; class App extends Component { render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Hello Parcel-React&lt;/h1&gt; &lt;/div&gt; ); } } export default App; App.scss $color-red: red; $color-black: black; h1{ color: $color-red; cursor: pointer; &amp;:hover{ color: $color-black; } } package.json { &quot;name&quot;: &quot;parcel-test1&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;parcel index.html&quot; }, &quot;dependencies&quot;: { &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;node-sass&quot;: &quot;^4.8.3&quot;, &quot;react&quot;: &quot;^16.2.0&quot;, &quot;react-dom&quot;: &quot;^16.2.0&quot; }, &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;parcel-bundler&quot;: &quot;^1.6.2&quot; } } 最后npm run一哈 舒服了，终于可以不用手脚架了，自己动手丰衣足食 有什么其他依赖再自己yarn add或npm install就好啦]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>Parcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯前端实现Gif制作]]></title>
    <url>%2F2018%2F03%2F24%2F%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0gif%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[背景受在线Sorry动图制作启发，想自己用纯前端撸一个类似的东西出来，这里地址 开始操作Begin开始没有任何头绪，想着去别人源码那copy一下，发现根本用不上… Next 想法1: 用绝对定位将文字定位到gif上,然后根据gif特定时间点显示特定文字 想法2: 在特定的时间点上用canvas在gif上绘制特定的文字 Next Result想了想，上面两种想法很好实现，但是都只是把动图展示出来，不能把修改后的文字保存到gif里 再Next对gif的每一帧进行处理然后再拼成gif 再Next Result想了想，没什么大问题，那就开干吧 真正开始操作~怎么把处理后的图片拼接成gif是个问题，去google了一波发现gif.js这个玩意，api也很简单，把图片或者canvas传进去然后render一下就ojbk了,来个官方demo var gif = new GIF({ workers: 2, quality: 10 }); // add a image element gif.addFrame(imageElement); // or a canvas element gif.addFrame(canvasElement, {delay: 200}); // or copy the pixels from a canvas context gif.addFrame(ctx, {copy: true}); gif.on(&#39;finished&#39;, function(blob) { window.open(URL.createObjectURL(blob)); }); gif.render(); 至于如何获得gif的每一帧，我用的mac下的Gif preview 用户点击生成后用类似懒加载的方式加载图片 for(let i = 0 ; i &lt; num ; i++){ image = new Image() image.src = `xxxx${i}/xx.jpg` arr[i] = image } 请求数据量比较大，我先用mac下的Compress All对图片进行压缩，然后再用gzip进一步压缩所有文件(这都是后话了) 接下来调用canvas的drawImage，绘制arr图片数组中的图片，然后用canvas在上面绘制文字，注意绘制的过程使用函数requestAnimationFrame(这坑爬了好久)，关于此函数这里就不讲解了 function render(){ ctx.drawImage(arr[i],0,0) ...... requestAnimationFrame(render) } render() 然后一个循环把canvas都add进去 for(let j = 0 ; j &lt; num ; j++){ gif.addFrame(ctx,{delay: 167}) } 这里注意这两块代码执行的顺序，按照正常理解是draw一个add一个但是我发现不行(woc为什么?)，改了半天破罐破摔都draw完后再一股脑add进去发现竟然可以(???)… 我打印了一下执行顺序发现add竟然是在draw之前完成的 因为draw是递归调用，并且draw和add都是同步任务，按照Js单线程来看draw了一次后就轮到add的for循环执行，执行完毕后才会执行递归调用的draw 那么问题来了… 递归调用的draw还没执行，为什么for循环里就能把没绘制的元素状态”add”进去… 于是我看了一波源码 GIF.prototype.addFrame = function(image, options) { var frame, key; if (options == null) { options = {} } frame = {}; frame.transparent = this.options.transparent; for (key in frameDefaults) { frame[key] = options[key] || frameDefaults[key] } if (this.options.width == null) { this.setOption(&quot;width&quot;, image.width) } if (this.options.height == null) { this.setOption(&quot;height&quot;, image.height) } if (typeof ImageData !== &quot;undefined&quot; &amp;&amp; ImageData !== null &amp;&amp; image instanceof ImageData) { frame.data = image.data } else if (typeof CanvasRenderingContext2D !== &quot;undefined&quot; &amp;&amp; CanvasRenderingContext2D !== null &amp;&amp; image instanceof CanvasRenderingContext2D || typeof WebGLRenderingContext !== &quot;undefined&quot; &amp;&amp; WebGLRenderingContext !== null &amp;&amp; image instanceof WebGLRenderingContext) { if (options.copy) { frame.data = this.getContextData(image) } else { frame.context = image } } else if (image.childNodes != null) { if (options.copy) { frame.data = this.getImageData(image) } else { frame.image = image } } else { throw new Error(&quot;Invalid image&quot;) } return this.frames.push(frame) } instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性 很明显, 因为add时候参数没有传copy所以进入frame.context = image，看到context第一感觉是和执行上下文有关系，再打印一遍执行顺序发现gif.on(&#39;finish&#39;)是全部draw完后执行的，结合worker不难推出frame和canvas之间是类似引用的关系并且在子线程中不断执行… 最后就很简单了…render一下就ojbk 考虑到我服务器性能和网速… 我在这整个大函数外面套了个延时器…保证用户加载完图片后才开始drawImage，不然会报错 启动服务器使用node.js的express搭建 总结光是最后这个想法介绍起来都能看出来我踩了很多坑….之前的想法踩了多少坑就不提了23333，并且发现不对后整个代码都要重写emmm，不过收获还是很多，同样的问题不会犯第二次了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS人人都能写自定义Checkbox（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F23%2FCSS%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89Checkbox%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景那一刻…无数前端开发者想起了自己曾经被Checkbox支配的恐惧…这种在绝大多数浏览器中几乎或完全不能进行样式替代的玩意让开发者们被迫选择默认样式，或者是找一些访问性极差的hack方案… 开始操作 先把基本结构搞出来 &lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot; /&gt; &lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt; 可能有部分人不知道label有啥用: 当label与checkbox关联后，就可以起到触发开关的作用，并且我们可以通过对其添加一些内容(下面会讲解)来模拟checkbox的样式，再把真正的checkbox隐藏，最终达到我们的目的 添加样式 input[type=&quot;checkbox&quot;] + label::before{ content: &#39;\a0&#39;; /* 不换行空格 */ display: inline-block; /* 让元素和label处于同一行 */ vertical-align: .1em; /* 设置元素向上偏移.1em */ width: .8em; height: .8em; margin-right: .2em; /* 和label保持一定距离 */ border-radius: .2em; /* 加个圆角 */ background-color: lightcoral; text-indent: .15em; /* 设置元素内content(下文模拟的✓)的缩进 */ line-height: .65; /* 设置行高 */ } ‘+’ 选择器指相邻同胞选择器，例子中指选择紧挨在checkbox后面的label~ 对于content这个属性，这里有篇博客大家可以看一下编码 关于em这里就不再讲解啦~ 不过还是推荐大家出门拐拐拐去学习一下emmmmm. 展示 这个淡珊瑚色的框框就是我们设置的label::before 加个选中状态input[type=&quot;checkbox&quot;]:checked + label::before{ content: &#39;\2713&#39;; background: lightblue; } 展示 这个对勾的位置受到了上面样式text-indent: .15em的影响 这里用到了CSS3的checked伪对象选择器 隐藏默认的checkboxinput[type=&quot;checkbox&quot;]{ position: absolute; clip: rect(0,0,0,0); /* 剪裁绝对定位元素 */ } 展示 注意, 这里使用display:none虽然也能隐藏,但是会将checkbox从tab切换焦点的队列中删除(比如你输入完账号密码后使用tab不会使checkbox获得焦点) 结果 Html&lt;input type=&quot;checkbox&quot; id=&quot;awesome&quot; /&gt; &lt;label for=&quot;awesome&quot;&gt;Awesome!&lt;/label&gt; Cssinput[type=&quot;checkbox&quot;] + label::before{ content: &#39;\a0&#39;; display: inline-block; vertical-align: .1em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background-color: lightcoral; text-indent: .15em; line-height: .65; } input[type=&quot;checkbox&quot;]:checked + label::before{ content: &#39;\2713&#39;; background: lightblue; } input[type=&quot;checkbox&quot;]{ position: absolute; clip: rect(0,0,0,0); } 了解了基础操作后，相信各位能自己独立写一个自定义checkbox啦，各位也可以自由修改content或者添加动画做出酷炫的效果~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(吐槽)学生把代码作业放到博客里有错么?]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%90%90%E6%A7%BD-%E5%AD%A6%E7%94%9F%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%BD%9C%E4%B8%9A%E6%94%BE%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%87%8C%E6%9C%89%E9%94%99%E4%B9%88%2F</url>
    <content type="text"><![CDATA[起因事情发生在我的周围，某位同学(以下称为X总)把实验课布置的课设某一阶段的代码放到了博客里，并注解了自己的理解等等….听起来是一件值得表扬的事情，然而结果并不如此… 高潮当实验课助教检查收上来的作业报告时，发现有十多个人的代码是相同的…!经过调查，确定了是那些同学上网搜到了X总的博客，发现写的真好还有自己的理解，于是就开心的抄了下来 结果X总和抄作业的同学都受到了扣分或零分的处置，并且X总获得和助教私聊的机会一次(内容不得而知) 调查特派员addone对助教和X总进行了间接调查 助教: 因为我们不会去看是谁写的博客，所以只能对代码相同的同学同样处置 X总: (我: X总下一阶段还写博客么)我K谁还敢写啊.. 舆论群内活跃人员(敢说话的大佬们)倾向于X总 个人想法写博客的X总没有任何错误，错误都在于抄博客的同学，助教应该去找明是谁被抄(本来也不是难事)并且严厉警告那些抄代码的同学，而不是这种酷酷的说:”分不清是谁抄谁”那句”我K谁还敢写啊”真是令人寒心.. 各位看官你们的想法呢?]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码简明宝典]]></title>
    <url>%2F2018%2F03%2F18%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍状态码的职责是当客户端向服务端发送请求时候，描述返回的请求内容 状态码如200 OK ，以三位数字和原因短语组成 状态码 类别 原因短语 1XX informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 本文只介绍具有代表性的14个状态码 2XX成功2XX的响应结果表明请求被正常处理了 200 OK从客户端发来的请求在服务端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变(GET/HEAD) 204 No Content服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体 一般在只需要从客户端往服务端发送信息，而对客户端不需要发送新信息内容的情况下使用 206 Partial Content客户端进行了范围请求，而服务器成功执行了这部分的GET请求 响应报文中包含由Content-Range指定范围的实体内容 3XX 重定向3XX的响应结果表明浏览器需要执行某些特殊的处理来正确处理请求 301 Moved Permanently永久性重定向。请求的资源已经被分配了新的URI，以后应该使用资源现在所指向的URI 如果已经把资源对应URI保存为书签，这时应该按Location首部字段提示的URI重新保存 302 Found临时性重定向。请求的资源已经被分配了新的URI，希望用户(本次)使用新的URI访问 只是临时性质的移动。如果已经把URI保存为书签，不会像301那样去更新，而是仍旧保留返回302状态码的页面对应URI 303 See Other请求对应的资源存在着另一个URI，应使用GET方法定向获取请求资源。 303与302有相同的功能，但是303明确表明应该使用GET方法 304 Not Modified客户端发送附带条件的请求时，服务器允许请求访问资源。但若请求未满足条件，则直接返回304(服务端资源未改变，可直接使用客户端未过期的缓存) 307 Temporary Redirect临时重定向。与302 Found有相同的含义 307会遵照浏览器标准，不会从POST变成GET 4XX 客户端错误4XX的响应结果表明客户端是发生错误的原因所在 400 Bad Request请求报文中存在语法错误，需修改请求内容再次发送 浏览器会像对待200 OK一样对待该状态码 401 Unauthorized发送的请求需要有通过HTTP认证的认证信息，若之前已进行过一次请求，则表示认证失败。 返回该响应必须包含一个适用于被请求资源的WWW-Authenticate首部以质询用户信息。浏览器初次接收到401响应会弹出认证用的对话窗口 403 Forbidden请求资源的访问被服务器拒绝。服务器没有必要给出拒绝的详细理由。 未获得文件系统的访问授权，访问权限出现某些问题等情况都有可能触发403 404 Not Found服务器上无法找到请求的资源 也可在服务端拒绝请求且不想说明理由时使用 5XX 服务器错误5XX的响应结果表明服务器本身发生错误 500 Internal Server Error服务端在执行请求时发生了错误，也有可能是Web应用的Bug或临时故障 503 Service Unavailable服务器处于超负载或正在停机维护，无法处理请求。 补充 返回的状态码可能和信息不对等 URI是什么? 参考于《HTTP图解》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期简明宝典]]></title>
    <url>%2F2018%2F03%2F16%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍React的生命周期是我们掌握React工作过程所必须掌握的知识，同时也是部分公司的面试考点 概要React严格定义了组件的生命周期，其主要经历了如下三个过程 装载过程(Mount): 组件第一次在DOM树中渲染的过程 更新过程(Update): 组件重新渲染的过程 卸载过程(Unmount): 组件从DOM中删除的过程 装载过程组件第一次被渲染的时候，依次调用的函数为： constructor getInitialState getDefaultProps componentWillMount render componentDidMount 1. constructorES6中每个类的构造函数，要创建一个组件的实例就要调用相应的构造函数。但是并不是每个组件都要定义自己的构造函数，比如无状态的React组件。一个组件调用构造函数，往往是为了两个目的： 初始化state 绑定成员函数的this环境 getInitialState和getDefaultPropsgetInitialState：该函数返回值用来初始化stategetDefaultProps: 该函数返回值用来初始化props 这两者只有用React.createClass方法创造的组件类才会发生作用，并且React.createClass已经被Fb官方废弃，所以这里不细讲了 2. componentWillMount这个函数没什么存在感，因为在这个时候没有任何渲染出来的结果，调用setState修改状态也不会触发重新渲染，并且在这里做的事情完全可以提前到constructor中去做 3. render可以说React组件中最重要的函数，因为React组件的父类React.Component类对除render之外的生命周期函数都有默认实现 render并不做渲染工作，只是返回一个JSX描述的结构，最终由React库根据返回对象决定如何渲染 render应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的，因为纯函数不应该引起状态的改变 4. componentDidMount componentDidMount并不是在render调用后立即调用，其调用的时候render返回的JSX已经渲染了 componentWillMount可以在服务端和浏览器端调用，但是componentDidMount只能在浏览器端调用(因为”装载”过程是不可能在服务端完成的) 异步请求数据一般都在该函数内进行。 更新过程更新过程会依次调用以下生命周期函数： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 更新过程并不总是执行所有函数 1. componentWillReceiveProps只要是父组件的render函数被调用，在render里渲染的子组件就会经历更新过程，不管父组件传递给子组件的props有没有改变，都会触发componentWillReceiveProps。 注意通过setState触发的更新过程不会调用这个函数，不然岂不是死循环了? 2. shouldComponentUpdate应该是除了render之外最重要的函数了。它决定了一个组件什么时候需不需要渲染。render和shouldComponentUpdate是React中唯二需要有返回值的函数，shouldComponentUpdate返回一个布尔值，告诉React是否需要继续更新，若为true则继续，为false则停止更新，不会触发之后的重新渲染。 3. componentWillUpdate即将render时执行，初始化render时不执行。在这里同样不能setState，这个函数调用之后，就会把nextProps和nextState分别设置到rops和state中，紧接着调用render 4. render同上 5. componentDidUpdate组件更新完成后执行，初始化render时不执行 卸载过程卸载过程只有一个函数componentWillUnmount，当react组件要从DOM树上删除前，该函数会被调用，所以这个函数适合做一些清理工作。 eg: 在componentDidMount中用非react方法创建的DOM元素，如果不处理可能会发生内存泄漏，因此可以在该函数中将其清理干净 总结React的生命周期函数并没有想象中的那么复杂 参考于《深入理解React》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单CSS实现闪烁动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%AE%80%E5%8D%95CSS%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%83%81%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景本文承接自上文《CSS实现文字打字动画（+1白话讲解）》 介绍提到闪烁动画，很多人可能会想起 &lt;blink&gt; 这个标签，亦或者是text-decoration: blink这个东西，但是这两者都有很大的局限性，身为”专业”前端开发者的我们怎么能满足于此呢？所以我们不得不去寻找一些其他的方法。 开始操作原图 字体调回正常啦~ 想法1:让元素变成透明再变回原样 .title{ animation: blink 1s 3; } @keyframes blink{ to { color: transparent; } } 我们用Chrome开发者工具中的Animation看一看这个动画 可以发现..这个元素在变成透明之后会瞬间显现到原来的样子，很江硬，我想把他变成平滑的显现出来，于是想到了一个办法：通过修改关键帧，让其在循环周期中进行状态切换 .title{ animation: blink 1s 3; } @keyframes blink{ 50% { color: transparent; } } 舒服了一点 但是长了眼睛的读者一定能从图中发现这个动画的过程是加速的，导致这个动画看起来不是很自然 读了我上一篇文章的童鞋们一定会想到steps这个东西~ 让我们来试一哈 .title{ animation: blink 1s 3 steps(1); } @keyframes blink{ 50% { color: transparent; } } 完美 在这里用to的童鞋注意了，steps(1)表示颜色值的切换只发生在动画周期的末尾，所以效果会变成这样 傻了吧，你的动画是一下都不会闪的 回顾上一篇文章末尾提到了添加一个闪烁的光标，那么我们就用上面学到的知识来实现一下吧~ .title{ ... width: 17ch; white-space: nowrap; overflow: hidden; border-right: 2px solid; //不指定颜色，使光标和文字颜色一致 animation: typing 10s steps(17), blink 1s steps(1) infinite; //infinite用来使动画无限循环 } @keyframes typing{ from { width: 0; } } @keyframes blink{ 50% { border-color: transparent; } } 肥肠完美 因为字体等原因效果展示不是肥肠好，但是应该是最优解啦，还可以通过JS进行维护，这里就不讲啦 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器从输入URL到页面加载过程（+1白话精简讲解）]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88-1%E7%99%BD%E8%AF%9D%E7%B2%BE%E7%AE%80%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍:这是一个很常见的问题，我们每天都在经历这件事，但是却不能说出具体的过程，同时这也是前端面试的一个考点，所以每个学习前端的人都应该了解这个过程。 本文以Chrome浏览器为例，其渲染引擎为Webkit 接下来让我们一步一步走 输入URL后可概括为以下几个过程: 浏览器从DNS服务器获取域名的IP地址(DNS解析) 浏览器与该IP服务器建立TCP连接 浏览器发送HTTP请求 服务器接收请求并返回HTTP报文 浏览器接收返回内容 拿到返回内容后先放两张很容易搜到的流程图 可概括为以下几个过程: 渲染引擎同时解析HTML文档和样式(CSS和Style中)，两者分别生成DOM树和CSSOM树 将DOM中的”可见内容”(除head或display: none等等)和CSSOM合并(attachment)成RenderTree(渲染树) RenderTree构建完毕后进行布局(layout)，即为每个节点分配坐标 遍历RenderTree，Painting(绘制)每个节点 解析器遇到 script 标记时会立即解析并执行脚本，文档的解析将停止，直到脚本执行完毕 补充什么是CSSOM? CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动 为什么Script会阻碍文档的解析? 因为这两者公用同一个线程，且Script优先级较高 如何避免上一个问题? defer: 当浏览器遇到具有defer属性的脚本时，它会阻止加载和执行脚本，直到HTML文档中的所有元素都已解析为止 async: 使用 async 属性时，浏览器会异步加载和执行脚本，同时继续解析HTML中的其他元素，包括其他脚本元素 HTML都解析完成后才会绘制RenderTree么? 并不是。浏览器会尽早的把内容显示出来，所以每解析一部分就会绘制一部分。 希望你看完能有所收获]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道简单面试题理解JS事件机制（+1白话讲解)]]></title>
    <url>%2F2018%2F03%2F14%2F%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[定义 同步: 一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去 异步: 进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率 线程: 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位。指运行中的程序的调度单位 单线程: 单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。单线程就是进程里只有一个线程 问题console.log(100) setTimeout(function () { console.log(200) }, 0) console.log(300) 输出: // 100 // 300 // 200 解析 JS为单线程, 但是任务执行分为同步任务和异步任务 代码中console.log为同步任务, setTimeout为异步任务(这些基础东西就不过多解释了) 为了方便理解，我们可以认为JS这条单线程中有两条事件队列, 一条为同步队列(主事件大循环 Event Loop)，一条为异步队列，同步任务在同步队列中依次执行，异步任务在异步队列中依次执行，并且这两个队列是同时执行的。但是，JavaScript引擎只会执行同步队列中的任务，那么异步队列中的任务什么时候执行呢？ JavaScript引擎会不断遍历同步队列，当同步队列为空时，会将异步队列中执行完毕的异步事件的回调函数放入同步队列执行。 回顾现在让我们回来看看上面的面试题就很容易理解了，同步队列中console.log(100)和console.log(300)执行后，console.log(200)被推入同步队列执行，所以结果依次为100-&gt; 300-&gt;200 PS: setTimeout(fun, 0)中的0不是立即执行的意思, 而是同步队列为空时立即将fun推入同步队列 额外var flag = 1 setTimeout(function(){ flag = 0 }, 0) while(flag){ console.log(&#39;running&#39;) } 结果是什么? 答案为死循环，因为while(flag)中的代码将一直在同步队列中执行，而flag = 0没有机会被推入同步队列]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现文字打字动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F14%2FCSS%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%89%93%E5%AD%97%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍很多时候，我们会有一些奇怪的骚想法，比如让网页中的一些特定文本像敲代码一样一个一个显示出来，有一种命令行的感觉，增加设计感，很多人觉得这个效果要用很长一段JS来实现…. 正好手头有个例子，我决定用CSS实验一下 开始操作原图 emmmmmm…请忽略我的字体 想法1: 让这段文字从宽度0变成实际宽度 .title{ ... animation: typing 6s; } @keyframes typing{ from { width: 0; } } emmmm, 忘记禁止折行和剪切超出部分文本了 修改 .title{ ... white-space: nowrap; overflow: hidden; animation: typing 6s; } @keyframes typing{ from { width: 0; } } 看起来还不错，但是还不够，我们希望字符能一个一个出来，想了想，Animation里面有个叫steps的东西，各位可以简单的理解(具体的这里就不介绍啦)为: 里面放多大的数字就是分多少帧执行，比如steps(5)就是将动画分成5帧执行。 就算我们能让动画一帧一帧执行，但是怎么让字符一个一个出现呢? 答案是…. 无人问津的ch单位，这是CSS3的新单位，表示”0”的宽度，到这我想真正的解决方案就出现啦！ 在等宽字体中，”0”字形的宽度和其他所有字形的宽度是一样的 修改 .title{ ... width: 17ch; //别忘了把空格算上! white-space: nowrap; overflow: hidden; animation: typing 6s steps(17); //steps里为你的字符数 } @keyframes typing{ from { width: 0; } } 或许我们还需要一个闪烁的光标？那就留着下次讲好了(如果我没忘的话) 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native实现NbaApp]]></title>
    <url>%2F2018%2F03%2F13%2FReact-Native%E5%AE%9E%E7%8E%B0NbaApp%2F</url>
    <content type="text"><![CDATA[介绍本项目为react-native构建的Nba App 设计灵感参考于:灵感来源( 其实就是参考样式 功能简单了很多,因为比较懒233333 功能 nba比分查询 球员数据查询 球队排名查询 项目地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序模仿网易云音乐]]></title>
    <url>%2F2018%2F03%2F13%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[介绍使用微信小程序模仿网易云音乐,接口来源于: 接口地址 功能 网易云账号登录 歌单查看 每日推荐 歌曲随机,单曲,列表循环 歌词滚动 …. 项目地址 图片在github里我就不放在这啦~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React在线编辑简历]]></title>
    <url>%2F2018%2F03%2F13%2FReact%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[简介闲来无事写了几个小时… 代码还有许多问题, 以及保存为pdf功能未实现 功能 任何地方点击即可修改, 项目可以增加删除 图片就长这个样子 项目地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017自我总结]]></title>
    <url>%2F2018%2F01%2F03%2F2017%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知道该说什么相比于大一，失去了很多，也获得了很多 暑假 自学了Vue全家桶 练手了数个微信小程序 自学后端nodejs 我觉得这是我做过的最正确的决定..告别了jQuery等..这些技术也为我之后学习react等技术铺平了道路,也确定了我向全栈发展的目标 开学后, 我离开了陪伴我将近整个大一的项目组。 我认为这个项目组除了微薄的工资外已经不能给我带来什么了 一些琐碎的事情以及老套的技术栈只会拖累我 氛围也失去了成立之初的热情，当然这是无可避免的 但我仍然感激这个项目组,实话实说,这里帮我度过了小白阶段,我在这的每一次项目都尽职尽责,但为了自己终究会离开 决定 放弃了许多事情, 走好自己的路, 坚持下去, 不好高骛远, 我觉得有句话说的很对：“你只要比昨天的自己更好就行,一辈子都在跟别人攀比是人生的悲剧”。 每天坚持补充前端只是, 不只是会写代码, js深入浏览器原理缓存http等等前端概念技术不断学习 机遇偶然遇见了一份xxxx的招聘信息, 看到远程实习什么什么的就心动了,于是就投了简历。 但是公司要求的react和django我并不会 但是公司给你7天时间自学作为二面结果 思考了一下, 有些机会错过了就不会来了, 于是3天入门, 提前完成任务, 也很顺利的进入公司,老板人很好还给配了macpro 但是 只有看看外面的世界才知道自己有多垃圾 项目难度比想象中大很多 团队协作方式不熟悉 代码太不规范,刚开始几行代码都要review好几次 但是你的付出终会得到回报, 一切都会慢慢变好, 永远不要轻言放弃 展望 好好工作 抓住每个适合自己的机会 拒绝每个不合适的邀请 坚持自己的道路 照顾好她]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++2016上机题及咸鱼代码]]></title>
    <url>%2F2017%2F04%2F22%2FC-2016%E4%B8%8A%E6%9C%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2016年程序设计（2）实验考试题目及弱鸡代码本人C++水平较差,若嫌弃则只看题目即可 （30分）已有二进制文件“student.dat”和“a.dat”，分别存放着10个学生的基本信息。请将“student.dat”文件中第五个学生的所有基本信息连接到 “a.dat”的尾部，并将修改后的文件“a.dat”的内容输出显示在屏幕上。学生信息由以下结构体来描述：struct student{ char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生 }; （35分）如下student类的成员：（1）请完善该类中的函数；（2）编写主函数，要求：（a）创建student类对象s1（”zhangsan”,80），创建对象s2并用s1初始化s2。（b）输出s1的name，score；输出s2的name，score；（c）利用重载函数实现计算，并在主函数输出s1，s2的分数之和。class student{ private: char *name;//学生姓名 intscore;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 intgetScore();//获取分数 }; （35分）已知一个抽象类Shape，其定义为：class Shape{ protected: float area; //面积 public: float getarea() { return area; }//获取面积 virtual void calcarea()=0; //计算面积 virtual void show()=0; //显示基本信息 }; 要求：(1) 由它派生出圆类Circle，它包含数据成员半径（radius）以及相关的成员函数getradius();还包含一个构造函数，对成员radius进行初始化，并实现继承自Shape的纯虚函数。(2) 再由圆类Circle派生出圆柱类Cylinder，它包含数据成员高度（height）以及相关的成员函数getheight();还包含一个构造函数对成员height进行初始化并显式调用父类Circle类的构造函数，要求覆盖继承自Circle类的函数calcarea()和show()。圆柱类Cylinder继承自Shape类的数据成员area表示圆柱体的表面积。(3) 在main函数中用“圆——半径2.5，圆柱——底面半径2.0，高度6.0”进行测试（π取3.14），调用函数calcarea()计算面积，并调用函数show()输出对象的基本信息，要求Circle类show() 函数输出圆的半径和面积，Cylinder类的show()函数输出圆柱底面圆半径，高度以及表面积。 咸鱼题解,仅供参考和吐槽 第一题#include&lt;fstream&gt; using namespace std; struct student{ char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生 }; int main(){ student std[10]; fstream stu; stu.open(&quot;student.dat&quot;,ios::in|ios::binary); if(stu.fail()){ cout&lt;&lt;&quot;打开a.dat文件失败&quot;&lt;&lt;endl; exit(0); } for(int i=0;i&lt;5;i++) stu.read((char*)&amp;std[i],sizeof(std[i])); stu.close(); stu.open(&quot;b.dat&quot;,ios::out|ios::binary|ios::app); stu.write((char*)&amp;std[4],sizeof(std[4])); stu.close(); stu.open(&quot;b.dat&quot;,ios::in|ios::binary); stu.read((char*)&amp;std,sizeof(std)); for(int i=0;i&lt;7;i++){ stu.read((char*)&amp;std[i],sizeof(std)[i]); cout&lt;&lt;std[i].name&lt;&lt;&quot; &quot;&lt;&lt;std[i].age&lt;&lt;&quot; &quot;&lt;&lt;std[i].gender&lt;&lt;&quot; &quot;&lt;&lt;std[i].num&lt;&lt;endl; } stu.close(); return 0; } 第二题 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; class student{ private: char *name;//学生姓名 int score;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 int getScore();//获取分数 }; student::student(char *a,int b){ name = new char[strlen(a)+1]; strcpy(name,a); score = b; } student::student(student &amp;obj){ name = new char[strlen(obj.name)+1]; strcpy(name,obj.name); score = obj.score; } student::~student(){ delete []name; } int student::operator+(student &amp;right){ int sum; sum = this-&gt;score + right.score; return sum; } char *student::getName(){ return name; } int student::getScore(){ return score; } int main(){ student s1(&quot;zhangsan&quot;,80),s2 = s1; int sum; sum = s1 + s2; cout&lt;&lt;s1.getName()&lt;&lt;&quot; &quot;&lt;&lt;s1.getScore()&lt;&lt;endl; cout&lt;&lt;s2.getName()&lt;&lt;&quot; &quot;&lt;&lt;s2.getScore()&lt;&lt;endl; cout&lt;&lt;&quot;总分：&quot;&lt;&lt;sum; return 0; } 第三题#include&lt;iostream&gt; using namespace std; #define pai 3.14 class Shape{ protected: float area; public: float getArea(){ return area; } virtual void calcarea()=0; virtual void show()=0; }; class Circle:public Shape{ protected: double radius; public: Circle(double r):Shape(){ radius = r; } double getRadius(){ return radius; } void calcarea(){ area = radius*radius*pai; } void show(){ cout&lt;&lt;&quot;半径: &quot;&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;&quot;面积：&quot;&lt;&lt;area&lt;&lt;endl; } }; class Cylinder:public Circle{ private: double height; public: Cylinder(double height,double r):Circle(r){ this-&gt;height = height; } void calcarea(){ area = radius*radius*pai*2 + 2*pai*radius*height; } void show(){ cout&lt;&lt;&quot;半径：&quot;&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;&quot;高：&quot;&lt;&lt;height&lt;&lt;endl; cout&lt;&lt;&quot;表面积：&quot;&lt;&lt;area&lt;&lt;endl; } double getHeight(){ return height; } }; int main(){ Circle c1(2.5); Cylinder c2(6.0,2.0); c1.calcarea();c2.calcarea(); cout&lt;&lt;&quot;圆的信息：&quot;;c1.show(); cout&lt;&lt;&quot;--------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;圆柱的信息：&quot;;c2.show(); return 0; }]]></content>
      <tags>
        <tag>C++</tag>
        <tag>上机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于三种css垂直居中]]></title>
    <url>%2F2017%2F04%2F22%2Fcss%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[目的写前端的时候总是忘记垂直居中…每次都要去搜代码 既然有了博客，就干脆整理一下写在这里吧 基于绝对定位main{ position: absolute; top: 50%; left: 50%; margin-top: -3em; margin-left: -9em; width: 18em; height: 6em; } 如果借助calc()函数的话…. main{ position: absolute; top: calc(50% - 3em); left: calc(50% - 9em); width: 18em; height: 6em; } PS: 然而这种方法只局限于固定宽高的元素… 所以我们还可以选择translate()变形函数 main{ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } ..缺陷自寻.. 基于视口单位main{ width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%); } ..vw,vh这里不再赘述.. PS: 只适用于在视口中居中的场景 基于Flexboxbody{ display: flex; min-height: 100vh; margin: 0; } main{ margin: auto; } 或者… main{ display: flex; align-items: center; justify-content: center; width: 18em; height: 10em; } PS: 要求你的浏览器支持Flexbox…. 或许你可以尝试一下… align-self: center; 参考: 《CSS揭秘》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的散文诗-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle3%2F</url>
    <content type="text"><![CDATA[我 想我想把耳朵，贴在溪边的小树上。听小溪清脆地演奏，听小鸟欢快地啼叫。听啊，听——来到梦一般的仙境。我想把鼻子，放在鲜花上。闻鲜花的芳香，嗅生命的清爽。闻啊，闻——使我更加舒爽。我想把双手，装在飞机上。捉住柔软的白云，逮住太阳的光。玩啊，玩——蓝天是我的乐园。我想把自己，变成一条鱼。在海底，与小鱼嬉戏，与海藻玩耍。无忧无虑，尽情畅游。游啊，游——海底就是我的家。我想把自己，化为一只雄鹰。俯看长城的雄伟，再瞧草原的辽阔。飞啊，飞——见证祖国的欣荣繁茂。我想张开双臂，把祖国的山川揽入怀中。尽享山之静，水之美。我想有一百张，一千张嘴，来歌唱我的祖国——祖国，我为你骄傲！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-2]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle2%2F</url>
    <content type="text"><![CDATA[时光匆匆轻轻地打开书本，低声诵起了朱自清的《匆匆》：“燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候……”多么优美，多么富于哲理的话语，我一遍又一遍地读着、读着……屈指一算，已有四千多个日夜从我身边流过，还有三个月就要小学毕业了。如果再过三千多个日夜我就该大学毕业走向社会了，成为一个来建设祖国的建设者了。如何才能做一个合格的小学生呢？如何做才能成为一个合格的建设者呢？我们这代青少年有理想，又有抱负，但不能坐享其成。有些青年靠幻想来度日：想着以后该做什么，怎样为国家做贡献，就是不开始行动，甚至相信天上会掉下馅饼来。让时间在幻想当中白白流失了。有的人，总把事情推到明天再做，要知道“明日复明日，明日何其多。我生待明日，万事成蹉跎”啊！时光冉冉，我已从嗷嗷待哺的婴儿成长到乖巧懂事的六年级学生，时间就这样溜走――早晨，当我开始洗漱时，时间从水盆里溜走；中午，当我放学回家时，时间从脚下溜走；晚上，当我观望星空时，时间从眼前溜走……“光阴似箭，日月如梭。”每时每刻，时间都从我身边溜走，而且去而不返。“一寸光阴一寸金，寸金难买寸光阴。”这使我加倍珍惜它，把握分分秒秒。直至现在，它还在催促我长大，但是我并不感谢它，因为它在催促我长大的同时，也让生命点滴流逝。我总是追赶它，渴望与它同起同作，同止同息，但是，那却是可望而不可及的。今年的春天一定在想——去年的春天寄托了什么样的理想，明年的春天又会是一个怎样的景象？这一切我都无法作答，但愿像欧阳修所说的那样：今年花胜去年红，明年花更好，更与我同！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle1%2F</url>
    <content type="text"><![CDATA[珍爱生命 让人生更精彩一个生命从春天走过，至少它美丽过； 一个生命从夏天走过，至少它辉煌过； 一个生命从秋天走过，至少它绚烂过； 一个生命从冬天走过，至少它坚强过。吟起这首诗，我自问：“生命是什么？”它不是一场雨，雨下在地上蒸发成水汽还会再落下；它不是一棵小草，小草枯了春天还会再荣；生命是无意间爬上额间的河流，当我们懂得珍惜时，河道已很深，深深的河道里有深深的遗憾。生命犹如单行道，没有回头的机会；生命是宇宙时间，永远无法找到两个相同时刻。“人，最宝贵的东西是生命。生命属于人只有一次。”汶川地震，警察妈妈哺育受灾幼儿；玉树天灾，护士妈妈再现慈爱。珍爱生命，人生将更精彩。感悟生命从连绵上浮起，从一点一滴中渗出，在细微处藏身。生命的长河倒映着红花绿叶、飘零积雪，变迁着湖畔边丝丝色泽，并渐渐地前行。大江东去，璀璨的生命镌刻着历史的痕迹，激荡着颗颗璀璨的明珠。生活中不可能处处有鲜花，时时有掌声。在你留意生命、珍惜生命的旅程中，你会发现，当生命被生活推向极致的地方，往往会展现出一些从容之美，临乱世而不惊，处方舟而不躁，喜迎阴晴圆缺，笑傲风霜雨雪；你更会明白，只有抱着一颗常人的平常之心，去看待生命，去珍惜生命，生命才会更有意义。生命是一种神秘的力量，说它脆弱，它就像薄冰一样不堪一击；说它坚强，它又像大山一般坚韧不拔。像海伦·凯勒，她是一位双耳失聪、双目失明的残疾人，但她凭着自己的毅力和信念，凭着对生命的热爱，先后掌握了四门外语，成为哈佛大学的一名学生，你能不说这是生命所创造的奇迹吗？去追寻你的梦想，去你想去的地方，做一个你想做的人。因为，生命只有一次，亦只得一次机会去做你所想做的事。我们应让自己的生命在理智的搏击中度过，就像落叶、谢花一样，潇洒地来，潇洒地去，做到对生命无怨无悔，让生命之光永远辉煌。珍爱生命吧，哪怕生命只有一霎那，那也让它成为一种永恒！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[addone]]></title>
    <url>%2F2017%2F04%2F20%2Faddone%2F</url>
    <content type="text"><![CDATA[欢迎各位来到我的简单博客 其实这里什么都没有2333333333333333]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
      </tags>
  </entry>
</search>
