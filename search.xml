<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript引擎之属性访问优化]]></title>
    <url>%2F2018%2F06%2F24%2FJavascript%E5%BC%95%E6%93%8E%E4%B9%8B%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[背景最近在看Javascript引擎的时候看到了Shape这个东西， 在这里理解并且延伸一下 预热 - JS内存机制内存模型JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。简单来理解的话，其中基础数据类型大多数保存在栈中(闭包除外)，对象保存在堆中，常量保存在池中。 对于栈中的数据，根据先进后出来取，若想取下层的数据，就要先将上层的数据取出 对于堆中的数据，Js是不允许直接访问的，我们实际操作的都是对象的引用而不是它的本身，例如var a = { b: 20 }，当我们操作{ b: 20 }时，实际上是从栈中访问a来获取对象的地址引用，再从堆中获取我们需要的数据 其他一些细节知识这里就懒得写的 Shape基础我们无时不刻都在访问属性，那么对于JS来说，快速的属性访问就是必不可少的。这时，对于几个拥有相同属性的对象：12const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; a: 3, b: 4 &#125;; 它们有相同的键值对，我们可以说它们有相同的Shape(即key)，对于这种数据，JS如果在每个对象中都存储这些重复的数据，就会造成大量重复且不必要的内存开销。所以Javascript引擎会将这些对象的Shape和Value分开存储 这样对于相同的对象只需要存储一个Shape就可以了，每一个具有相同Shape的对象都会指向这个Shape实例 所有JavaScript引擎都使用Shape作为优化，但它们并不都称之为Shape 学术论文称之为Hidden Classes V8称之为Maps Chakra称之为Types JavaScriptCore称之为Structures SpiderMonkey称之为Shapes，演讲中统一使用了Shape 过渡链如果我们为一个对象添加或者删除了一个熟悉，那么Javascript引擎如何找到这个对象的新的Shape？其实很简单 123var obj1 = &#123;&#125;obj1.a = 1obj1.b = 2 大家都是聪明人，一眼就能看懂吧，但是我们甚至不需要存储一个完整的Shape，我们只需要知道新引入进来的属性即可 如果你要找obj1.a，那么只需要顺着过渡链找到引用了a的Shape即可 如果我们无法创建一个过渡链会怎样？1234var obj1 = &#123;&#125;obj1.a = 1var obj2 = &#123;&#125;obj2.b = 2 也很简单，构建一个树形分支结构即可，建立一个过渡树 对于一种特殊情况 123var obj1 = &#123;&#125;obj1.a = 1var obj2 = &#123; a: 2 &#125; 对于初始化就包含属性的对象，其过渡链跳过了empty，优化缩短了过渡链 困了 未完待续]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件杯H5端'视频尬舞机'开发记录]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E6%9D%AFH5%E7%AB%AF-%E8%A7%86%E9%A2%91%E5%B0%AC%E8%88%9E%E6%9C%BA-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[背景自己还没接触过这方面的开发，所以准备写一篇博客长期跟踪这个项目了 技术栈: 原生Javascript，WebRTC 开始基本结构这里使用Parcel进行搭建 12345678src --css --index.css --js --index.js --imgindex.htmlpackage.json 在index.html中引入Js和Css然后执行parcel index.html即可运行项目 WebRTC基于浏览器的安全策略，通过WebRTC（具体为getUserMedia）调用摄像头和麦克风获取音视频数据，只能是在HTTPS下的网页，或者是本地localhost下才能调用，需要先校验 123456789101112let isAllowed = truewindow.onload = validate()function validate()&#123; var isSecureOrigin = location.protocol === 'https:' || location.hostname === 'localhost'; if (!isSecureOrigin) &#123; alert('getUserMedia() must be run from a secure origin: HTTPS or localhost.'); isAllowed = false; // 判断是否满足条件 &#125;&#125; 然后调用相应的接口打开摄像头，进行链式调用 12345if(isAllowed)&#123; navigator.mediaDevices.getUserMedia(constraints) .then(handleSuccess) .catch(handleError);&#125; constraints为打开的video窗口配置，max，min为最大最小分辨率，ideal为你期望的最佳分辨率，这里目前先简单的做一下适配 1234567const constraints = &#123; audio: false, // 关闭声音 video: &#123; width: &#123; min: 350, ideal: window.screen.width + 200, max: 800 &#125;, height: &#123; min: 500, ideal: window.screen.height - 200, max: 1500 &#125; &#125;&#125;; 调用失败的函数 1234function handleError(error) &#123; console.log('navigator.getUserMedia error: ', error); alert('navigator.getUserMedia error: ', error);&#125; 调用成功的函数 123456789101112131415function handleSuccess(stream) &#123; window.stream = stream; //显示在页面上 var recordedVideo = document.querySelector('video#recorded'); recordedVideo.srcObject = stream; recordedVideo.onloadedmetadata = function(e) &#123; console.log("Label: " + stream.label); //视频图像 console.log("VideoTracks" , stream.getVideoTracks()); &#125;; videoPause(recordedVideo) // 注册暂停播放事件 imgFall() // 显示下落的图片&#125; 再修改一下Html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Index&lt;/title&gt; &lt;link rel="stylesheet" href="./src/css/index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;video id='recorded' class='recorded' autoplay&gt; 您的环境不支持播放视频。 &lt;/video&gt;&lt;/body&gt; &lt;script src='./src/js/index.js'&gt;&lt;/script&gt;&lt;/html&gt; 做到这，不用管之前下面那两个函数，你已经能看到窗口里的你了hhhhh 视频暂停video是绝对定位并且浮在最下面的，所以一些点击事件操作通过mask处理 1234567891011121314const mask = document.getElementById('mask');function videoPause(recordedVideo)&#123; mask.addEventListener('click', () =&gt; &#123; if(!recordedVideo.paused)&#123; isPause = true recordedVideo.pause() &#125;else&#123; isPause = false recordedVideo.play() &#125; &#125;)&#125; 图片下落这里目前只有一个图片来源，在图片onload回调里进行图片处理，这里封装了一个定时器来循环产生下落的图片 1234567891011121314151617let track = []function imgFall()&#123; let img = new Image() img.onload = () =&gt; &#123; track[0] = outInterval(() =&gt; &#123; let item = new Image() item.src = img.src item.style.left = parseInt((window.screen.width - 100) * Math.random()) + 'px' mask.appendChild(item) &#125;, 0, 5000) &#125; img.src = require('../img/people.png')&#125; 定时器封装外部延时器接受3个参数: callback: 回调函数 begin: 开始时间 delay: 定时间隔 用一个延时器来延时内部的定时器(innerInterval)，然后返回内部定时器 12345678910111213function outTimeout(callback, begin, delay)&#123; let timeout setTimeout(() =&gt; &#123; callback() timeout = innerInterval(callback, delay) &#125;, begin) return timeout;&#125; 内部定时器接受2个参数: callback: 回调函数 delay: 定时间隔 内部进行递归的setTimeout来实现定时器功能，避免了setInterval的间隔重叠问题，保证每个callback经过相同的时间后执行 123456789101112function innerInterval(callback, delay)&#123; const timeout = setTimeout(function()&#123; if(!isPause) callback() // 播放状态下才执行回调函数(图片下落) setTimeout(innerInterval(callback, delay), delay) &#125;, delay) return timeout;&#125; 下落处理此处为callback函数中的内容，每次执行的时候创建新的img然后随机left偏移，之后append到父元素中 12345let item = new Image()item.src = img.srcitem.style.left = parseInt((window.screen.width - 100) * Math.random()) + 'px'mask.appendChild(item) 123456789101112131415161718192021.mask img&#123; position: absolute; width: 100px; height: 120px; animation: fall 5s linear forwards;&#125;@keyframes fall &#123; from &#123; top: -120px; // 减去图片高度 &#125; to &#123; top: 100vh; // 落到屏幕下方 &#125; 90% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; // 变透明 &#125;&#125; 下落后要定时清除图片元素避免过多，设置清除为第一次下落后执行，间隔为每一次下落完成的时间 123456const deleteImg = outTimeout(() =&gt; &#123; if(mask.childNodes.length &gt; 3)&#123; let child = mask.childNodes mask.removeChild(child[0]) &#125;&#125;, 5000, 5000) 如果你想要多列图片下落只需要添加track以及相应的延时和删除即可 目前的样式]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于页面切换后setInterval出现延时问题]]></title>
    <url>%2F2018%2F06%2F08%2F%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2%E5%90%8EsetInterval%E5%87%BA%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[直接上问题今天没事在写3D粒子动画的时候，设置了一个延时器让粒子变换不同的样子..就像这样 本以为完美完成..然后切换页面后再回来 就会发现setInterval出现了延时.. 动画会一瞬间变的很快 1234567function enableTrigger(idx) &#123; if(window.interval) return; let interval = setInterval(() =&gt; &#123; morphTo(texts[idx].particles, '#da2f20'); idx = (idx + 1) % 3; &#125;,3000)&#125; 上网搜了一下如何判断页面切换。。找到了 123let hiddenProperty = 'hidden' in document ? 'hidden' : 'webkitHidden' in document ? 'webkitHidden' : null; 整理一下思路，修改一下原函数完美解决 12345678910111213141516function enableTrigger(trigger, idx) &#123; if(window.interval) return; let interval = setInterval(() =&gt; &#123; let hiddenProperty = 'hidden' in document ? 'hidden' : 'webkitHidden' in document ? 'webkitHidden' : null; if(document[hiddenProperty])&#123; return; &#125; morphTo(texts[idx].particles, '#da2f20'); idx = (idx + 1) % 3; &#125;,3000)&#125; 在前公司留下的习惯 尽量减少if里的缩进 这里就直接return了]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js技术题自写]]></title>
    <url>%2F2018%2F06%2F07%2FJs%E6%8A%80%E6%9C%AF%E9%A2%98%E8%87%AA%E5%86%99%2F</url>
    <content type="text"><![CDATA[1写一个方法，在一个未知对象中，找出所有的“李鹏”,并console.log输出: 对应值当前所在对象 当前对象有多少个目标值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const tar = &#123; a:&#123; b:&#123; c:&#123; d:&#123; e:&#123; name:"百度" &#125; &#125;, l:&#123; name:"李鹏", age: "李鹏" &#125; &#125; &#125; &#125;, d:"90", e:"90", l:&#123; a:&#123; b:&#123; c:&#123; version:"1.0.0.1", name:"李鹏" &#125; &#125; &#125; &#125;, f:&#123; name:"李鹏", update:"2017年03月20日" &#125;&#125;function getTar(tar, search)&#123; let count = 0 // 记录目标数 let path = [] // 记录所在对象 function _deep(tar)&#123; Object.keys(tar).map(item =&gt; &#123; if(Object.prototype.toString.call(tar[item]) === '[object Object]')&#123; path.push(item) _deep(tar[item]) // 如果是对象则递归遍历并将对象名加入path &#125;else if(tar[item] === search)&#123; count++ console.log(path) //找到则打印路径 &#125; &#125;) path.pop() // 遍历完一个对象的所有成员后回溯路径 &#125; _deep(tar) // 初始遍历 console.log(count)&#125;getTar(tar,'李鹏') 输出 12345["a", "b", "c", "l"]["a", "b", "c", "l"]["l", "a", "b", "c"]["f"]4 2找出数组arr中重复出现过的元素 123input: [1,2,4,4,3,3,1,5,3].sort()output: [1,3,4] 1234567891011121314const arr = [1,2,4,4,3,3,1,5,3].sort()function seleteDup(arr)&#123; let res = [] arr.map(item =&gt; &#123; if(arr.indexOf(item) != arr.lastIndexOf(item) &amp;&amp; res.indexOf(item) === -1)&#123; res.push(item) //第一次出现的位置和最后一次出现的位置不相等 并且res数组中没有 则添加 &#125; &#125;) console.log(res)&#125;seleteDup(arr) 3不使用循环，创建一个长度为100的数组，并使数组的每个值等于它的下标 1234567891011121314// 先创建一个长为100的数组然后Object.keys拿到字符数组, 需要转化为数字let temp = Object.keys(Array.apply(null, &#123;length:100&#125;))let arr = temp.map(item =&gt; &#123; return +temp;&#125;)// Array.keys拿到迭代器然后转为数组let arr = Array.from(new Array(100).keys())// 方法与第一种类似 同样为字符数组 需要转化let temp = Object.keys(Array.from(&#123;length:100&#125;))// es6扩展运算符let arr = [...Array(100).keys()] 4解析 URL 中的 queryString，返回一个对象返回值示例：12345&#123; name: 'coder', age: '20'. callback: 'https://youzan.com?name=test'&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const testURL = 'https://www.youzan.com?name=coder&amp;age=20&amp;callback=https%3A%2F%2Fyouzan.com%3Fname%3Dtest&amp;arr[]=1&amp;arr[]=2&amp;test=%7B%22b%22%3A%22bbb%22%2C%22c%22%3A%22ccc%22%2C%22d%22%3A%7B%22f%22%3A%22f%22%7D%7D';function isObj(decodeTemp, parent)&#123; if(decodeTemp.indexOf('&#123;') !== 0 || decodeTemp.lastIndexOf('&#125;') !== decodeTemp.length - 1)&#123; return null; &#125; let obj = &#123;&#125; let tempObj = decodeTemp.slice(1, decodeTemp.length - 1) let tempObjArr = tempObj.split(',') tempObjArr.map(item =&gt; &#123; console.log(item) let objArr = item.slice(1, item.length - 1).split(':') console.log(objArr) let key = objArr[0].slice(0, objArr[0].length - 1) let res = isObj(objArr[1].slice(1), obj) obj[key] = res ? res : objArr[1].slice(1) &#125;) console.log(obj) return obj;&#125;function parseQueryString(url) &#123; let temp = url.split('?') let arr = temp[1].split('&amp;') let paramObj = &#123;&#125; arr.map(item =&gt; &#123; let temp = item.split('=') let decodeTemp = decodeURIComponent(temp[1]) // 解码 let key = temp[0]; if(key.indexOf('[]') &gt; -1)&#123; key = key.slice(0, key.length - 2) // 获取数组名 const keys = Object.keys(paramObj) if(keys.indexOf(key) &gt; -1)&#123; paramObj[key].push(temp[1]) // 如果已经存在该数组则push &#125;else&#123; paramObj[key] = [temp[1]] &#125; &#125;else&#123; let res = isObj(decodeTemp, paramObj) paramObj[temp[0]] = res ? res : decodeTemp &#125; &#125;) console.log(paramObj) return paramObj;&#125;parseQueryString(testURL) 这里对嵌套的对象的处理有些问题 待修改 5输出以下语句结果1["1", "1", "11","5"].map(parseInt) 自解:先查看MDN 1parseInt(string, radix) string要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略 radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10 123let new_array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array &#125;[, thisArg]) callback生成新数组元素的函数，使用三个参数：&nbsp;&nbsp;&nbsp;&nbsp;currentValue&nbsp;&nbsp;&nbsp;&nbsp;callback 的第一个参数，数组中正在处理的当前元素。&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;&nbsp;&nbsp;callback 的第二个参数，数组中正在处理的当前元素的索引。&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;&nbsp;&nbsp;&nbsp;callback 的第三个参数，map 方法被调用的数组。thisArg可选的。执行 callback 函数时 使用的this 值 以上MDN内容用来科普 对数组[&quot;1&quot;, &quot;1&quot;, &quot;11&quot;,&quot;5&quot;]调用map后回调函数传入parseInt， 这里数组中每个元素都能转化成数字所以不用考虑string参数不符合要求，这里关键是要明白传给parseInt的参数都是什么 我们重写一个函数来测试一下 123456789let arr = ["1", "1", "11","5"]let parseInt = function(string, radix)&#123; return string + ' : ' + radix&#125;console.log(arr.map(parseInt))// ["1 : 0", "1 : 1", "11 : 2", "5 : 3"] 可以看到第一个参数传入了数组元素，第二个参数传入了索引，这和map函数接受的参数一样，那么我们可以猜一下最后一个参数传入的就是数组 123456789let arr = ["1", "1", "11","5"]let parseInt = function(string, radix, array)&#123; return string + ' : ' + radix + '-' + array&#125;console.log(arr.map(parseInt))// ["1 : 0-1,1,11,5", "1 : 1-1,1,11,5", "11 : 2-1,1,11,5", "5 : 3-1,1,11,5"] 这样题目就很好理解了.. 答案就是1[1,NaN,3,NaN]]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些感想]]></title>
    <url>%2F2018%2F06%2F04%2F%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[序今天路上跟舍友小聊了一些，又想起了最近发生的一些事情，感触颇深 杂记得大一跟着老师在项目组工作的日子，人生中第一次有了自己的办公室 后来在这个项目组里尽职尽责(对于这四个字我问心无愧)的写代码，从开始的几百块钱，到后来的1k+，虽然很少，但是涉世未深的我还真是开心呢，开心的我到处炫耀自己赚了钱，毕竟是靠着自己的能力赚的第一桶金，当时觉得自己在同龄人之中算是很优秀的了 在不断地学习过程中，了解了前端的新技术，也明白了我们项目组正在使用的技术是多么的 老套 ，也明白了我们的工资是多么的低hhhhhh。随着对社会的接触越来越多，自己越来越清楚自己想要的是什么。 仔细评估了一下，感觉自己如果继续留在项目组真的会 荒废时间 ，于是大二果断退出了…现在想想这是多么明确的决定，退出的这段时间我好好地沉淀了自己，学了前端的新技术，开始物色公司实习，并且朝这方面不断努力.. 之后偶然看到了一个远程实习的招聘，技术栈是React，虽然当时用的是Vue，但是基于对实习的渴望还是三天内转型React并且通过面试..在后来的几个月实习给我带来的最大的转折点就是让我爱上了React吧2333 我感觉我写跑题了。。这特么根本不是感想 静下心来，沉淀自己 多接触一下社会，不然你不知道自己菜成什么b样 别做了一点小东西就在朋友圈炫耀… 这点东西拿出来真的不值一提 不如分享一些经验什么的会更有用 业务层面的代码是个人学几天都会写… 多多关注内在的东西 面试的时候要放平心态不要紧张 少跟嘴炮选手打交道 Talk is cheap. Show me the code 紧跟时代的潮流，但是不要盲目的从众 永远不要害怕自己走的是最孤独的路!坚持下去，不要被别人动摇，让他们去走自己的路 相信自己的判断，在自己擅长的领域内，你才是专家 完成比完美更好]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二杭州有赞前端三轮面试]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%A4%A7%E4%BA%8C%E6%9D%AD%E5%B7%9E%E6%9C%89%E8%B5%9E%E5%89%8D%E7%AB%AF%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[背景个人感觉对杭州这个城市还是有很大好感的，正好在掘金上看到有赞的招聘，就顺势投了简历，第二天就收到了电话面试的邀请(吐槽一下没商量电面时间就直接突击面试2333 一点准备也没有hhhh) 电面问题在这里列一下问题，有这方面意向的小伙伴可以参考一下 react源码 render渲染机制 组件化思想 值传递 HOC 函数绑定 redux 箭头函数作用域 有无状态组件 setTimeout Promise js事件机制 let,const 类型检测,instanceof缺陷 浏览器缓存 react-router webpack打包工具 我只记得这些了23333 其中有一些是我自己扩展出来的 电面答了将近90%,个人和面试官感觉都是比较满意的 视频面Coding URL解析题 Promise处理图片加载 第一题真的问到我薄弱的地方了，当时看到题目内心就凉凉，虽然不难但是我真的没记住API，和一面结果比起来差很多。第二题是我强行加的2333，但是感觉也没能扳回一城 HR面 你为什么想来杭州工作 你觉得在前端这个领域应该具备什么样的技能 会让你觉得有成就感的事情 你准备在这条路上如何走下去 你今后两年的打算 你在学校内参与或领导的一些技术活动 你是如何学习前端的 …… 问了一下 杭州大部分互联网公司不会提供公司住宿 不过每个月会有1000+的补贴 有种生活费的感觉hhhh 收获 电面都是自己会的所以收获不大，不过自己当着面试官把这些知识点说一遍还是很有帮助的~ 视频面收获巨大23333,发现自己对Object的一些原生API不是很熟悉，以及一些问题的深度思考 Hr面的小姐姐说话很温柔 感想内心还是有点小遗憾，感觉视频面写代码和平时写代码真的不一样，会有一种压力…其实过后那些API很容易就想出来，但是当时的紧张让自己大脑暂时性空白(毕竟第一次视频面)，希望以后会避免这种事情发生 面试评价有赞的面试官都很棒!态度也很和谐很舒服，感觉这个是一个比较有技术实力的公司吧，面试处理效率也很高，搜了一下网上评价也很高。可以说是我面试的最舒服的一次了(虽然我只面试了一只手可以数过来的公司) 结果拿到Offer]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[create-react-app的webpack配置阅读]]></title>
    <url>%2F2018%2F05%2F15%2Fcreate-react-app%E7%9A%84webpack%E9%85%8D%E7%BD%AE%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[序 “你构建项目用webpack么?” “不, 我用parcel。” “那你用过什么脚手架么?” “create-react-app等等…” “那你读过create-react-app中的webpack配置源码么?” “当然，balabala….” Dev(开发环境)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158'use strict';const autoprefixer = require('autoprefixer');const path = require('path');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const CaseSensitivePathsPlugin = require('case-sensitive-paths-webpack-plugin');const InterpolateHtmlPlugin = require('react-dev-utils/InterpolateHtmlPlugin');const WatchMissingNodeModulesPlugin = require('react-dev-utils/WatchMissingNodeModulesPlugin');const eslintFormatter = require('react-dev-utils/eslintFormatter');const ModuleScopePlugin = require('react-dev-utils/ModuleScopePlugin');const getClientEnvironment = require('./env');const paths = require('./paths');const publicPath = '/';const publicUrl = '';const env = getClientEnvironment(publicUrl);module.exports = &#123; devtool: 'cheap-module-source-map', entry: [ require.resolve('./polyfills'), require.resolve('react-dev-utils/webpackHotDevClient'), paths.appIndexJs, ], output: &#123; pathinfo: true, filename: 'static/js/bundle.js', chunkFilename: 'static/js/[name].chunk.js', publicPath: publicPath, devtoolModuleFilenameTemplate: info =&gt; path.resolve(info.absoluteResourcePath).replace(/\\/g, '/'), &#125;, resolve: &#123; modules: ['node_modules', paths.appNodeModules].concat( process.env.NODE_PATH.split(path.delimiter).filter(Boolean) ), extensions: ['.web.js', '.mjs', '.js', '.json', '.web.jsx', '.jsx'], alias: &#123; 'react-native': 'react-native-web', &#125;, plugins: [ new ModuleScopePlugin(paths.appSrc, [paths.appPackageJson]), ], &#125;, module: &#123; strictExportPresence: true, rules: [ &#123; test: /\.(js|jsx|mjs)$/, enforce: 'pre', use: [ &#123; options: &#123; formatter: eslintFormatter, eslintPath: require.resolve('eslint'), &#125;, loader: require.resolve('eslint-loader'), &#125;, ], include: paths.appSrc, &#125;, &#123; oneOf: [ &#123; test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/], loader: require.resolve('url-loader'), options: &#123; limit: 10000, name: 'static/media/[name].[hash:8].[ext]', &#125;, &#125;, &#123; test: /\.(js|jsx|mjs)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; cacheDirectory: true, &#125;, &#125;, &#123; test: /\.css$/, use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, ], &#125;, &#123; test: /\.scss$/, loader: 'style!css!postcss!sass?outputStyle=expanded' &#125;, &#123; exclude: [ /\.(js|jsx|mjs)$/, /\.html$/, /\.json$/, /\.scss$/ ], loader: require.resolve('file-loader'), options: &#123; name: 'static/media/[name].[hash:8].[ext]', &#125;, &#125; ], &#125;, ], &#125;, plugins: [ new InterpolateHtmlPlugin(env.raw), new HtmlWebpackPlugin(&#123; inject: true, template: paths.appHtml, &#125;), new webpack.NamedModulesPlugin(), new webpack.DefinePlugin(env.stringified), new webpack.HotModuleReplacementPlugin(), new CaseSensitivePathsPlugin(), new WatchMissingNodeModulesPlugin(paths.appNodeModules), new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/), ], node: &#123; dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty', &#125;, performance: &#123; hints: false, &#125;,&#125;; 接下来我们从上到下进行阅读 这里只涉及module.exports中的内容 devtool1devtool: 'cheap-module-source-map', 这里是webpack的sourcemap配置。 sourcemap是为了解决开发代码与实际运行代码不一致时帮助我们debug到原始开发代码的技术 官方有十几种sourcemap这里不做普及，不懂的看一下详细官方文档 entry12345require.resolve('./polyfills'),require.resolve('react-dev-utils/webpackHotDevClient'),paths.appIndexJs, 默认装载了polyfills.js 载入热更新, 可以被看做具有更好体验的WebpackDevServer 你的入口文件 关于第三点，我们可以在paths.js中看到其为appIndexJs: resolveApp(&#39;src/index.js&#39;) output12345678910pathinfo: true,filename: 'static/js/bundle.js',chunkFilename: 'static/js/[name].chunk.js',publicPath: publicPath,devtoolModuleFilenameTemplate: info =&gt; path.resolve(info.absoluteResourcePath).replace(/\\/g, '/'), 告诉 webpack在bundle中引入「所包含模块信息」的相关注释(不在生产环境中使用) 决定了每个输出bundle的名称和目录 决定了非入口chunk文件的名称(name为入口名称) 指定在浏览器中所引用的「此输出目录对应的公开 URL」, 上文中为const publicPath = &#39;/&#39; 自定义每个source map的sources数组中使用的名称(此选项仅在 「devtool 使用了需要模块名称的选项」时使用, 上文在这里使用了cheap-module-source-map) resolve12345678910111213modules: ['node_modules', paths.appNodeModules].concat( process.env.NODE_PATH.split(path.delimiter).filter(Boolean)),extensions: ['.web.js', '.mjs', '.js', '.json', '.web.jsx', '.jsx'],alias: &#123; 'react-native': 'react-native-web',&#125;,plugins: [ new ModuleScopePlugin(paths.appSrc, [paths.appPackageJson]),], 告诉webpack解析模块时应该搜索的目录，按数组前后优先级进行搜索。这里process.env.NODE_PATH.split(path.delimiter).filter(Boolean)将路径按:或者;分割开返回数组并且去掉其中逻辑值为false的元素 自动解析确定的扩展，能够使用户在引入模块时不带扩展，比如import ./index.js可以写成import ./index 创建 import 或 require 的别名，来确保模块引入变得更简单，这里在引用模块的时候可以把目录名react-native-web简写成react-native 使用的额外的解析插件列表，这里使用ModuleScopePlugin限制自己编写的模块只能从src目录中引入 module123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384strictExportPresence: true,rules: [ &#123; test: /\.(js|jsx|mjs)$/, enforce: 'pre', use: [ &#123; options: &#123; formatter: eslintFormatter, eslintPath: require.resolve('eslint'), &#125;, loader: require.resolve('eslint-loader'), &#125;, ], include: paths.appSrc, &#125;, &#123; oneOf: [ &#123; test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/], loader: require.resolve('url-loader'), options: &#123; limit: 10000, name: 'static/media/[name].[hash:8].[ext]', &#125;, &#125;, &#123; test: /\.(js|jsx|mjs)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; cacheDirectory: true, &#125;, &#125;, &#123; test: /\.css$/, use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, ], &#125;, &#123; test: /\.scss$/, loader: 'style!css!postcss!sass?outputStyle=expanded' &#125;, &#123; exclude: [ /\.(js|jsx|mjs)$/, /\.html$/, /\.json$/, /\.scss$/ ], loader: require.resolve('file-loader'), options: &#123; name: 'static/media/[name].[hash:8].[ext]', &#125;, &#125; ], &#125;,], strictExportPresence使缺少的导出出现错误而不是警告, 默认值为false rules使创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用loader，或者修改解析器(parser) 这里rules中的每个loader就不讲了，把定义列一下自己就能看懂 test: 匹配要处理的文件的正则匹配，是 Rule.resource.test 的简写 enforce:加载器的执行顺序，不设置为正常执行。可选值 &#39;pre|post&#39;前|后 include:将要处理的目录包括进来 exclude:排除不处理的文件目录，可以使数组或字符串正则格式 issuer:一个条件，用来与被发布的 request 对应的模块项匹配 loader:是 Rule.use: [ { loader } ] 的简写 loaders:是 Rule.use的别名,由于需要支持Rule.use，此选项已废弃 oneOf:规则数组，当规则匹配时，只使用第一个匹配规则 options|query: 是 Rule.use: [ { options } ] 的简写，已废弃 parser:解析选项对象。所有应用的解析选项都将合并 resource:与资源匹配的条件，可以使用正则。例子中匹配资源内部 含有app的文件 如 app.js | demoapp.js resourceQuery:与资源查询匹配的条件，匹配资源?后面的字段 如 app.js?userName use: 应用于模块的UseEntries列表。每个入口(entry)指定使用一个 loader plugins在 webpack 的构建流程中，plugin 用于处理更多其他的一些构建任务。可以这么理解，模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成 这里只对用到的plugins功能进行分析，不对其进行具体分析 1234567891011new InterpolateHtmlPlugin(env.raw),new HtmlWebpackPlugin(&#123; inject: true, template: paths.appHtml,&#125;),new webpack.NamedModulesPlugin(),new webpack.DefinePlugin(env.stringified),new webpack.HotModuleReplacementPlugin(),new CaseSensitivePathsPlugin(),new WatchMissingNodeModulesPlugin(paths.appNodeModules),new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/), InterpolateHtmlPlugin: 和HtmlWebpackPlugin串行使用，允许在index.html中添加变量 HtmlWebpackPlugin: 简化了HTML文件的创建，以便为你的webpack包提供服务,可以让插件为你生成一个HTML文件，使用lodash模板提供你自己的模板，或使用你自己的loader NamedModulesPlugin: 当开启 HMR(模块热替换) 的时候使用该插件会显示模块的相对路径，建议用于开发环境 DefinePlugin: 允许创建一个在编译时可以配置的全局常量，这里设置了env.stringified为development HotModuleReplacementPlugin: HMR CaseSensitivePathsPlugin: 如果路径有误则直接报错 WatchMissingNodeModulesPlugin: 允许你安装库后自动重新构建打包文件 IgnorePlugin: 防止在 import 或 require 调用时，生成以下正则表达式匹配的模块 node这些选项可以配置是否 polyfill 或 mock 某些 Node.js 全局变量和模块。这可以使最初为Node.js 环境编写的代码，在其他环境（如浏览器）中运行 是一个对象，其中每个属性都是 Node.js 全局变量或模块的名称，每个 value 是以下其中之一 true：提供 polyfill。 &quot;mock&quot;：提供 mock 实现预期接口，但功能很少或没有。 &quot;empty&quot;：提供空对象。 false: 什么都不提供。预期获取此对象的代码，可能会因为获取不到此对象，触发 ReferenceError 而崩溃。尝试使用 require(&#39;modulename&#39;) 导入模块的代码，可能会触发 Cannot find module &quot;modulename&quot; 错误 1234567node: &#123; dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty',&#125;, 允许我来一个标准收尾 这就不用讲了吧?]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高级技巧(简洁版)]]></title>
    <url>%2F2018%2F05%2F07%2F%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84JS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[高级函数由于在JS中，所有的函数都是对象，所以使用函数指针十分简单，也是这些东西使JS函数有趣且强大 安全的类型检测JS内置的类型检测机制并不是完全可靠的 typeof操作符返回一个字符串，表示未经计算的操作数的类型，在大多数情况下很靠谱，但是当然还有例外 正则表达式12typeof /s/ === 'function'; // Chrome 1-12 , 不符合 ECMAScript 5.1typeof /s/ === 'object'; // Firefox 5+ , 符合 ECMAScript 5.1 NULL1typeof null === 'object'; // 从一开始出现JavaScript就是这样的 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了object instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性 语法 object instanceof constructor(要检测的对象 instanceof 构造函数) 但是在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。 1[] instanceof window.frames[0].Array //false 因为 Array.prototype !== window.frames[0].Array.prototype，因此你必须使用 Array.isArray(myObj) 或者 Object.prototype.toString.call(myObj) === &quot;[object Array]&quot;来判断myObj是否是数组 解决以上两个问题的方案就是Object.prototype.toString Object.prototype.toString方法返回一个表示该对象的字符串 可以通过toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply()的形式来调用，传递要检查的对象作为第一个参数，称为thisArg 1234567891011var toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]toString.call(/s/); // [object RegExp]toString.call([]); // [object Array]//Since JavaScript 1.8.5toString.call(undefined); // [object Undefined]toString.call(null); // [object Null] 作用域安全的构造函数构造函数其实就是一个使用new操作符调用的函数。当使用new调用时，构造函数内用到的this对象会指向新创建的对象实例 12345678function Person(name, age)&#123; this.name = name; this.age = age;&#125;let person = new Person("addone", 20);person.name // addone 当你使用new操作符的时候，就会创建一个新的Person对象，同时分配这些属性，但是如果你没有使用new 1234let person = Person("addone", 20);person1.name // Cannot read property 'name' of undefinedwindow.name // addone 这是因为this是在执行时确认的，当你没有使用new，那么this在当前情况下就被解析成了window，属性就被分配到window上了 作用域安全的构造函数在进行更改前，首先确认this对象是正确类型的实例，如果不是，就创建新的对象并且返回 1234567891011121314function Person(name, age)&#123; if(this instanceof Person)&#123; this.name = name; this.age = age; &#125;else&#123; return new Person(name, age); &#125;&#125;let person1 = new Person("addone", 20);person1.name // addonelet person2 = Person("addone", 20);person2.name // addone this instanceof Person检查了this对象是不是Person的实例，如果是则继续，不是则调用new 惰性载入函数假如你要写一个函数，里面有一些判断语句 1234567function foo()&#123; if(a != b)&#123; console.log('aaa') &#125;else&#123; console.log('bbb') &#125;&#125; 如果你的a和b是不变的，那么这个函数不论执行多少次，结果都是不变的，但是每次执行还要进行if判断，这就造成了不必要的浪费。 惰性载入表示函数执行的分支只会发生一次，这里有两种解决方式。 在函数被调用时再处理函数123456789101112function foo()&#123; if(a != b)&#123; foo = function()&#123; console.log('aaa') &#125; &#125;else&#123; foo = function()&#123; console.log('bbb') &#125; &#125; return foo();&#125; 这样进入每个分支后都会对foo进行赋值，覆盖了之前的函数，之后每次调用foo就不会再执行if判断 在声明函数时就指定适当的函数1234567891011var foo = (function foo()&#123; if(a != b)&#123; return function()&#123; console.log('aaa') &#125; &#125;else&#123; return function()&#123; console.log('bbb') &#125; &#125;&#125;)(); 这里创建一个匿名，自执行的函数，用来确定应该使用哪一个函数来实现。 惰性函数的优点就是只在第一次执行分支时牺牲一点点性能 函数绑定请使用fun.bind(thisArg[, arg1[, arg2[, ...]]]) thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效 arg1,arg2,… 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法 返回 由指定的this值和初始化参数改造的原函数拷贝 一个例子 123456789let person = &#123; name: 'addone', click: function(e)&#123; console.log(this.name) &#125;&#125;let btn = document.getElementById('btn');EventUtil.addHandle(btn, 'click', person.click); 这里创建了一个person对象，然后将person.click方法分配给DOM按钮的事件处理程序，当你点击按按钮时，会打印出undefiend，原因是执行时this指向了DOM按钮而不是person 解决方案： 将this强行指向person 1EventUtil.addHandle(btn, 'click', person.click.bind(person)); 函数柯里化函数柯里化是把接受多个参数的函数转变成接受单一参数的函数 12345678function add(num1, num2)&#123; return num1 + num2;&#125;function curryAdd(num2)&#123; return add(1, num2);&#125;add(2, 3) // 5curryAdd(2) // 3 这个例子用来方便理解柯里化的概念 下面是创建函数柯里化的通用方式 12345678function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; let innerArgs = Array.prototype.slice.call(arguments); let finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;&#125; 第一个参数是要进行柯里化的函数，其他参数是要传入的值。这里使用Array.prototype.slice.call(arguments, 1)来获取第一个参数后的所有参数(外部)。在返回的函数中，同样调用Array.prototype.slice.call(arguments)让innerArgs来存放所有的参数(内部)，然后用concat将内部外部参数组合，用apply传递给函数 12345678function add(num1, num2)&#123; return num1 + num2;&#125;let curryAdd1 = curry(add, 1);curryAdd1(2); // 3let curryAdd2 = curry(add, 1, 2);curryAdd2(); // 3 防篡改对象Javascript中任何对象都可以被同一环境中运行的代码修改，所以开发人员有时候需要定义防篡改对象（tamper-proof object) 来保护自己 不可扩展对象默认情况下所有对象都是可以扩展的(添加属性和方法) 12let person = &#123; name: 'addone' &#125;;person.age = 20; 第二行为person对象扩展了age属性，当然你可以阻止这一行为，使用Object.preventExtensions() 12345let person = &#123; name: 'addone' &#125;;Object.preventExtensions(person);person.age = 20;person.age // undefined 你还可以用Object.isExtensible()来判断对象是不是可扩展的 12345let person = &#123; name: 'addone' &#125;;Object.isExtensible(person); // trueObject.preventExtensions(person);Object.isExtensible(person); // false 请记住这是不可扩展!!，即不能添加属性或方法 密封的对象密封对象不可扩展，且不能删除属性和方法 12345678let person = &#123; name: 'addone' &#125;;Object.seal(person);person.age = 20;delete person.name;person.age // undefinedperson.name // addone 相对的也有Object.isSealed()来判断是否密封 1234567let person = &#123; name: 'addone' &#125;;Object.isExtensible(person); // trueObject.isSealed(person); // falseObject.seal(person);Object.isExtensible(person); // falseObject.isSealed(person); // true 冻结的对象这是最严格的防篡改级别，冻结的对象即不可扩展，又密封，且不能修改 123456789let person = &#123; name: 'addone' &#125;;Object.freeze(person);person.age = 20;delete person.name;person.name = 'addtwo'person.age // undefinedperson.name // addone 同样也有Object.isFrozen来检测 123456789let person = &#123; name: 'addone' &#125;;Object.isExtensible(person); // trueObject.isSealed(person); // falseObject.isFrozen(person); // falseObject.freeze(person);Object.isExtensible(person); // falseObject.isSealed(person); // trueObject.isFrozen(person); // true 以上三种方法在严格模式下进行错误操作均会导致抛出错误 高级定时器阅读前提 大概理解setTimeout的基本执行机制和js事件机制 重复的定时器当你使用setInterval重复定义多个定时器的时候，可能会出现某个定时器代码在代码再次被添加到执行队列之前还没有完成执行，导致定时器代码连续执行多次。 机智Javascript引擎解决了这个问题，使用setInterval()的时候，仅当没有该定时器的其他代码实例时，才会将定时器代码添加到队列中。但这还会导致一些问题: 某些间隔被跳过 间隔可能比预期的小 为了避免这个两个问题，你可以使用链式setTimeout()调用 12345setTimeout(function()&#123; TODO(); setTimeout(arguments.callee, interval);&#125;, interval) arguments.callee获取了当前执行函数的引用，然后为其设置另外一个定时器，这样就确保在下一次定时器代码执行前，必须等待指定的间隔。 Yielding Processes浏览器对长时间运行的脚本进行了制约，如果代码运行超过特定的时间或者特定语句数量就不会继续执行。 如果你发现某个循环占用了大量的时间，那么对于下面这两个问题 该处理是否必须同步完成? 数据是否必须按顺序完成? 如果你的两个答案都是”否”，那么你可以使用一种叫做数组分块(array chunking) 的技术。基本思路是为要处理的项目创建一个队列，然后使用定时器取出下一个要出处理的项目进行处理，然后再设置另一个定时器。 1234567891011function chunk(array, process, context)&#123; setTimeout(function()&#123; // 取出下一个项目进行处理 let item = array.shift(); process.call(item); if(array.length &gt; 0)&#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100)&#125; 这里接受三个参数，要处理的数组，处理的函数，运行该函数的环境(可选)，这里设置间隔100ms是个效果不错的选择 如果你一个函数需要50ms以上时间完成，那么最好看看能否将任务分割成一系列可以使用定时器的小任务 函数节流(Throttle)节流的目的是防止某些操作执行的太快。比如在调整浏览器大小的时候会出发onresize事件，如果在其内部进行一些DOM操作，这种高频率的更爱可能会使浏览器崩溃。为了避免这种情况，可以采取函数节流的方式。 123456function throttle(method, context)&#123; clearTimeout(method.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;, 100)&#125; 这里接受两个参数，要执行的函数，执行的环境。执行时先清除之前的定时器，然后将当前定时器赋值给方法的tId，之后调用call来确定函数的执行环境。 一个应用的例子12345678function resizeDiv()&#123; let div = document.getElementById('div'); div.style.height = div.offsetWidth + "px";&#125;window.onresize = function()&#123; throttle(resizeDiv);&#125; 这个就不用讲了吧2333 文章参考于《JavaScript高级程序设计(第三版)》 如果你觉得我的理解有问题或者整理的太简略，那么我强烈安利你自己去读一下这本书~]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发者如何快速的把UI撸出来?(讽刺版)]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%9A%84%E6%8A%8AUI%E6%92%B8%E5%87%BA%E6%9D%A5-%E8%AE%BD%E5%88%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[背景本文不使用任何框架 不考虑任何浏览器兼容性 不接受反驳 前提你需要了解各种基本的布局属性，不要求你掌握，但是你至少要知道名字和大概用法 思想“先易后难”，”管他三七二十一”，”抱歉，有搜索引擎就是可以为所欲为”，”你们后端接口都要按我的前端来写”，”把生米煮成熟饭” 例子 一个十分基础的结构，很多老鸟一看就有了自己的实现方案，但是可能很多新人看了几眼后就开始抱怨:”woc,这个东西怎么放在中间啊?”,”诶..为什么那个文字可以去最右边?”,”老哥你这个阴影有点过分了”,”你这图片上哪找的啊??” 请使用”先易后难” 我相信长了眼睛的人一定能分辨出这里可以划分成4块结构 然后”不管三七二十一”把这基本结构写出来 123456&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 但是对于内部元素的具体布局该如何实现呢？(讲道理大佬可以跳过这一步) “抱歉，有搜索引擎就是可以为所欲为” 当你功成名就后别忘了和你的后端小伙伴说一声 “你们后端接口都要按我的前端来写” 当然这个思想还有升级版 “抱歉，全栈工程师就是可以为所欲为” 然后你就可以关闭你的所有通讯设备 “把生米煮成熟饭” 熟能生巧!! 欢迎分享给你周围学前端的新人 全文结束]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从“零”开始 ：Spring MVC]]></title>
    <url>%2F2018%2F05%2F06%2F%E4%BB%8E%E2%80%9C%E9%9B%B6%E2%80%9D%E5%BC%80%E5%A7%8B-%EF%BC%9ASpring-MVC%2F</url>
    <content type="text"><![CDATA[该系列博客由我的同学汤茂行独立完成，仅在这里提供链接，欢迎访问博客地址]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICS2017 Programming Assignment 2.2-2.3]]></title>
    <url>%2F2018%2F05%2F06%2FICS2017-Programming-Assignment-2-2-2-3%2F</url>
    <content type="text"><![CDATA[PA2.2 程序，运行时的环境与AM运行更多的程序让项目默认编译到x86-nemu中的AM中1234// nexus-am/Makefile.checkARCH ?= x86-nemuARCHS = $(shell ls $(AM_HOME)/am/arch/) 然后在nexus-am/tests/cputest中执行 1make ALL=xxx run xxx为程序名(无.c后缀) 实现更多的指令在完成更多指令之前我们要先完成rtl.h中的辅助函数 1234567#define make_rtl_setget_eflags(f) \ static inline void concat(rtl_set_, f) (const rtlreg_t* src) &#123; \ cpu.eflags.f = *src; \ &#125; \ static inline void concat(rtl_get_, f) (rtlreg_t* dest) &#123; \ *dest = cpu.eflags.f; \ &#125; 根据提示简单的完成标志位赋值 1234static inline void rtl_not(rtlreg_t* dest) &#123; // dest &lt;- ~dest rtl_li(dest,~(*dest));&#125; 取反 12345static inline void rtl_update_ZF(const rtlreg_t* result, int width) &#123; // eflags.ZF &lt;- is_zero(result[width * 8 - 1 .. 0]) assert (width == 4 || width == 2 || width == 1); cpu.eflags.ZF = (*result &amp; ~(0xffffffff &lt;&lt; (8 * width - 1) &lt;&lt; 1)) == 0;&#125; 根据提示更新ZF位，同时判断长度width 12345static inline void rtl_update_SF(const rtlreg_t* result, int width) &#123; // eflags.SF &lt;- is_sign(result[width * 8 - 1 .. 0]) assert (width == 4 || width == 2 || width == 1); cpu.eflags.SF = (*result &gt;&gt; (8 * width - 1)) &amp; 0x1;&#125; 根据提示更新SF位，同时判断长度width 完成指令主要任务是完成nemu/src/cpu/exec/下每个文件的TODO，先在该目录下执行ls看一下文件 1all-instr.h arith.c cc.c control.c data-mov.c exec.c logic.c prefix.c special.c system.c 接下来我们按ls展示的文件顺序进行分析 all-instr.hall-instr.h为你写的函数定义的文件，先看看在文件完成后定义的全部指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354include "cpu/exec.h"make_EHelper(mov);make_EHelper(operand_size);make_EHelper(cltd);make_EHelper(cwtl);make_EHelper(idiv);make_EHelper(div);make_EHelper(sbb);make_EHelper(dec);make_EHelper(shl);make_EHelper(sar);make_EHelper(or);make_EHelper(adc);make_EHelper(dec);make_EHelper(mul);make_EHelper(imul);make_EHelper(imul1);make_EHelper(imul2);make_EHelper(jmp_rm);make_EHelper(jmp);make_EHelper(inc);make_EHelper(leave);make_EHelper(cltd);make_EHelper(jcc);make_EHelper(test);make_EHelper(movzx);make_EHelper(movsx);make_EHelper(setcc);make_EHelper(nop);make_EHelper(xchg);make_EHelper(and);make_EHelper(leave);make_EHelper(cltd);make_EHelper(dec);make_EHelper(cmp);make_EHelper(neg);make_EHelper(not);make_EHelper(or);make_EHelper(shr);make_EHelper(sar);make_EHelper(lea);make_EHelper(add);make_EHelper(inv);make_EHelper(nemu_trap);make_EHelper(call);make_EHelper(call_rm);make_EHelper(push);make_EHelper(sub);make_EHelper(pop);make_EHelper(xor);make_EHelper(ret); arith.cAdd1234567891011121314151617make_EHelper(add) &#123; rtl_add(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); rtl_sltu(&amp;t0, &amp;t2, &amp;id_dest-&gt;val); rtl_set_CF(&amp;t0); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_not(&amp;t0); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;t2); rtl_and(&amp;t0, &amp;t0, &amp;t1); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template2(add);&#125; 查看i386手册，ADD执行两个操作数（DEST和SRC）的整数相加。 加法结果被分配给第一个操作数（DEST），并相应地设置标志位，当立即字节被添加到字或双字操作数时，立即值被符号扩展为字或双字的大小的操作数，发现其与Adc相似，只需修改部分即可，然后填入opcode table中 12345make_group(gp1, EX(add),..../* 0x00 */ IDEXW(G2E, add, 1), IDEX(G2E, add), IDEXW(E2G, add, 1), IDEX(E2G, add),/* 0x04 */ IDEXW(I2a, add, 1), IDEX(I2a, add), EMPTY, EMPTY, 译码函数查询decode.c,同时对照i386手册填写即可，以下不在赘述 Sub1234567891011121314151617make_EHelper(sub) &#123; rtl_sub(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); rtl_sltu(&amp;t0, &amp;id_dest-&gt;val, &amp;t2); rtl_set_CF(&amp;t0); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;t2); rtl_and(&amp;t0, &amp;t0, &amp;t1); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template2(sub);&#125; SUB从第一个操作数（DEST）中减去第二个操作数（SRC）。 第一个操作数分配了相减的结果，并相应地设置标志。当从字操作数中减去一个立即字节值时，立即值首先被符号扩展为目标操作数的大小。根据Add指令相反的写Sub即可，也可以参考Sbb指令 12/* 0x28 */ IDEXW(G2E, sub, 1), IDEX(G2E, sub), IDEXW(E2G, sub, 1), IDEX(E2G, sub),/* 0x2c */ IDEXW(I2a, sub, 1), IDEX(I2a, sub), EMPTY, EMPTY, Cmp12345678910111213141516make_EHelper(cmp) &#123; rtl_sub(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_update_ZFSF(&amp;t0, id_dest-&gt;width); rtl_sltu(&amp;t1, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_set_CF(&amp;t1); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;t0); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_and(&amp;t0, &amp;t1, &amp;t0); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template2(cmp);&#125; Cmp指令很简单，与Sub十分类似只是不需要写回，所以只要把operand_write(id_dest, &amp;)去掉即可 123456make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp)）/* 0x38 */ IDEXW(G2E, cmp, 1), IDEX(G2E, cmp), IDEXW(E2G, cmp, 1), IDEX(E2G, cmp),/* 0x3c */ IDEXW(I2a, cmp, 1), IDEX(I2a, cmp), EMPTY, EMPTY, Inc12345678910111213make_EHelper(inc) &#123; rtl_addi(&amp;t0, &amp;id_dest-&gt;val, 1); operand_write(id_dest, &amp;t0); rtl_update_ZFSF(&amp;t0, id_dest-&gt;width); rtl_eqi(&amp;t1, &amp;id_dest-&gt;val, 0xffffffff); rtl_set_CF(&amp;t1); rtl_slt(&amp;t1, &amp;t0, &amp;id_dest-&gt;val); rtl_set_OF(&amp;t1); print_asm_template1(inc);&#125; INC在操作数上加1。 它不会更改进位标志。 要影响进位标志，请使用第二个操作数为1的ADD指令。解释很明确，使用Addi指令，然后更新标志位即可 123456make_group(gp4, EX(inc), EX(dec), EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)/* 0x40 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc),/* 0x44 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), Dec1234567891011121314make_EHelper(dec) &#123; rtl_subi(&amp;t2, &amp;id_dest-&gt;val, 1); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); rtl_xor(&amp;t0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_xor(&amp;t1, &amp;id_dest-&gt;val, &amp;t2); rtl_and(&amp;t0, &amp;t0, &amp;t1); rtl_msb(&amp;t0, &amp;t0, id_dest-&gt;width); rtl_set_OF(&amp;t0); print_asm_template1(dec);&#125; DEC从操作数中减去1。 DEC不会更改进位标志。 要影响进位标志，请使用立即操作数为1的SUB指令。这里和上面的Inc类似，使用subi指令，然后照着Inc反着写Dec，更新标志位即可 123456make_group(gp4, EX(inc), EX(dec), EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)/* 0x48 */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec),/* 0x4c */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), Neg1234567891011121314151617make_EHelper(neg) &#123; rtl_mv(&amp;t0, &amp;id_dest-&gt;val); rtl_not(&amp;t0); rtl_addi(&amp;t0, &amp;t0, 1); operand_write(id_dest, &amp;t0); rtl_eq0(&amp;t1, &amp;id_dest-&gt;val); rtl_set_CF(&amp;t1); rtl_update_ZFSF(&amp;t0, id_dest-&gt;width); rtl_xor(&amp;t1, &amp;t0, &amp;id_dest-&gt;val); rtl_not(&amp;t1); rtl_msb(&amp;t1, &amp;t1, id_dest-&gt;width); rtl_set_OF(&amp;t1); print_asm_template1(neg);&#125; Neg用其二进制补码替代寄存器或存储器操作数的值。操作数从零中减去，结果放在操作数中。进位标志被设置为1，除非操作数为零，在这种情况下，进位标志被清除为0。根据描述调用相应的rtl函数即可 123make_group(gp3, IDEX(test_I, test), EMPTY, EX(not), EX(neg), EX(mul), EX(imul1), EX(div), EX(idiv)) control.cret12345make_EHelper(ret) &#123; rtl_pop(&amp;decoding.jmp_eip); decoding.is_jmp = 1; print_asm("ret");&#125; RET将控制权转交给位于堆栈上的返回地址。地址通常由CALL指令放置在堆栈上，并返回到CALL之后的指令。简单来说就是把jmp_eip推出然后设置跳转即可 1/* 0xc0 */ IDEXW(gp2_Ib2E, gp2, 1), IDEX(gp2_Ib2E, gp2), EMPTY, EX(ret), data-mov.cleave123456make_EHelper(leave) &#123; rtl_mv(&amp;cpu.esp, &amp;cpu.ebp); rtl_pop(&amp;cpu.ebp); print_asm("leave");&#125; LEAVE反转ENTER指令的动作。通过将帧指针复制到堆栈指针，LEAVE释放过程为其局部变量使用的堆栈空间。旧的帧指针被弹出到BP或EBP中，恢复调用者的帧。 随后的RET指令将删除所有推送到退出过程堆栈上的参数。简单来说就是将ebp赋值给esp然后推出ebp，调用rtl函数直接完成 1/* 0xc8 */ EMPTY, EX(leave), EMPTY, EMPTY, cltd123456789101112131415161718192021222324make_EHelper(cltd) &#123; if (decoding.is_operand_size_16) &#123; rtl_lr(&amp;t0, R_AX, 2); if ((int32_t)(int16_t)(uint16_t)t0 &lt; 0) &#123; rtl_addi(&amp;t1, &amp;tzero, 0xffff); rtl_sr(R_DX, 2, &amp;t1); &#125; else &#123; rtl_sr(R_DX, 2, &amp;tzero); &#125; &#125; else &#123; rtl_lr(&amp;t0, R_EAX, 4); if ((int32_t)t0 &lt; 0) &#123; rtl_addi(&amp;t1, &amp;tzero, 0xffffffff); rtl_sr(R_EDX, 4, &amp;t1); &#125; else &#123; rtl_sr(R_EDX, 4, &amp;tzero); &#125; &#125; print_asm(decoding.is_operand_size_16 ? "cwtl" : "cltd");&#125; CLD清除方向标志。 没有其他标志或寄存器受到影响。 CLD执行后，字符串操作会增加它们使用的索引寄存器（SI和/或DI)。 1/* 0x98 */ EX(cwtl), EX(cltd), EMPTY, EMPTY, logic.ctest1234567make_EHelper(test) &#123; rtl_and(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); rtl_set_CF(&amp;tzero); rtl_set_OF(&amp;tzero); rtl_update_ZFSF(&amp;t2,id_dest-&gt;width); print_asm_template2(test);&#125; TEST计算其两个操作数的按位逻辑“与”。如果两个操作数的相应位都是1，结果为1; 否则，每一位都是0.操作的结果被丢弃，只有标志被修改。所以将两个操作数and之后仅设置标志位即可 12345make_group(gp3, IDEX(test_I, test), EMPTY, EX(not), EX(neg), EX(mul), EX(imul1), EX(div), EX(idiv))/* 0x84 */ IDEXW(G2E, test ,1), IDEX(G2E, test), EMPTY, EMPTY, and12345678make_EHelper(and) &#123; rtl_and(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_set_CF(&amp;tzero); rtl_set_OF(&amp;tzero); rtl_update_ZFSF(&amp;t2,id_dest-&gt;width); print_asm_template2(and);&#125; 如果操作数的两个相应位都是1，AND指令的结果的每一位都是1; 否则，它变成0。与Test类似，只需添加将结果写回即可。 123456make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp))/* 0x20 */ IDEXW(G2E, and, 1), IDEX(G2E, and), IDEXW(E2G, and, 1), IDEX(E2G, and),/* 0x24 */ IDEXW(I2a, and, 1), IDEX(I2a, and), EMPTY, EMPTY, or12345678make_EHelper(or) &#123; rtl_or(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_set_CF(&amp;tzero); rtl_set_OF(&amp;tzero); rtl_update_ZFSF(&amp;id_dest-&gt;val,id_dest-&gt;width); print_asm_template2(xor);&#125; OR计算其两个操作数的包含OR，并将结果放入第一个操作数中。 如果操作数的相应位都是0，结果的每一位都是0; 否则，每一位都是1。与And指令相同，只需将rtl_and修改为rtl_or即可 12345make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp))/* 0x08 */ IDEXW(G2E, or, 1), IDEX(G2E, or), IDEXW(E2G, or, 1), IDEX(E2G, or), sar12345678make_EHelper(sar) &#123; // unnecessary to update CF and OF in NEMU rtl_sar(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); print_asm_template2(sar);&#125; SAR向下移动操作数的位。低阶位移入进位标志。SAR执行有符号的分割，向负无穷大舍入（与IDIV不同; 高位保持不变。先判断操作数宽度进行扩展，然后调用rtl_sar函数，将结果写回并更新符号位。 12345678make_EHelper(shr) &#123; // unnecessary to update CF and OF in NEMU rtl_shr(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); print_asm_template2(shr);&#125; SHR与SAR类似,SHR执行未标记的划分; 高位被设置为0。写法与Sar类似，调用rtl_shr函数后写回，更新标志位 12345678make_EHelper(shl) &#123; // unnecessary to update CF and OF in NEMU rtl_shl(&amp;t2, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;t2); rtl_update_ZFSF(&amp;t2, id_dest-&gt;width); print_asm_template2(shl);&#125; SAL(或其同义词SHL）向上移动操作数的位。 高位移入进位标志，低位设为0。与上面两个指令类似，调用rtl_shl函数，将结果写回，更新标志位 以上三个函数根据提示不需要更新CF和OF位 123make_group(gp2, EMPTY, EMPTY, EMPTY, EMPTY, EX(shl), EX(shr), EMPTY, EX(sar)) setcc1234567make_EHelper(setcc) &#123; uint8_t subcode = decoding.opcode &amp; 0xf; rtl_setcc(&amp;t2, subcode); operand_write(id_dest, &amp;t2); print_asm("set%s %s", get_cc_name(subcode), id_dest-&gt;str);&#125; 在这里可以看到调用了rtl_setcc，我们要去cc.c文件中对指令进行补全 cc.c12345678910111213141516171819202122232425262728293031switch (subcode &amp; 0xe) &#123; case CC_O: rtl_li(dest, cpu.eflags.OF); break; case CC_B: rtl_li(dest, cpu.eflags.CF); break; case CC_E: rtl_get_ZF(&amp;t0); rtl_eqi(dest, &amp;t0, 1); break; case CC_NE: rtl_get_ZF(&amp;t0); rtl_neq0(dest, &amp;t0); break; case CC_BE: rtl_li(dest, ((cpu.eflags.CF) || (cpu.eflags.ZF))); break; case CC_S: rtl_li(dest, cpu.eflags.SF); break; case CC_L: rtl_li(dest, (cpu.eflags.SF != cpu.eflags.OF)); break; case CC_LE:&#123; rtl_li(dest, ((cpu.eflags.ZF) || (cpu.eflags.SF != cpu.eflags.OF))); break; &#125; default: panic("should not reach here"); case CC_P: panic("n86 does not have PF");&#125; 这里根据i386补全了部分需要用到的指令: CC_O: 将OF赋值给操作数 CC_B: 将CF赋值给操作数 CC_E: 获取ZF, 然后判断ZF是否为1，若是则dest为1，否则为0 CC_NE: 获取ZF, 然后判断ZF是否不等于0，若是则dest为1，否则为0 CC_BE: 将CF和ZF取或后结果赋值给dest CC_S: 将SF赋值给操作数 CC_L: 判断SF和OF是否相等，将结果赋值给dest CC_LE: 将ZF和SF是否不等于OF的结果取或，然后赋值给dest 最后附上完整的exec文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/* 0x80, 0x81, 0x83 */make_group(gp1, EX(add), EX(or), EX(adc), EX(sbb), EX(and), EX(sub), EX(xor), EX(cmp))/* 0xc0, 0xc1, 0xd0, 0xd1, 0xd2, 0xd3 */make_group(gp2, EX(rol), EMPTY, EMPTY, EMPTY, EX(shl), EX(shr), EMPTY, EX(sar))/* 0xf6, 0xf7 */make_group(gp3, IDEX(test_I, test), EMPTY, EX(not), EX(neg), EX(mul), EX(imul1), EX(div), EX(idiv))/* 0xfe */make_group(gp4, EX(inc), EX(dec), EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)/* 0xff */make_group(gp5, EXW(inc, 2), EX(dec), EX(call_rm), EX(call), EX(jmp_rm), EMPTY, EX(push), EMPTY)/* 0x0f 0x01*/make_group(gp7, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY)opcode_entry opcode_table [512] = &#123; /* 0x00 */ IDEXW(G2E, add, 1), IDEX(G2E, add), IDEXW(E2G, add, 1), IDEX(E2G, add), /* 0x04 */ IDEXW(I2a, add, 1), IDEX(I2a, add), EMPTY, EMPTY, /* 0x08 */ IDEXW(G2E, or, 1), IDEX(G2E, or), IDEXW(E2G, or, 1), IDEX(E2G, or), /* 0x0c */ IDEXW(I2a, or, 1), IDEX(I2a, or), EMPTY, EX(2byte_esc), /* 0x10 */ IDEXW(G2E, adc, 1), IDEX(G2E, adc), IDEXW(E2G, adc, 1), IDEX(E2G, adc), /* 0x14 */ IDEXW(I2a, adc, 1), IDEX(I2a, adc), EMPTY, EMPTY, /* 0x18 */ IDEXW(G2E, sbb, 1), IDEX(G2E, sbb), IDEXW(E2G, sbb, 1), IDEX(E2G, sbb), /* 0x1c */ IDEXW(I2a, sbb, 1), IDEX(I2a, sbb), EMPTY, EMPTY, /* 0x20 */ IDEXW(G2E, and, 1), IDEX(G2E, and), IDEXW(E2G, and, 1), IDEX(E2G, and), /* 0x24 */ IDEXW(I2a, and, 1), IDEX(I2a, and), EMPTY, EMPTY, /* 0x28 */ IDEXW(G2E, sub, 1), IDEX(G2E, sub), IDEXW(E2G, sub, 1), IDEX(E2G, sub), /* 0x2c */ IDEXW(I2a, sub, 1), IDEX(I2a, sub), EMPTY, EMPTY, /* 0x30 */ IDEX(G2E, xor), IDEX(G2E, xor), IDEX(E2G, xor), IDEX(E2G, xor), /* 0x34 */ IDEX(I2a, xor), IDEX(I2r, xor), EMPTY, EMPTY, /* 0x38 */ IDEXW(G2E, cmp, 1), IDEX(G2E, cmp), IDEXW(E2G, cmp, 1), IDEX(E2G, cmp), /* 0x3c */ IDEXW(I2a, cmp, 1), IDEX(I2a, cmp), EMPTY, EMPTY, /* 0x40 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), /* 0x44 */ IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), IDEX(r, inc), /* 0x48 */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), /* 0x4c */ IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), IDEX(r, dec), /* 0x50 */ IDEX(r, push), IDEX(r, push), IDEX(r, push), IDEX(r, push), /* 0x54 */ IDEX(r, push), IDEX(r, push), IDEX(r, push), IDEX(r, push), /* 0x58 */ IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), /* 0x5c */ IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), IDEX(r, pop), /* 0x60 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x64 */ EMPTY, EMPTY, EX(operand_size), EMPTY, /* 0x68 */ IDEX(push_SI, push), EMPTY, IDEXW(push_SI, push, 1), EMPTY, /* 0x6c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x70 */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x74 */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x78 */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x7c */ IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), IDEXW(J, jcc, 1), /* 0x80 */ IDEXW(I2E, gp1, 1), IDEX(I2E, gp1), EMPTY, IDEX(SI2E, gp1), /* 0x84 */ IDEXW(G2E, test ,1), IDEX(G2E, test), EMPTY, EMPTY, /* 0x88 */ IDEXW(mov_G2E, mov, 1), IDEX(mov_G2E, mov), IDEXW(mov_E2G, mov, 1), IDEX(mov_E2G, mov), /* 0x8c */ EMPTY, IDEX(lea_M2G, lea), EMPTY, EMPTY, /* 0x90 */ EX(nop), EMPTY, EMPTY, EMPTY, /* 0x94 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x98 */ EX(cwtl), EX(cltd), EMPTY, EMPTY, /* 0x9c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa0 */ IDEXW(O2a, mov, 1), IDEX(O2a, mov), IDEXW(a2O, mov, 1), IDEX(a2O, mov), /* 0xa4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa8 */ IDEXW(I2a, test, 1), IDEX(I2a, test), EMPTY, EMPTY, /* 0xac */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xb0 */ IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), /* 0xb4 */ IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), IDEXW(mov_I2r, mov, 1), /* 0xb8 */ IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), /* 0xbc */ IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), /* 0xc0 */ IDEXW(gp2_Ib2E, gp2, 1), IDEX(gp2_Ib2E, gp2), EMPTY, EX(ret), /* 0xc4 */ EMPTY, EMPTY, IDEXW(mov_I2E, mov, 1), IDEX(mov_I2E, mov), /* 0xc8 */ EMPTY, EX(leave), EMPTY, EMPTY, /* 0xcc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd0 */ IDEXW(gp2_1_E, gp2, 1), IDEX(gp2_1_E, gp2), IDEXW(gp2_cl2E, gp2, 1), IDEX(gp2_cl2E, gp2), /* 0xd4 */ EMPTY, EMPTY, EX(nemu_trap), EMPTY, /* 0xd8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xdc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe8 */ IDEX(I, call), IDEX(J, jmp), EMPTY, IDEXW(J, jmp, 1), /* 0xec */ IDEXW(in_dx2a, in, 1), IDEX(in_dx2a, in), IDEXW(out_a2dx, out, 1), IDEX(out_a2dx, out), /* 0xf0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf4 */ EMPTY, EMPTY, IDEXW(E, gp3, 1), IDEX(E, gp3), /* 0xf8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xfc */ EMPTY, EMPTY, IDEXW(E, gp4, 1), IDEX(E, gp5), /*2 byte_opcode_table */ /* 0x00 */ EMPTY, IDEX(gp7_E, gp7), EMPTY, EMPTY, /* 0x04 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x08 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x0c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x10 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x14 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x18 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x1c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x20 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x24 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x28 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x2c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x30 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x34 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x38 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x3c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x40 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x44 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x48 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x4c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x50 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x54 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x58 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x5c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x60 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x64 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x68 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x6c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x70 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x74 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x78 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x7c */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0x80 */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x84 */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x88 */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x8c */ IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), IDEX(J, jcc), /* 0x90 */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0x94 */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0x98 */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0x9c */ IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), IDEXW(E, setcc, 1), /* 0xa0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xa8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xac */ EMPTY, EMPTY, EMPTY, IDEX(E2G, imul2), /* 0xb0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xb4 */ EMPTY, EMPTY, IDEXW(mov_E2G, movzx, 1), IDEXW(mov_E2G, movzx, 2), /* 0xb8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xbc */ EMPTY, EMPTY, IDEXW(mov_E2G, movsx, 1), IDEXW(mov_E2G, movsx, 2), /* 0xc0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xc4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xc8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xcc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xd8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xdc */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xe8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xec */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf0 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf4 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xf8 */ EMPTY, EMPTY, EMPTY, EMPTY, /* 0xfc */ EMPTY, EMPTY, EMPTY, EMPTY&#125;; 基础设置(2)思考题 Differential Testing能帮你节省多少时间呢? 能节省我至少10个小时 Differential Testing先在nemu/include/common.h中定义DIFF_TEST 12#define DEBUG#define DIFF_TEST 然后在nemu/src/monitor/diff-test/diff-test.c文件中的difftest_step函数中 12345678910if(cpu.eip != r.eip)&#123; diff = true; printf("eip: nemu: 0x%x qemu: 0x%x \n",cpu.eip,r.eip);&#125;for(int i = 0 ; i &lt; 8 ; i++)&#123; if(reg_l(i) != r.array[i])&#123; diff = true; printf("%s: nemu: 0x%x qemu: 0x%x \n",regsl[i],reg_l(i),r.array[i]); &#125;&#125; 这里对eip和八个寄存器进行遍历比较，如果发现值不同则设置diff = true停止客户程序运行 一键回归测试在nemu目录执行 1bash runall.sh 全部样例跑通 思考题 你觉得该如何捕捉死循环 对程序设置最大运行时间，如果超过该时间则判断程序进入死循环 PA2.3 输入输出思考题 如果代码中的地址0x8049000最终被映射到一个设备寄存器，去掉volatile可能会带来什么问题? 变量如果加了 volatile 修饰，则会从内存重新装载内容，而不是直接从寄存器拷贝内容，去掉volatile会导致错误发生 实现Hello World1234567891011121314151617181920make_EHelper(in) &#123; t2 = pio_read(id_src-&gt;val, id_src-&gt;width); operand_write(id_dest, &amp;t2); print_asm_template2(in);#ifdef DIFF_TEST diff_test_skip_qemu();#endif&#125;make_EHelper(out) &#123; pio_write(id_dest-&gt;val, id_dest-&gt;width, id_src-&gt;val); print_asm_template2(out);#ifdef DIFF_TEST diff_test_skip_qemu();#endif&#125; in与out类似，分别调用pio_read和pio_write函数并传入相应参数即可，这里设置了is_skip_qemu标志来跳过QEMU检查，完成指令后在all-instr.h中定义 12make_EHelper(rol);make_EHelper(out); 在exec.c中填写opcode table 1/* 0xec */ IDEXW(in_dx2a, in, 1), IDEX(in_dx2a, in), IDEXW(out_a2dx, out, 1), IDEX(out_a2dx, out), 时钟在nexus-am/am/arch/x86-nemu/src/ioe.c中 1234567void _ioe_init() &#123; boot_time = inl(RTC_PORT);&#125;unsigned long _uptime() &#123; return inl(RTC_PORT) - boot_time;&#125; 可以看出inl(RTC_PORT)获取当前时间，boot_time为上一次时间，将两者相减返回即可 看看NEMU跑多快Dhrystone Coremark Microbench ref测试 test测试 键盘12345678int _read_key() &#123; uint32_t key_code = _KEY_NONE; if(inb(I8042_STATUS_PORT))&#123; key_code = inl(I8042_DATA_PORT); &#125; return key_code;&#125; 这里先判断端口I8042_STATUS_PORT是否开启，若开启则获取当前keycode即inl(I8042_DATA_PORT)，否则返回_KEY_NONE 思考题 如何检测多个键被同时按下？ 当检测到一个键被按下的时候，去检测此时其他是否有按键被按下 在一些90年代的游戏中，很多渐入渐出的效果都是通过调色板实现的，聪明的你知道其中的玄机么？ 将颜色模拟成类似透明的白色盖在其他颜色上面，模拟出渐变的颜色 添加内存映射I/O在nemu/src/memory/memory.c文件中 12345678910111213141516uint32_t paddr_read(paddr_t addr, int len) &#123; int port = is_mmio(addr); if(port != -1)&#123; return mmio_read(addr, len, port); &#125; return pmem_rw(addr, uint32_t) &amp; (~0u &gt;&gt; ((4 - len) &lt;&lt; 3));&#125;void paddr_write(paddr_t addr, int len, uint32_t data) &#123; int port = is_mmio(addr); if(port != -1)&#123; mmio_write(addr, len, data, port); &#125;else&#123; memcpy(guest_to_host(addr), &amp;data, len); &#125;&#125; 先用is_mmio函数判断物理地址是否被映射到I/O空间，对于paddr_read若返回-1则访问pmem，否则使用mmio_read函数读取port位置的内存，对于paddr_write，若不返回-1则调用mmio_write将数据写入port位置内存 实现IOE(3)123456void _draw_rect(const uint32_t *pixels, int x, int y, int w, int h) &#123; int i; for(i = 0; i &lt; h; i++) &#123; memcpy(fb + (y + i) * _screen.width + x, pixels + i * w, w * 4); &#125;&#125; 将pixels指定的的矩形像素绘制到屏幕中以(x, y)和(x+w, y+h)两点连线为对角线的矩形区域 必答题编译与链接 去掉static，去掉inline或去掉两者，然后重新进行编译，你会发现错误，请分别解释为什么会发生这些错误？你有办法证明你的想法么 当函数被声明static后，它只在定义它的源文件内有效，其他源文件无法访问，所以用来解决不同文件函数重名问题，如果去掉进行编译的话，若不同文件有相同函数名则会报错，证明可以将不同文件中的函数名里添加文件名进行区分，若不报错则想法正确 inline修饰的函数变为内联函数,同时和static类似，只有本地文件可见，允许多个文件内重复定义相同名的函数，错误与static类似，可能会报重复定义的错误，证明可以将不同文件中的函数名里添加文件名进行区分，若不报错则想法正确 编译与链接 在nemu/include/common.h中添加volatile static int dummy;后重新编译NEMU,请问重新编译后的NEMU有多少个dummy变量的实体，你是如何得到这个结果的 有1个。因为在这里用volatile定义了一个dummy 在上一问题条件下在nemu/include/debug.h中添加volatile static int dummy;,请问重新编译后的NEMU有多少个dummy变量的实体，与上题中dummy实体数目进行比较，并解释本题的结果 有2个。因为两个文件中都使用了volatile进行dummy的定义，所以不会发生冲突，为2个。 修改添加的代码，为两处dummy变量进行初始化volatile static int dummy = 0;,然后重新编译NEMU,你发现了什么问题？为什么之前没有出现这个问题 会报错。因为当volatile修饰的dummy被赋予了确定的值之后，两个dummy就指向了同一个内存地址，会发生重复定义的错误。 了解Makefile 请你描述在nemu目录下敲入make后，make程序如何组织.c和.h文件，最终生成可执行文件nemu/build/nemu(这个问题包含两个方面: makefile的工作方式和编译链接的过程) 在当前目录下找名字叫Makefile或makefile的文件 如果找到，它会找文件中的第一个目标文件，并把这个文件作为最终的目标文件 如果文件不存在，或是文件所依赖的后面的.o文件的文件修改时间要比这个文件新，那么，他就会执行后面所定义的命令来生成h这个文件，这个也就是重编译 如果文件所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。 .c文件和.h文件存在，于是make会生成 .o 文件 make会一层一层去找文件的依赖关系，直到最终编译出第一个目标文件，若是过程中出现了错误，make会直接退出并报错，直到最后生成可执行文件nemu]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成-程序的转换及机器级表示]]></title>
    <url>%2F2018%2F05%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[AT&amp;T汇编指令学习(GCC) 源/目的操作数顺序:AT&amp;T语法格式表示为:opcode src, dest: “操作码 源, 目标” 操作数长度标识:在AT&amp;T语法中,通过在指令后添加后缀来指明该指令运算对象的尺寸.后缀 b 指明运算对象是一个字节(byte)后缀 w 指明运算对象是一个字(word)后缀 l 指明运算对象是一个双字(long) 常数/立即数格式 在AT&amp;T语法中 对立即数,须在其前加前缀 $ 来指明 在常数前也必须加一个前缀字符 * 内存寻址方式 SECTION:DISP(BASE, INDEX, SCALE)，段:偏移量(基地址,变址,比例因子) 用法: 这里用leal举例 1234567891011leal 6(%eax), %edx //把eax的值+6放入edx中leal (%eax, %ecx), %edx //把eax+ecx的值装入edx中leal (%eax, %ecx, 4), %edx //把eax + 4*ecx的值装入edx中leal 7(%eax, %eax, 8), %edx //把9*eax +7的值装入edx中leal 0xA(,%eax,4), %edx //把4*eax + 10的值装入edx中leal 9(%eax, %ecx, 2), %edx //把eax + 2*ecx+ 9的值装入edx中 movl用法与leal相同，只不过movl是赋值，leal是赋地址 基本的行内汇编格式 asm(&quot;statements&quot;)例如：asm(&quot;nop&quot;); `asm(“movl %eax,%ebx”);asm 和 asm是完全一样的. 如果有多行汇编，则每一行都要加上\n\t` 常用指令 数据传送指令：move,push,pop 加载有效地址指令：leal 一元操作指令：inc(加1),dec(减1)，neg(取负)，not(取补) 二元操作指令：add,sub,imul,idivl(有符号除法),xor,or,and 移位指令：sal(左移),shl,sar(算数右移),shr(逻辑右移) 跳转指令：jmp,je,jne,js,jns,jg,jl,ja,jb,jbe… 常用指令用法 inc D，加1。 dec D，减1。 neg D，取负数。 not D，取反。 dd S, D，D= D +S，加。 sub S, D，D= D –S，减。 imul S, D，D= D * S， 乘。 xor S, D，D = D ^ S， 异或。 or S, D，D = D | S，或。 and S, D，D = D &amp; S，与。 关于偏移量和对齐方式 对齐方式介绍 123456789101112131415161718struct MyStruct &#123; char dda; //偏移量为0，满足对齐方式，dda占用1个字节； /* 下一个可用的地址的偏移量为1，不是sizeof(double)=8 的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式）， 因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节*/ double dda1;/*int type； //下一个可用的地址的偏移量为16，是sizeof(int)=4的倍 //数，满足int的对齐方式，所以不需要VC自动填充，type存 //放在偏移量为16的地址上，它占用4个字节。 &#125;； //所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构 //的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof //(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为 //sizeof(double)=8的倍数。 几道题第一题对于以下 AT&amp;T格式汇编指令，根据操作数的长度确定对应指令助记符中的长度后缀，并说明每个操作数的寻址方式12345678mov 8(%ebp, %ebx, 4), %axmov %al, 12(%ebp)add (, %ebx, 4), %ebxor (%ebx), %dhpush $0xF8mov $0xFFF0, %eaxtest %cx,%cxlea 8(%ebx, %esi), %eax 参考答案 12345678w，基址+比例变址+偏移，寄存器b，寄存器，基址+偏移l，比例变址，寄存器b，基址，寄存器l，立即数，栈l，立即数，寄存器w，寄存器，寄存器l，基址+变址+偏移，寄存器 第二题假设x和ptr声明如下 123src_type x;dst_type ptr;*ptr = (dst_type)x; 若 x 存储在寄存器 EAX 或 AX 或 AL 中，ptr 存储在寄存器 EDX 中，写出实现上述赋值语句的机器级代码。要求用 AT&amp;T 格式汇编指令表示机器级代码 src_type dst_type 机器级表示 1234567char int movsbl %al, (%edx)int char movb %al, (%edx)int unsigned movl %eax, (%edx)short int movswl %ax, (%edx)unsigned char unsigned movzbl %al, (%edx)char unsigned movsbl %al, (%edx)int int movl %eax, (%edx) 关于Mov movb,movw,movl 分别表示：传送字节，传送字，传送双字 movsbw,movsbl,movswl,将做了符号扩展的字节传送到字，将做了符号扩展的字节传送到双字，将做了符号扩展的字传送到双字 movzbw,movzbl,movzwl,将做了零扩展的字节传送到字,将做了零扩展的字节传送到双字,将做了零扩展的字传送到双字]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能需要的一些微信小程序开发知识点]]></title>
    <url>%2F2018%2F05%2F03%2F%E6%88%91%E5%9C%A8%E5%86%99%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[背景一直以来进行了比较多的微信小程序开发… 总会接触到一些和官方组件或api相关或其无法解决的需求，于是决定在这里小小的整理一下自己的实现(次序不分先后) 自定义组件的使用 创建右键新建Component 引用在你需要引用的文件的json中定义 12345678"注释": "前面为组件名，后面为路径，这里仅供参考"&#123; "usingComponents": &#123; "Menu": "../Components/Menu/Menu", "Loading": "../Components/Loading/Loading" &#125;&#125; 传入属性 在组件的js中定义你需要的属性名,类型及默认值1234567properties: &#123; theme: &#123; type: String, value: 'gray' &#125; ...&#125;, 注意properties为父组件要传入的数据，组件自身状态还是在data中 然后在wxml中引用即可1&lt;Menu theme="&#123;&#123;theme&#125;&#125;"&gt;&lt;/Menu&gt; 一键换肤先创建一个color.wxss来存你的皮肤样式(文件名和位置随意) 12345678910/* 黑色主题 */.bg-black&#123; background-color: #363636;&#125;.col-black-title&#123; color: #ffffff;&#125;.col-black-name&#123; color: #c3c3c3;&#125; class名中必须带一个标志来区分不同主题，推荐使用颜色的英文名..然后在app.wxss中引用 12// ~ 为你的文件路径@import '~/color.wxss'; 之后在app.js的globalData中定义一个字段储存你当前主题 1234globalData: &#123; themeArr: ['gray', 'black', 'green', 'orange', 'pink', 'blue'], theme: 'black' // gray, black, green, orange, pink, blue&#125; 然后在js里引用app.js，然后在onLoad里获取theme后setData即可，这里贴上代码 12345678&lt;Menu theme="&#123;&#123;theme&#125;&#125;"&gt;&lt;/Menu&gt;&lt;block wx:for="&#123;&#123;themeArr&#125;&#125;" wx:key="&#123;&#123;index&#125;&#125;"&gt; &lt;view class="theme-view-item bg-&#123;&#123;item&#125;&#125; select-&#123;&#123;item == theme&#125;&#125;" bindtap='changeTheme' data-theme="&#123;&#123;item&#125;&#125;" &gt;&lt;/view&gt;&lt;/block&gt; 123456789.theme-view-item&#123; width: 80rpx; height: 40rpx; margin: 20rpx; border-radius: 10rpx;&#125;.select-true&#123; transform: scale(1.2,1.2);&#125; 1234567891011121314151617181920212223var app = getApp()Page(&#123; data: &#123; theme: '', themeArr: app.globalData.themeArr &#125;, onLoad: function (options) &#123; this.setData(&#123; theme: app.globalData.theme &#125;) &#125;, changeTheme(e)&#123; var theme = e.currentTarget.dataset.theme app.globalData.theme = theme this.setData(&#123; theme: theme &#125;) &#125;&#125;) 来个效果图 这里你也可以使用storage来保存theme 加载更多使用scroll-view 12345&lt;scroll-view scroll-y bindscrolltolower='toLow' style="height: &#123;&#123;height&#125;&#125;px"&gt; scroll-y允许纵向滚动，bindscrolltolower定义了滚动到底部时应该执行的函数，style中使用了js中获取的屏幕可用高度 使用scroll-y需要指定scroll的高度 1234567891011121314onLoad: function (options) &#123; wx.getSystemInfo(&#123; success: (res) =&gt; &#123; this.setData(&#123; height: res.windowHeight &#125;) &#125; &#125;)&#125;,toLow()&#123; this.setData(&#123; isLoading: true &#125;)&#125;, 然后在scroll下面放你的loading组件就可以了.. 12345678910&lt;scroll-view scroll-y bindscrolltolower='toLow' style="height: &#123;&#123;height&#125;&#125;px"&gt; ...... &lt;view hidden="&#123;&#123;!isLoading&#125;&#125;"&gt; &lt;Loading&gt;&lt;/Loading&gt; &lt;/view&gt;&lt;/scroll-view&gt; 下拉刷新这个功能用到的都是官方的api，先在app.json中定义允许下拉刷新 1234"window": &#123; ...... "enablePullDownRefresh": true&#125; 然后在你的js文件中定义相应的函数 1234onPullDownRefresh: function () &#123; ...... wx.stopPullDownRefresh()&#125;, 这个点可以看官方文档 自适应rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx= 375px = 750物理像素，1rpx = 0.5px = 1物理像素 如果不懂的话不用考虑太多，在用px的时候将其大小翻倍使用rpx即可 【微信小程序】——rpx、px、rem等尺寸间关系浅析 阻止事件冒泡假设有如下结构 123&lt;view class='A' bindtap='funcA'&gt; &lt;view class='B' bindtap='funcB'&gt;&lt;/view&gt;&lt;/view&gt; 我们在A,B上定义了两个独立的点击事件，懂得事件冒泡的童鞋会发现，如果点击B的话，不仅会执行funcB还会执行funcA，那么如何避免这个问题? 很简单，只需要将不需要冒泡的的绑定函数改成catchtap 123&lt;view class='A' bindtap='funcA'&gt; &lt;view class='B' catchtap='funcB'&gt;&lt;/view&gt;&lt;/view&gt; 如何去掉Button的默认边框将button自带的position: relative去掉即可 小程序登录接入流程一张图]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于在mac上使用vscode编写markdown出现控制字符问题]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%85%B3%E4%BA%8E%E5%9C%A8mac%E4%B8%8A%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99markdown%E5%87%BA%E7%8E%B0%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景如题….遇到过无数次，所以今天终于决定解决一下 问题先放一个问题图 这是我的一篇GitHub上的README文件，能看到有好几个莫名的特殊字符 在网上搜了一下，在vscode设置中开启 12//控制编辑器是否应呈现控制字符&quot;editor.renderControlCharacters&quot;: true 然后就能看到这个鬼畜的东西 能看到那个小小的BS，搜了一下发现它是ASCII码中的退格符的Unicode表示法(所有ASCII控制字符都有一个图形外观)，其实这个Bug是chromium的，但是因为vscode底层是electron，electron底层又用的chromium，就导致vscode也有了这个Bug 至于什么情况会发生呢？ 你需要满足以下几条条件: 使用Mac 在Mac上使用vscode(其他编辑器不知道有没有这个Bug) 在上面两种条件满足的情况下写markdown文件 在上面三种条件满足的情况下开启preview，就像这样 凑齐这几个条件真是难为我了 解决方案 去掉上文四个条件中的至少一条 开启&quot;editor.renderControlCharacters&quot;: true，看到这玩意就删掉 本文资料来源于知乎Mac 上的 VSCode 编写 Markdown 总是出现隐藏字符？]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自写一个react-like项目]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%87%AA%E5%86%99%E4%B8%80%E4%B8%AAreact-like%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[背景之前自学了一阵子React源码(文章)，感觉自己对Component和setState,所以这里决定写一个React-Like项目加深一下对React的理解 开始 项目使用了transform-react-jsx来进行JSX和JS的转换 组件既然是写React，那就先定义一下React基本结构 12345678910// src/react/index.jsimport Component from './Component.js'import createElement from './CreateReactElement.js'const React = &#123; Component, createElement&#125;export default React; 其中Component为基本组件作为父类,createElement来创建组件 1234567891011121314151617// src/react/Component.jsimport &#123; enqueueSetState &#125; from './StateQueue'class Component &#123; constructor(props)&#123; this.isComponent = true // 是否为组件 this.isReplace = false // 是否是更新的组件 this.props = props this.state = &#123;&#125; &#125; setState(partialState)&#123; enqueueSetState(partialState, this) &#125;&#125;export default Component; 这里进行了一些基本的初始化, 还定义了setState方法，其中调用了enqueueSetState(后话)进行组件更新 12345678910111213141516171819202122232425262728// src/react/CreateReactElement.jsfunction createElement(tag, attrs, children)&#123; var props = &#123;&#125; var attrs = attrs || &#123;&#125; const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; props.children = childArray; &#125; return &#123; tag, attrs, props, key: attrs.key || null &#125;&#125;export default createElement; 这里同样进行一些初始化操作，但是对传进来的children进行了特殊的处理，利用arguments获得children长度，之后决定是转化成数组还是直接写到porps上去，最后将所有属性作为对象返回，当用户创建React对象时会自动调用这个函数 渲染同样我们先定义一个ReactDom对象 1234567891011// src/react-dom/index.jsimport render from './Render'const ReactDOM = &#123; render: ( nextElement, container ) =&gt; &#123; return render( nextElement, container ); &#125;&#125;export default ReactDOM; 在这里定义了一个大名鼎鼎的render函数，传入两个参数分别为当前的元素和要插入的容器，然后调用Render文件中的render方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// src/react-dom/Render.jsimport &#123; createComponent, setComponentProps&#125; from './Diff'import setAttribute from './Dom'/**入口render方法 * @param &#123;ReactElement&#125; nextElement 要插入到DOM中的组件 * @param &#123;DOMElement&#125; container 要插入到的容器 */export function render(nextElement, container)&#123; if(nextElement == null || container == null) return; if(nextElement.isComponent)&#123; const component = nextElement; if (component._container) &#123; if (component.componentWillUpdate)&#123; component.componentWillUpdate(); &#125; else if (component.componentWillMount) &#123; component.componentWillMount(); &#125; &#125; component._container = container; nextElement = component.render() &#125; const type = typeof nextElement if(type === 'string' || type === 'number')&#123; let textNode = document.createTextNode(nextElement); return container.appendChild(textNode); &#125; if(typeof nextElement.tag === 'function')&#123; let component = createComponent(nextElement.tag, nextElement.attrs) setComponentProps(component,nextElement.attrs, container) return render(component.base, container); &#125; const dom = document.createElement(nextElement.tag) if(nextElement.attrs)&#123; Object.keys(nextElement.attrs).map(key =&gt; &#123; setAttribute(key, nextElement.attrs[key], dom) &#125;) &#125; if(nextElement.props)&#123; if(typeof nextElement.props.children == 'object')&#123; nextElement.props.children.forEach(item =&gt; &#123; render(item, dom) &#125;) &#125;else&#123; render(nextElement.props.children, dom) &#125; &#125; if(nextElement._component)&#123; if(nextElement._component.isReplace)&#123; var arr = Array.from(nextElement._component.parentNode.childNodes) arr.map((item,index) =&gt; &#123; if(isSameDom(item,dom))&#123; return container.replaceChild(dom, nextElement._component.parentNode.children[index]) &#125; &#125;) &#125; &#125; return container.appendChild(dom)&#125;function isSameDom(item, dom)&#123; return (item.nodeName == dom.nodeName &amp;&amp; item.nodeType == dom.nodeType &amp;&amp; item.nextSibling == dom.nextSibling)&#125;export default render; 代码比较长，我们这里分段分析一下 123456const type = typeof nextElementif(type === 'string' || type === 'number')&#123; let textNode = document.createTextNode(nextElement); return container.appendChild(textNode);&#125; 如果元素类型为string或number则直接创建TextNode并直接append到container中里 12345if(typeof nextElement.tag === 'function')&#123; let component = createComponent(nextElement.tag, nextElement.attrs) setComponentProps(component,nextElement.attrs, container) return render(component.base, container);&#125; 如果元素的tag类型为function即为React组件，则调用Diff中的方法来创建组件(后话) 1234567const dom = document.createElement(nextElement.tag)if(nextElement.attrs)&#123; Object.keys(nextElement.attrs).map(key =&gt; &#123; setAttribute(key, nextElement.attrs[key], dom) &#125;)&#125; 如果都不是的话即为普通元素，则直接调用document.createElement创建Dom，之后遍历attrs调用setAttribute来设置属性，Object.keys将对象转化成数组方便遍历，接下来我们看一下setAttribute方法 12345678910111213141516171819202122232425function setAttribute(key, value, dom)&#123; if(key === 'className')&#123; key = 'class' &#125; if(typeof value === 'function')&#123; dom[key.toLowerCase()] = value || ''; &#125;else if(key === 'style')&#123; if(typeof value === 'string')&#123; dom.style.cssText = value || ''; &#125;else if(typeof value === 'object')&#123; for (let name in value) &#123; dom.style[name] = typeof value[name] === 'number' ? value[name] + 'px' : value[name]; &#125; &#125; &#125;else&#123; if(value)&#123; dom.setAttribute(key, value); &#125;else&#123; dom.removeAttribute(key, value); &#125; &#125;&#125;export default setAttribute; 先将className转化为class 若绑定的类型为function则转化成小写后写入dom属性 若key为style，则分类讨论，若属性为string则写入cssText，若为object则判断其是否为number，若是则自动在后面添加px，然后写入style 若为其他则直接调用原生setAttribute方法 若属性值为空则在dom上删除该属性 123456789if(nextElement.props)&#123; if(typeof nextElement.props.children == 'object')&#123; nextElement.props.children.forEach(item =&gt; &#123; render(item, dom) &#125;) &#125;else&#123; render(nextElement.props.children, dom) &#125;&#125; 顺着render往下看，这里遍历元素的子元素递归渲染 1234567891011if(nextElement._component)&#123; if(nextElement._component.isReplace)&#123; var arr = Array.from(nextElement._component.parentNode.childNodes) arr.map((item,index) =&gt; &#123; if(isSameDom(item,dom))&#123; return container.replaceChild(dom, nextElement._component.parentNode.children[index]) &#125; &#125;) &#125;&#125;return container.appendChild(dom) 最后判断两次render的组件是否为同一个，若为同一个则调用replaceChild方法进行替换，否则appendChild到容器中 回到上面nextElement.tag === &#39;function&#39;中，其中有两个函数createComponent和setComponentProps 12345678910111213141516// src/react-dom/Diff.jsexport function createComponent(component, props)&#123; let instance; if(component.prototype &amp;&amp; component.prototype.render)&#123; instance = new component(props) &#125;else&#123; instance = new component(props) instance.constructor = component instance.render = function() &#123; return this.constructor(props) &#125; &#125; return instance;&#125; 第一个if判断是不是class创建的组件，若是则直接new一个，若不是则为函数返回组件，调整一下constructor以及render方法，然后将新组件返回 123456789101112131415// src/react-dom/Diff.jsexport function setComponentProps(component, props, container)&#123; if (!component.base)&#123; if (component.componentWillMount) component.componentWillMount(); &#125;else if(component.componentWillReceiveProps)&#123; component.componentWillReceiveProps(props); &#125; component.props = props; component.parentNode = container renderComponent(component, container)&#125; 首先判断组件的base是否存在，若存在则判断是否为初次挂载，否则判断是否为接受新的props，然后将props即render中的attrs和container作为成员添加到component上，parentNode用来定位父元素方便更新，然后调用renderComponent进行组件挂载或者更新 123456789101112131415161718192021222324252627// src/react-dom/Diff.jsexport function renderComponent(component, container)&#123; let base; if ( component.base &amp;&amp; component.componentWillUpdate ) &#123; component.componentWillUpdate(); &#125; base = component.render() if (component.base) &#123; if (component.componentDidUpdate)&#123; component.componentDidUpdate(); &#125; &#125;else if(component.componentDidMount) &#123; component.componentDidMount(); &#125; component.base = base; base._component = component; if(!container)&#123; component.isReplace = true render(base, component.parentNode) &#125;&#125; base为createComponent中的component渲染后结果，然后进行一下简单的生命周期判断，最后判断container是否为空，若为空则为更新组件，把component.parentNode作为container传回render State更新在文章开始提到过，Component中的setState方法调用了enqueueSetState 1234567891011121314151617181920212223242526// src/react/StateQueue.jsconst batchingUpdates = [] // 需要更新的状态const dirtyComponent = [] // 需要更新的组件var isbatchingUpdates = false // 是否处于更新状态function callbackQueue(fn)&#123; return Promise.resolve().then(fn);&#125;export function enqueueSetState(partialState, component)&#123; if(!isbatchingUpdates)&#123; callbackQueue(flushBatchedUpdates) &#125; isbatchingUpdates = true batchingUpdates.push(&#123; partialState, component &#125;) if(!dirtyComponent.some(item =&gt; item === component))&#123; dirtyComponent.push(component) &#125;&#125; isbatchingUpdates判断事务是否处于更新状态(初始值为false)，若不为更新则调用callbackQueue来执行flushBatchedUpdates函数来更新组件，然后设置更新状态为true，将当前状态和组件添加到batchingUpdates中，最后判断dirtyComponent中是否有当前组件，若无则添加进去 callbackQueue使用了Promise来达到延时模拟setState的功能 1234567891011121314151617181920212223242526// src/react/StateQueue.jsfunction flushBatchedUpdates()&#123; let queueItem, componentItem; while(queueItem = batchingUpdates.shift())&#123; const &#123; partialState, component &#125; = queueItem; if(!component.prevState)&#123; component.prevState = Object.assign(&#123;&#125;, partialState) &#125; if(typeof partialState == 'function')&#123; Object.assign(component.state, partialState(component.prevState, component.props)) &#125;else&#123; Object.assign(component.state, partialState) &#125; component.prevState = component.state &#125; while(componentItem = dirtyComponent.shift())&#123; renderComponent(componentItem) &#125; isbatchingUpdates = false&#125; 遍历batchingUpdates数组排头(shift自查)，获取其中组件和状态，判断组件的前一个状态，若无之前的状态，则将空对象和当前状态合并设为该组件的初始状态，若💰一状态为function，则调用该函数并将返回值和之前状态合并，若不为函数则直接合并，然后设置组件的上一状态为其之前的状态，最后遍历dirtyComponent更新组件，完成后设置isbatchingUpdates为false 至此，基本功能完成 代码请移步GitHub仓库]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码自阅读(长篇)]]></title>
    <url>%2F2018%2F04%2F18%2FReact%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1%E7%99%BD%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[背景准备有时间写一个类react的框架，所以先读一下react的源码 开始这里先自己用parcel简单搭建了一个React环境又随便写了点组件 组件1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import MyNav from '../components/MyNav'class MainContainer extends Component &#123; componentDidMount()&#123; console.log(&lt;MyNav&gt;&lt;/MyNav&gt;) &#125; render() &#123; return ( &lt;div&gt; &lt;MyNav&gt;&lt;/MyNav&gt; &lt;/div&gt; ); &#125;&#125;export default MainContainer; 这里随便写了一个Js, 然后打印了一下MyNav组件 很明显这是一个Js对象而不是Dom 如果在里面嵌套一个子元素… console.log(&lt;MyNav&gt;&lt;div&gt;Hello&lt;/div&gt;&lt;/MyNav&gt;) 我们会发现在props里多了一个children成员，同样也是一个JS对象 如果再多嵌套一下的话(这里写的好看点) 12345678console.log( &lt;MyNav&gt; &lt;div&gt; Hello &lt;span&gt;React&lt;/span&gt; &lt;/div&gt; &lt;/MyNav&gt;) 可以看到这里会在props里面无限的套下去，同时如果一个元素内嵌了多个子元素的话，这些子元素在props的children里会以数组的方式存在 在这里不禁唱起：套马滴汉子你威武雄壮~ 那我们不如就顺着这个问题深入，先看一下React.js 12345678const React = &#123; ...... //省略 Component, createElement: __DEV__ ? createElementWithValidation : createElement, ...... //省略&#125; 我们先看一下Component 123456789101112/* node_modules/react/cjs/react.development.js*/function Component(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer. this.updater = updater || ReactNoopUpdateQueue;&#125; 组件extends的Components就是继承的这玩意 这里没什么好说的，一个构造函数，重点是看看那个children到底是怎么个回事 然后看一哈createElement 123456789101112131415161718192021222324252627282930313233343536373839/* node_modules/react/cjs/react.development.js*/function createElement(type, config, children) &#123; var propName; // Reserved names are extracted var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; ..... // 省略 // Children can be more than one argument, and those are transferred onto // the newly allocated props object. var childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; ...... //省略 return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);&#125; 东西都在这里，代码也很容易理解，这里初始化了一堆东西（你可以很清晰的看到children的处理方式)，最后用ReactElement这个工厂函数返回一个React元素 Object.freeze这里就不讲了 有兴趣的去百度一哈 那么问题来了..Component是继承来的，那这个createElement是什么时候执行的呢? 常规思路是在render里, 那就去看一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344var ReactMount = &#123; /**入口render方法 * @param &#123;ReactElement&#125; nextElement 要插入到DOM中的组件 * @param &#123;DOMElement&#125; container 要插入到的容器 * @param &#123;?function&#125; callback 回调 * @return &#123;ReactComponent&#125; Component instance rendered in `container`.返回ReactComponent */ render: function (nextElement, container, callback) &#123; return ReactMount._renderSubtreeIntoContainer( null, nextElement, container, callback, ); &#125;, ...... /** * 将ReactElement插入DOM中，并返回ReactElement对应的ReactComponent。 * ReactElement是React元素在内存中的表示形式，可以理解为一个数据类，包含type，key，refs，props等成员变量 * ReactComponent是React元素的操作类，包含mountComponent(), updateComponent()等很多操作组件的方法 */ /* parentComponent: 当前组件的父组件 nextElement: 要插入的组件 container: 要插入的容器 callback: 回调函数 */ _renderSubtreeIntoContainer: function ( parentComponent, nextElement, container, callback, ) &#123; callback = callback === undefined ? null : callback; var nextWrappedElement = React.createElement(TopLevelWrapper, &#123; child: nextElement, &#125;); &#125; ......&#125; 在render里可以看到用React的成员方法createElement创建了一个元素返回给了nextWrappedElement 我们跟踪一下nextWrappedElement 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取要插入到的容器的前一次的ReactComponent，这是为了做DOM diffvar prevComponent = getTopLevelWrapperInContainer(container);if (prevComponent) &#123; var prevWrappedElement = prevComponent._currentElement; var prevElement = prevWrappedElement.props.child; // shouldUpdateReactComponent方法判断是否需要更新,它只对同一DOM层级，type相同，key(如果有)相同的组件做DOM diff， if (shouldUpdateReactComponent(prevElement, nextElement)) &#123; var publicInst = prevComponent._renderedComponent.getPublicInstance(); var updatedCallback = callback &amp;&amp; function () &#123; validateCallback(callback); callback.call(publicInst); &#125;; ReactMount._updateRootComponent( prevComponent, nextWrappedElement, nextContext, container, updatedCallback, ); return publicInst; &#125; else &#123; //直接unmount ReactMount.unmountComponentAtNode(container); &#125; // 对于ReactDOM.render()调用，prevComponent为null var reactRootElement = getReactRootElementInContainer(container); var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement); var containerHasNonRootReactChild = hasNonRootReactChild(container); var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild; var component = ReactMount._renderNewRootComponent( nextWrappedElement, container, shouldReuseMarkup, nextContext, callback, )._renderedComponent.getPublicInstance(); return component;&#125; 简单梳理一下这个函数: 先拿到前一次的ReactComponent做dom diff，然后shouldUpdateReactComponent判断一下是否需要更新，如果需要的话就diff之后_updateRootComponent，否则直接卸载；然后调用_renderNewRootComponent渲染新的组件，这两个函数都有上文提到的nextWrappedElement作为参数 到这里问题差不多就解决啦，不过我决定弄个图来直观的表现一哈 至于instantiateReactComponent创建的四种组件感觉没什么深入的必要，这里就不讨论了 事务上面组件那一节讨论的Component下面还有几行代码 123456Component.prototype.setState = function(partialState, callback) &#123; this.updater.enqueueSetState(this, partialState); if (callback) &#123; this.updater.enqueueCallback(this, callback, 'setState'); &#125; &#125;; 这里传入两个参数，分别为新的state和回调函数，这里的updater是在Component中定义的this.updater = updater || ReactNoopUpdateQueue 这里我们看一下enqueueSetState是啥 12345678910111213141516enqueueSetState: function(publicInstance, partialState)&#123; var internalInstance = getInternalInstanceReadyForUpdate( publicInstance, 'setState' ); if (!internalInstance) &#123; return; &#125; // 更新队列合并操作 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); enqueueUpdate(internalInstance); &#125; getInternalInstanceReadyForUpdate获取了当前组件并赋给了internalInstance，然后判断internalInstance的_pendingStateQueue(state更新队列)是否为空，若为空则初始化为数组，然后将partialState即新的state推入，然后调用enqueueUpdate 123456789function enqueueUpdate(component) &#123; if (!batchingStrategy.isBatchingUpdates) &#123; batchingStrategy.batchedUpdates(enqueueUpdate, component); return; &#125; dirtyComponents.push(component); &#125; 当batchingStrategy.isBatchingUpdates为false，即不处于更新状态的时候，调用batchedUpdates对组件进行更新，否则将组件推入dirtyComponents中 但是让我们先看一下batchingStrategy是个啥.. 1234567891011121314var ReactDefaultBatchingStrategy = &#123; isBatchingUpdates: false, batchedUpdates: function(callback, a, b, c, d, e) &#123; var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; if (alreadyBatchingUpdates) &#123; callback(a, b, c, d, e); &#125; else &#123; transaction.perform(callback, null, a, b, c, d, e); &#125; &#125;,&#125; 这里初始状态为false，在batchedUpdates中拿到此时ReactDefaultBatchingStrategy的isBatchingUpdates赋给alreadyBatchingUpdates，然后将其设置为true;如果alreadyBatchingUpdates为true则直接执行回调函数，否则进行transaction.perform Transaction上面都是铺垫，这里就进入真正的事务里了~ 先放一张官方源码的解析图  事务就是把方法用wrapper封装起来，再通过事务的perform方法进行调用，从图里可以看出在执行被包裹的方法前后分别执行initialize和close，一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加 上文的perform(callback)即perform(enqueueUpdate)，这里再放一张网上随便偷来的流程图帮助理解 我们看一下上文的两个wrapper 12345678910111213var RESET_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function()&#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false &#125;&#125;var FLUSH_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function()&#123; ReactUpdates.flushBatchedUpdates.bind(ReactUpdates) &#125;&#125; RESET_BATCHED_UPDATES即是一个wrapper，从图可以看出它应该是用来修改isBatchingUpdates的值，需要更新的时候设置为更新，更新结束后恢复状态，这样不仅可以节省渲染，还能防止enqueueUpdate的递归调用导致死循环 那么在dirtyComponents中是如何进行组件更新的呢? 这里涉及到另一个wrapper即FLUSH_BATCHED_UPDATES，我们看一下flushBatchedUpdates 12345678910var flushBatchedUpdates = function() &#123; while(dirtyComponents.length || asapEnqueued)&#123; if(dirtyComponents.length)&#123; var transaction = ReactUpdatesFlushTransaction.getPooled() transaction.perform(runBatchedUpdates,null,transaction) ReactUpdatesFlushTransaction.release(transaction) &#125; ...... &#125;&#125; flushBatchedUpdates遍历了dirtyComponents，然后用事务执行runBatchedUpdates方法 搜了一下，这个函数主要执行以下两步 一是通过执行updateComponent方法来更新组件 二是若setState方法传入了回调函数则将回调函数存入callbackQueue队列 先看一下updateComponent源码 能看到两个比较重要的函数名componentWillReceiveProps和shouldComponentUpdate，但是根据nextState让我们先看一下_processPendingState这个函数 理解一下: 更新队列为null则直接返回原来state 若队列不为null则返回(大于1则合并) 在updateComponent中，如果shouldUpdate为true,则执行_performComponentUpdate 这里能看到componentWillUpdate这个生命周期函数，没什么深入的必要，我们看看上文中最后的更新函数_updateRenderedComponent 拿到新旧组件信息后传给shouldUpdateReactComponent，根据返回值true or false决定是更新旧组件还是卸载旧组件挂载新组件]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之MVC,MVP,MVVM]]></title>
    <url>%2F2018%2F04%2F16%2FMVC-MVVM-MVP%2F</url>
    <content type="text"><![CDATA[MVCMVC是模型(Model)－视图(View)－控制器(Controller)的缩写，是设计模式中最常用的软件架构 Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的 View：视图，为用户提供使用界面，与用户直接进行交互。 Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应 MVC中只有单向通信 用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等 服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理 Model处理后，将处理结果再交给Controller Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端 MVPMVP是Model-View-Presenter，即将MVC中的控制器Controller换成了Presenter负责逻辑的处理 Presenter: 中介者，连接Model和View层 MVC和MVP的区别是：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller 各部分之间都是双向通信 View 接收用户交互请求 View 将请求转交给 Presenter Presenter 操作Model进行数据更新 Model 通知Presenter数据发生变化 Presenter 更新View数据 MVVMMVVM是Model-View-ViewModel，和MVP的区别在于Presenter换成了ViewModel负责逻辑处理 Model 层，对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model View 层，作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明 ViewModel 层把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新 MVVM的优点是低耦合、可重用性、独立开发 双线数据绑定 View 接收用户交互请求 View 将请求转交给ViewModel ViewModel 操作Model数据更新 Model 更新完数据，通知ViewModel数据发生变化 ViewModel 更新View数据]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Camp - 简明Git入门|笔记记录]]></title>
    <url>%2F2018%2F04%2F15%2FGit-Camp-%E7%AE%80%E6%98%8EGit%E5%85%A5%E9%97%A8-%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[What is Git ?Super popular Version Conntrol System Reasons to Love Git HistoryManage history CollaborationNo waiting,Continue working Feature branchesBranches Tree Why should we learn Git?No Why Where do we begin1234567891011mkdir coding-netcd coding-nettouch index.htmlgit initgit add .git commit -m 'init' History Back 123git status //查看一下状态 git checkout -- . 如果此时你电脑坏了还能找回么? 不能，因为现在还只是本地状态，一切都只现存在你电脑里 Solution: Push 插曲Svn 和 Git 拥有权限管理的功能，每个人只能看到管理员允许自己看到的代码，但是当Svn服务器挂掉后，每个人只有部分的代码，但是Git中每个人都有全部的代码 Master杂项 Master指向可以规定 Master与Branch平级 Clone后Head指向Master Branch杂项12345git branch -b feature //创建并切换到feature分支git checkout master //切换到Mastergit branch -D xxx //删除xxx分支 如果删除feature分支，那么这个节点还存在么? 存在，feature只是一个指向该节点的指针，删除后节点依然存在，只不过没有指针指向它，最后会被Git垃圾回收机制清理 分支提交 12345git push origin // 将当前分支推送到origin主机的对应分支git push origin aaa:bbb //远程创建bbb分支并将aaa推入git push -u origin master // 将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了 因为是入门的Git Camp，虽然自己都会了，但还是收获颇多 还混了一个洋葱猴..]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二新人的一次搜狐前端实习电面]]></title>
    <url>%2F2018%2F04%2F13%2F%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%9C%E7%8B%90%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[背景暑假想找一份实习，碰巧看到了学长的搜狐内推，就把自己的没有诚意的简历投了过去，过了一个多星期收到了电话面试的邮件(十分怀疑是学长面子比较大)。 问题 这里只挑几个重点的问题记录一下(我记得的..) React和Vue相同点 都使用了Virtual DOM 组件化 不同点 React使用JSX渲染页面，Vue使用简单的模板 React不是MVVM,而Vue是,拥有双向数据绑定,允许插值表达式 React中只能用setState修改状态,Vue中可直接修改data React Native与Weex Promise Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected。状态转变只能是 pending -&gt; fulfilled 或者 pending -&gt; rejected。状态转变不可逆 then 方法可以被同一个 promise 调用多次 then 方法必须返回一个 promise。规范里没有明确说明返回一个新的 promise 还是复用老的 promise（即 return this），大多数实现都是返回一个新的 promise，而且复用老的 promise可能改变内部状态，这与规范也是相违背的 值穿透 这里还问了一下具体实现，我只答上了nextTick() 原型链举个例子: 在一个对象上寻找成员的时候，如果没有找到就继续顺着proto往上找，如果最后没找到就报错(直到Object.prototype)balabala… 继承原型链 12// B 继承 AB.prototype = new A() Class 123456class B extends A&#123; constructor(props) &#123; //调用实现父类的构造函数 super(props); &#125;&#125; Undifined 和 Null这是Js的两个基本类型..balabala.. 什么时候这两者会出现? Undifined是未赋值..当你定义了一个变量但是没赋值，或者像是变量提升这种balabala.. Null在我看来是一个指向Object的指针..因为Typeof Null = Objectbalabala… 面试官: 那什么时候Null会出现? 我TM竟然没答上来..当时心里就是一阵凉凉，后来我一想Null不就是没赋值的引用类型么.. 读过什么源码么读过React的setState和Node的setImmediate… 但是考虑到自己水平问题这里就一笔带过了..然后嘴欠提了句感觉读源码对自己现阶段帮助不大，面试官还问了问为什么，我又好不容易圆回来23333 你使用的Html5和Css3新特性Html5 audio，video，canvas，datalist.. Canvas用的比较多，用其模仿过草莓音乐节的宣传视频动画datalist在懒加载的时候有经常用.. Css3 选择器，Animation，Transition，Transform… 然后让我描述了一下看见一个动画如何去实现它..balabala.. 我觉得没人能完全答上来所有的…主要还是说一下自己用的比较多的 总结面试方面 面了大约40-50分钟左右，技术点自我感觉扯上了80%左右，没答上的也尽量扯一点(除了一些自己真的听都没听过的)。感觉问的技术面不是很广(可能因为是实习生)，原生方面问的比较多..但是没问一些更深入一点的，自己比较擅长的Css和React方面也问的比较少(难过)，浏览器和Http方面没问，整体来说面试难度不大..可能考虑到我只是个大二来实习的😂 自己方面人生第一次电话面试..全程紧张，大脑间歇性暂时性空白，许多自己会的没有完美地答出来很遗憾，自己会的想表现出来的没问也有点遗憾，其中还有几次尴尬的寂静(最怕空气突然安静)，不出意外自己应该是凉了QAQ。 但是想想自己大二还有时间补救，赶紧把这篇博客整理出来反思一下自己，诸君共勉吧~ 一些补充 这篇文章好像省略了绝大部分问题(我真的记不起来了) 后来Leader又问了我许多项目相关的问题，但是请看下一条 本文只记录了我记得的中认为有价值(其实是我觉得可以写出来的)的问题 面试官还是不错滴 本文比较适合找实习工作的小萌新 本文随我的记忆实时更新.. 面试评价很注重原生的一个公司.. 可以看出技术实力还是很强的，毕竟算是个大厂。但是面试处理效率不敢恭维，以及面试结果不公布不知道是什么意思。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式]]></title>
    <url>%2F2018%2F04%2F12%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 应用场景 某些管理类，保证资源的一致访问性。 创建对象时耗时过多或耗费资源过多，但又经常用到的对象； 工具类对象 频繁访问数据库或文件的对象。 123456789101112131415161718192021222324class CreateUser &#123; constructor(name) &#123; this.name = name; this.getName(); &#125; getName() &#123; return this.name; &#125;&#125;// 代理实现单例模式var ProxyMode = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new CreateUser(name); &#125; return instance; &#125;&#125;)();// 测试单体模式的实例var a = new ProxyMode("aaa");var b = new ProxyMode("bbb");// 因为单体模式是只实例化一次，所以下面的实例是相等的console.log(a === b); //true 策略模式 策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。 策略模式的目的就是将算法的使用算法的实现分离开来。一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。 应用场景 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 1234567891011121314151617/*策略类*/var levelOBJ = &#123; "A": function(money) &#123; return money * 4; &#125;, "B" : function(money) &#123; return money * 3; &#125;, "C" : function(money) &#123; return money * 2; &#125; &#125;;/*环境类*/var calculateBouns =function(level,money) &#123; return levelOBJ[level](money);&#125;;console.log(calculateBouns('A',10000)); // 40000 代理模式 代理模式的定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。 常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。 应用场景 当我们想要隐藏某个类时，可以为其提供代理类 当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中进行权限判断来进行不同权限的功能调用） 当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行） 12345678910111213141516171819202122var imgFunc = (function() &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function() &#123; var img = new Image(); img.onload = function() &#123; imgFunc.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; imgFunc.setSrc('./loading,gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('./pic.png'); 中介者模式 中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。 应用场景 当一组对象要进行沟通或者业务上的交互，但是其关系却又很复杂混乱时，可以采用此模式 当一个对象与其他的对象要进行紧密的交互，但又想服用该对象而不依赖其他的对象时 想创造一个运行于多个类之间的对象，又不想生成新的子类时 123456789101112131415161718192021222324252627282930313233343536var goods = &#123; //手机库存 'red|32G': 3, 'red|64G': 1, 'blue|32G': 7, 'blue|32G': 6,&#125;;//中介者var mediator = (function() &#123; var colorSelect = document.getElementById('colorSelect'); var memorySelect = document.getElementById('memorySelect'); var numSelect = document.getElementById('numSelect'); return &#123; changed: function(obj) &#123; switch(obj)&#123; case colorSelect: //TODO break; case memorySelect: //TODO break; case numSelect: //TODO break; &#125; &#125; &#125;&#125;)();colorSelect.onchange = function() &#123; mediator.changed(this);&#125;;memorySelect.onchange = function() &#123; mediator.changed(this);&#125;;numSelect.onchange = function() &#123; mediator.changed(this);&#125;; 装饰者模式 装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。 例如：现有4种型号的自行车分别被定义成一个单独的类，如果给每辆自行车都加上前灯、尾灯、铃铛这3个配件，如果用类继承的方式，需要创建4*3=12个子类。但如果通过装饰者模式，只需要创建3个类。 应用场景 原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求 函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性 123456789101112131415161718192021222324252627Function.prototype.before = function(beforefn) &#123; var self = this; //保存原函数引用 return function()&#123; //返回包含了原函数和新函数的 '代理函数' beforefn.apply(this, arguments); //执行新函数，修正this return self.apply(this,arguments); //执行原函数 &#125;&#125;Function.prototype.after = function(afterfn) &#123; var self = this; return function()&#123; var ret = self.apply(this,arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;var func = function() &#123; console.log('2');&#125;//func1和func3为挂载函数var func1 = function() &#123; console.log('1');&#125;var func3 = function() &#123; console.log('3');&#125;func = func.before(func1).after(func3);func(); 以上来源于JavaScript设计模式 未完待续…]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现折叠展开菜单]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[背景在这篇文章《2018年设计趋势指南》中发现一款菜单不错，就想着用微信小程序实现 先上个动图 开始正题上方Nav基本flex布局再加个padding不需要多讲吧? 提一下，微信小程序里input的placeholder样式是写在placeholder-style里或使用placeholder-class 下方菜单 每个小卡片遵从flex布局，设置width: 50%，别忘了flex-wrap: wrap 每个小卡片内部同为flex布局并设置垂直居中，想了想还是科普下: 123456.main-view-item&#123; display: flex; justify-content: center; align-items: center; width: 50%;&#125; flex真他娘的好用 至于里面的图片是从iconfont上拿的，调这几个配色的时间是我布局时间的几十倍…. 动画 微信小程序的动画只能用JS，常规手段不可用，来个头脑风暴hack起来 观察每个卡片的折叠方向后，为每个卡片添加初始rotate使其反向折叠，我在这里定义了两个Class 123456.rotateX90&#123; transform: rotateX(-90deg);&#125;.rotateY90&#123; transform: rotateY(-90deg);&#125; 好了这样就看不到卡片了，然后给菜单按钮添加点击事件改变卡片的rotate(动态改变Class)就Ojbk啦,就像这样 1&lt;view class='main-view-item rotateX90 item1 &#123;&#123;item1Style&#125;&#125;' animation='&#123;&#123;item1&#125;&#125;'&gt;&lt;/view&gt; 实际情况应该用wx:for进行循环渲染 12345678910111213var duration = 150var item1 = wx.createAnimation(&#123; duration: duration, transformOrigin: '0 0 0'&#125;)item1.rotateX(90).step()this.setData(&#123; item1: item1, item1Style: 'item1Style'&#125;) 这里注意调整transformOrigin来控制折叠方向，对于后面的卡片在createAnimation中添加delay字段即可(差为duration的等差数列) 是不是很简单嗯? 至于菜单的收回，代码和展开差不多，就是反过来而已，不过有些展开的顺序和transformOrigin需要注意，这里还是贴一个代码吧: 1234567891011121314var duration = 150var item3 = wx.createAnimation(&#123; duration: duration, transformOrigin: '100% 100% 0', delay: duration * 2&#125;)item1.rotateX(90).step()this.setData(&#123; item3: item3, item3Style: ''&#125;) 另外我在data里设置了两个变量isShow和isShowing来判断菜单是否展开或者正在展开，来控制点击事件，差不多像这样 12345678handleClick()&#123; if(this.data.isShowing) return; else if(!this.data.isShow) this.showMenu() else this.hideMenu()&#125; 在动画完成后对isShow和isShowing进行修改即可 欢迎有更好想法的朋友进行讨论~]]></content>
      <categories>
        <category>微信小程序</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个前端开发者的自我折磨(UI)]]></title>
    <url>%2F2018%2F04%2F03%2F%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%8A%98%E7%A3%A8-UI%2F</url>
    <content type="text"><![CDATA[背景偶然看到一篇UI优化文章，发现里面几个UI交互真滴不错，就自己动手撸了一下~ 上动图 代码按钮12345&lt;div class="load-div"&gt; &lt;div class="load-progress"&gt;&lt;/div&gt; &lt;div class="wave-btn wave wave-small"&gt;&lt;/div&gt; &lt;input type="button" class="load-btn load-btn-hover" value="Show!"&gt;&lt;/div&gt; 这里起作用的有3个div,load-progress模拟进度条,wave-btn模拟扩散的波纹,load-btn即为按钮 扩散的波纹123456789101112131415161718192021222324252627282930313233343536.wave &#123; position: absolute; width: 160px; height: 40px; background-color: #b749cd; border-radius: 5px; z-index: 8;&#125;.wave-small &#123; animation: wave-small .8s infinite linear;&#125;.wave-large &#123; animation: wave-large .6s infinite linear;&#125;@keyframes wave-small &#123; 30% &#123; opacity: 0.5; &#125; 100% &#123; transform: scale(1.1, 1.4); opacity: 0; &#125;&#125;@keyframes wave-large &#123; 30% &#123; opacity: 0.5; &#125; 100% &#123; transform: scale(1.3, 1.6); opacity: 0; &#125;&#125; 使用绝对定位让波纹div在button下面避免遮盖,添加动画使div放大的同时变透明,通过30%调整到比较合适的视觉效果 1234567891011const button = document.getElementsByClassName('load-btn')[0]button.onmouseover = () =&gt; &#123; wave.classList.remove('wave-small') wave.classList.add('wave-large')&#125;button.onmouseout = () =&gt; &#123; wave.classList.remove('wave-large') wave.classList.add('wave-small')&#125; 因为hover时button会变大，所以用js进行判断添加不同大小的波纹动画 变化的按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.load-btn &#123; position: relative; width: 160px; height: 40px; font-size: 16px; color: white; background-color: #d159ec; border-radius: 5px; border: none; outline: none; cursor: pointer; z-index: 9;&#125;.loading-btn-size &#123; animation: size-small, size-back; animation-delay: 0s, 1.4s; animation-duration: .1s, .5s; animation-fill-mode: forwards, forwards; animation-timing-function: ease-in, ease;&#125;.load-btn-hover:hover &#123; animation: color-deep .2s ease-in forwards;&#125;@keyframes color-deep &#123; 70% &#123; transform: scale(1.1, 1.1) &#125; to &#123; background-color: #b749cd; transform: scale(1.1, 1.1) &#125;&#125;@keyframes size-small &#123; to &#123; transform: scale(1, .6); &#125;&#125;@keyframes size-back &#123; 50% &#123; transform: scale(1.2, 1.2); &#125; 70% &#123; transform: scale(1.1, 1.1); &#125; 80% &#123; transform: scale(1.2, 1.2); &#125; to &#123; transform: scale(1.1, 1.1); background-color: #74e795; &#125;&#125; hover时放大且颜色变深,这个就不细讲了,点击后缩小scale(1, .6),延时一段时间后变回原大小(比原来大一点)且更换颜色和文本,在size-back中通过调整百分比来模拟弹性 进度条12345678910111213141516171819202122.load-progress &#123; position: absolute; top: 8px; height: 100%; background-color: rgba(0, 0, 0, 0.3); border-radius: 5px; z-index: 10;&#125;.load-progress-x &#123; animation: x-change 1.2s ease-in; animation-delay: .2s;&#125;@keyframes x-change &#123; from &#123; width: 0; &#125; to &#123; width: 160px; &#125;&#125; 设置高度为button缩小后的高度，宽度从0到恢复模拟进度条，用透明黑色覆盖button来模拟进度条样式 展开的列表123456789&lt;div class="list"&gt; &lt;div class="red"&gt;&lt;/div&gt; &lt;div class="orange"&gt;&lt;/div&gt; &lt;div class="yellow"&gt;&lt;/div&gt; &lt;div class="green"&gt;&lt;/div&gt; &lt;div class="qing"&gt;&lt;/div&gt; &lt;div class="blue"&gt;&lt;/div&gt; &lt;div class="purple"&gt;&lt;/div&gt;&lt;/div&gt; HTML不解释 1234567891011121314151617181920.list div&#123; width: 250px; height: 50px; margin-top: 10px; visibility: hidden;&#125;.fade-show&#123; visibility: visible !important; animation: fade-show .5s linear;&#125;@keyframes fade-show&#123; from &#123; opacity: 0; &#125; tp &#123; opacity: 1; &#125;&#125; css没什么好讲的，这里使用visibility: hidden使元素隐形但是仍占据空间 12345678910111213const list = document.getElementsByClassName('list')[0]let i = 0let n = list.lengthlet timer = setInterval(() =&gt; &#123; if(i == n) clearInterval(timer) if(i &lt; n)&#123; list[i].classList.add('fade-show') i++; &#125;&#125;,50) 定时器遍历NodeList添加动画class即可 总结其实写起来并不难，主要是看你的想法，每个人可能都有不同的实现方式，关键是看哪种效率最高]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入React知识点]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%B7%B1%E5%85%A5React%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[背景自己对React方面还没有一个系统的整理，并且自己ReactNative方面比较薄弱，毕竟平时很少用ReactNative进行开发，接触的相关项目也比较少，所以在这里对React的一些知识点进行一些总结，顺便提一下ReactNative方面的知识 开始以下内容基本为个人理解，如有错误欢迎指出 ReactNative相比于原生App的优势和劣势优势 节省编译时间，开发效率快 学习成本极低(对于我) 组件化 热更新 劣势 不太稳定 内存占用较高 React的生命周期详情可以看我写的这篇React生命周期简明宝典 关于setState setState() schedules an update to a component’s state object. When state changes, the component responds by re-rendering 一个简化的setState调用图 首先，setState是异步执行的 setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below.setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the updater argument below. 这里意思大概就是setState并不总是立即生效..可能会有延迟，但是你可以用componentDidUpdate或者回调函数来解决这个问题 至于setState为什么是异步的，深入的话涉及到React的事务机制，比较高级，本人能力有限这里就不误人子弟了，有兴趣的同学可以去自学一波 如果你写代码的时候发现你set的data并没有立即生效，那么它们很可能被batch update了 setState并不负责更新数据，它只是把state和callback放入_pendingStateQueue和_pendingCallback中，并且把要更新的组件放入dirtyComponents序列 再来个详细一点的图 本人目前只能理解到这里了…这个知识点就先到这了 关于state(状态)和props(属性)stateReact 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致，在React里只需要更新state，然后根据新的state进行渲染。state 的主要作用是用于组件保存、控制、修改自己的可变状态，是一个局部的、只能被组件自身控制的数据源 初始值来源于getInitalState（constructor) 只能在组件内部进行setState 代表组件内部自身的状态，只能在自身组件中存在 props组件中的props是一种父级向子级传递数据的方式，作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改，除非外部传入的props发生改变 尽量减少react组件的state，来降低组件的复杂性以及维护的难度 RefReact 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上 这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例 例如: 123456789101112131415161718192021222324var MyComponent = React.createClass(&#123; handleClick: function() &#123; // 使用原生的 DOM API 获取焦点 this.refs.myInput.focus(); &#125;, render: function() &#123; // 当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs return ( &lt;div&gt; &lt;input type="text" ref="myInput" /&gt; &lt;input type="button" value="点我输入框获取焦点" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); Context在某些场景下，你想在整个组件树中传递数据，但却不想手动地在每一层传递属性。你可以直接在 React 中使用context API解决上述问题 绝大多数应用不需要使用context，这只是一个实验性的API，很有可能在未来的React版本中移除 这里有个官方的context例子，代码比较长我就不搬运了 React事件React有一套自己的事件系统，一般来说元素绑定事件都要用到React提供的事件接口 React的事件其实是做了一层事件代理(事件委托)，使用一个统一的事件监听器，当事件发生的时候，在映射里找到真正的处理函数并调用，简化了事件处理和回收机制，提升了效率。 如果你打印一下这个事件，就会发现是一个Proxy对象 如果在React中绑定了原生事件，组件卸载的时候记得解绑，避免内存泄漏 所以尽量避免在React中使用混合事件和Dom事件 高阶组件(HOC)高阶组件（HOC）是React开发中的特有名词，一个函数返回一个React组件，指的就是一个React组包裹着另一个React组件。可以理解为一个生产React组件的工厂 一句话概括：接受一个组件作为参数，返回一个组件的函数 有两种类型的HOC: Props Proxy（pp） HOC对被包裹组件WrappedComponent的props进行操作 Inherbitance Inversion（ii）HOC继承被包裹组件WrappedComponent 例子:12345678910111213// Target 是一个组件，它作为参数传给了Hoc这个函数function Hoc(Target) &#123; class Wrap extends Component &#123; render() &#123; return ( &lt;div className='wrap'&gt; &lt;Target /&gt; &lt;/div&gt; ); &#125; &#125; return Wrap;&#125; 本文随时间更新]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React-Native</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack配置讲解]]></title>
    <url>%2F2018%2F03%2F28%2FWebpack%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景之前讲了讲Parcel搭建React环境…想了想不讲一哈Webpack还真有点过意不去 开始安装1234npm install webpack webpack-cli -g # 或者yarn global add webpack webpack-cli 配置创建package.json文件1234npm install webpack -D # 或者yarn add webpack -D 添加npm scripts1234567&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --mode production&quot;&#125;,&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,&#125; 入口随意创建./src/index.js，此为webpack默认入口文件，若想更改可以对webpack配置文件进行修改 1234567891011121314151617181920212223242526272829module.exports = &#123; entry: './src/index.js' &#125;// 上述配置等同于module.exports = &#123; entry: &#123; main: './src/index.js' &#125;&#125;// 或者配置多个入口module.exports = &#123; entry: &#123; foo: './src/page-foo.js', bar: './src/page-bar.js', // ... &#125;&#125;// 使用数组来对多个文件进行打包module.exports = &#123; entry: &#123; main: [ './src/foo.js', './src/bar.js' ] &#125;&#125; loader 我们可以把 loader 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块 在module.rules中进行修改123456789101112module: &#123; // ... rules: [ &#123; test: /\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀 include: [ path.resolve(__dirname, 'src') // 指定哪些路径下的文件需要经过 loader 处理 ], use: 'babel-loader', // 指定使用的 loader &#125;, ],&#125; 关于loader的安装可以查看网址 plugin 模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成，只需在配置中通过 plugins 字段添加新的 plugin 即可 1234567const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; plugins: [ new UglifyPlugin() ],&#125; 输出 webpack 的输出即指 webpack 最终构建出来的静态文件，使用output字段进行修改 12345678910111213141516171819202122232425262728module.exports = &#123; // ... output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;,&#125;// 或者多个入口生成不同文件module.exports = &#123; entry: &#123; foo: './src/foo.js', bar: './src/bar.js', &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist', &#125;,&#125;// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存module.exports = &#123; // ... output: &#123; filename: '[name].js', path: __dirname + '/dist/[hash]', &#125;,&#125; 小结创建一个简单的配置文件webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path')const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;, module: &#123; rules: [ &#123; test: /\.jsx?/, include: [ path.resolve(__dirname, 'src') ], use: 'babel-loader', &#125;, ], &#125;, // 代码模块路径解析的配置 resolve: &#123; modules: [ "node_modules", path.resolve(__dirname, 'src') ], extensions: [".wasm", ".mjs", ".js", ".json", ".jsx"], &#125;, plugins: [ new UglifyPlugin(), // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码 // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件 // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数 ],&#125; 简单的webpack搭建就到这里]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和setImmediate小姐那销魂的一夜情]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%92%8CSetImmediate%E5%B0%8F%E5%A7%90%E9%82%A3%E9%94%80%E9%AD%82%E7%9A%84%E4%B8%80%E5%A4%9C%E6%83%85%2F</url>
    <content type="text"><![CDATA[背景Rex大佬看完我的那篇一道简单面试题理解JS事件机制（+1白话讲解)后推荐我加上setImmediate这个东东.. 于是这篇博客应运而生~ 简介This method is used to break up long running operations and run a callback function immediately after the browser has completed other operations such as events and display updates. 如果看不懂这段话…那么这篇文章可能不适合你 渐进先来个简单的Node.js的Event loop 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ Event loop的基础知识这里不再讲解.. 想了解的可以看我上面提到的那篇博文 timers: 这个阶段执行setTimeout()和setInterval()设定的回调。 I/O callbacks: 执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。 idle, prepare: 仅内部使用。 poll: 获取新的I/O事件；node会在适当条件下阻塞在这里。 check: 执行setImmediate()设定的回调。 close callbacks: 执行比如socket.on(‘close’, …)的回调。 例子1234567setTimeout(function timeout () &#123; console.log('timeout');&#125;,0);setImmediate(function immediate () &#123; console.log('immediate');&#125;); setTimeout(fn, 0)几乎等价于setTimeout(fn, 1) 结果如何? 答案是不确定，因为不能确定进行到timers的时候1ms是否已经过去，如果没过去那就执行check中的setImmediate了 另外如果在一些特定的上下文中执行，比如fs.readFile，该函数的回调执行是在poll阶段，那么接下来就一定会先执行check中的setImmediate 多次调用 setImmediate 则把回调都放入队列，在 check 阶段都会执行 setImmediate 回调里调用setImmediate ，则放到下次 event loop 未完待续]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas模仿草莓音乐节宣传视频]]></title>
    <url>%2F2018%2F03%2F27%2FCanvas%E6%A8%A1%E4%BB%BF%E8%8D%89%E8%8E%93%E9%9F%B3%E4%B9%90%E8%8A%82%E5%AE%A3%E4%BC%A0%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[简介在掘金上看了一篇文章，作者使用的是导出的svg，然鹅我不会，所以我就想着用canvas撸出来…顺便当复习了 代码 这里只挑一些我认为有价值的地方讲.. 想了想…canvas好像确实没啥值得讲的，主要是撸代码的时候注意绘画的坐标，要考虑健壮性…不然你会发现后期很难维护 animation-fill-mode: both这是个好东西，让最后放大的三个圆在执行动画前不显示样式以及动画结束后保持样式 代码Js太长 这里就只贴Html了12345678910&lt;div class="main"&gt; &lt;canvas id="left-dot" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="left-scroll" height="600" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="right-scroll" height="600" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle-out" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle-inner" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle1" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle2" height="500" width="700"&gt;&lt;/canvas&gt; &lt;canvas id="circle3" height="500" width="700"&gt;&lt;/canvas&gt;&lt;/div&gt; 成品]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcel上手与React开发环境搭建]]></title>
    <url>%2F2018%2F03%2F25%2FParcel%E4%B8%8A%E6%89%8B%E4%B8%8EReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[背景我从不关注代码之外的东西，因为我相信有人会帮我做这些… 之前上手了Parcel感觉还OK，在这里小小的整理一哈 开始操作 安装Parcel 1yarn global add parcel-bundler 创建package.json再顺便加个命令 12345yarn init -y// package.json"scripts": &#123; "start": "parcel index.html"&#125; 安装Babel 1yarn add babel-preset-env 安装node-sass 1yarn add node-sass 接着创建.babelrc 123&#123; "preset": ["env"]&#125; 安装React依赖 12345yarn add reactyarn add react-domyarn add --dev parcel-bundleryarn add --dev babel-preset-envyarn add --dev babel-preset-react 在.babelrc中修改 123&#123; "presets": ["env", "react"]&#125; 让React内部Class支持箭头函数 1npm install --save-dev babel-plugin-transform-class-properties 在.babelrc中添加 1234"presets": ["env", "react"],"plugins": [ ["transform-class-properties", &#123; "spec": true &#125;] ] 再整理一下目录…现在应该是这样的(关键的) 123456789node_modulessrc components containers App.js App.scss.babelrcindex.htmlpackage.json index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Parcel-React&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="./src/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js12345import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); App.js123456789101112131415import React, &#123; Component &#125; from 'react';import './App.scss';class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;h1&gt;Hello Parcel-React&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default App; App.scss123456789$color-red: red;$color-black: black;h1&#123; color: $color-red; cursor: pointer; &amp;:hover&#123; color: $color-black; &#125;&#125; package.json1234567891011121314151617181920&#123; "name": "parcel-test1", "version": "1.0.0", "main": "index.js", "license": "MIT", "scripts": &#123; "start": "parcel index.html" &#125;, "dependencies": &#123; "babel-preset-env": "^1.6.1", "node-sass": "^4.8.3", "react": "^16.2.0", "react-dom": "^16.2.0" &#125;, "devDependencies": &#123; "babel-core": "^6.26.0", "babel-preset-react": "^6.24.1", "parcel-bundler": "^1.6.2" &#125;&#125; 最后npm run一哈 舒服了，终于可以不用手脚架了，自己动手丰衣足食 有什么其他依赖再自己yarn add或npm install就好啦]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>Parcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯前端实现Gif制作]]></title>
    <url>%2F2018%2F03%2F24%2F%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0gif%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[背景受在线Sorry动图制作启发，想自己用纯前端撸一个类似的东西出来，这里地址 开始操作Begin开始没有任何头绪，想着去别人源码那copy一下，发现根本用不上… Next 想法1: 用绝对定位将文字定位到gif上,然后根据gif特定时间点显示特定文字 想法2: 在特定的时间点上用canvas在gif上绘制特定的文字 Next Result想了想，上面两种想法很好实现，但是都只是把动图展示出来，不能把修改后的文字保存到gif里 再Next对gif的每一帧进行处理然后再拼成gif 再Next Result想了想，没什么大问题，那就开干吧 真正开始操作~怎么把处理后的图片拼接成gif是个问题，去google了一波发现gif.js这个玩意，api也很简单，把图片或者canvas传进去然后render一下就ojbk了,来个官方demo 12345678910111213141516171819var gif = new GIF(&#123; workers: 2, quality: 10&#125;);// add a image elementgif.addFrame(imageElement);// or a canvas elementgif.addFrame(canvasElement, &#123;delay: 200&#125;);// or copy the pixels from a canvas contextgif.addFrame(ctx, &#123;copy: true&#125;);gif.on('finished', function(blob) &#123; window.open(URL.createObjectURL(blob));&#125;);gif.render(); 至于如何获得gif的每一帧，我用的mac下的Gif preview 用户点击生成后用类似懒加载的方式加载图片 12345for(let i = 0 ; i &lt; num ; i++)&#123; image = new Image() image.src = `xxxx$&#123;i&#125;/xx.jpg` arr[i] = image&#125; 请求数据量比较大，我先用mac下的Compress All对图片进行压缩，然后再用gzip进一步压缩所有文件(这都是后话了) 接下来调用canvas的drawImage，绘制arr图片数组中的图片，然后用canvas在上面绘制文字，注意绘制的过程使用函数requestAnimationFrame(这坑爬了好久)，关于此函数这里就不讲解了 123456function render()&#123; ctx.drawImage(arr[i],0,0) ...... requestAnimationFrame(render)&#125;render() 然后一个循环把canvas都add进去 123for(let j = 0 ; j &lt; num ; j++)&#123; gif.addFrame(ctx,&#123;delay: 167&#125;)&#125; 这里注意这两块代码执行的顺序，按照正常理解是draw一个add一个但是我发现不行(woc为什么?)，改了半天破罐破摔都draw完后再一股脑add进去发现竟然可以(???)… 我打印了一下执行顺序发现add竟然是在draw之前完成的 因为draw是递归调用，并且draw和add都是同步任务，按照Js单线程来看draw了一次后就轮到add的for循环执行，执行完毕后才会执行递归调用的draw 那么问题来了… 递归调用的draw还没执行，为什么for循环里就能把没绘制的元素状态”add”进去… 于是我看了一波源码 1234567891011121314151617181920212223242526272829303132333435GIF.prototype.addFrame = function(image, options) &#123; var frame, key; if (options == null) &#123; options = &#123;&#125; &#125; frame = &#123;&#125;; frame.transparent = this.options.transparent; for (key in frameDefaults) &#123; frame[key] = options[key] || frameDefaults[key] &#125; if (this.options.width == null) &#123; this.setOption("width", image.width) &#125; if (this.options.height == null) &#123; this.setOption("height", image.height) &#125; if (typeof ImageData !== "undefined" &amp;&amp; ImageData !== null &amp;&amp; image instanceof ImageData) &#123; frame.data = image.data &#125; else if (typeof CanvasRenderingContext2D !== "undefined" &amp;&amp; CanvasRenderingContext2D !== null &amp;&amp; image instanceof CanvasRenderingContext2D || typeof WebGLRenderingContext !== "undefined" &amp;&amp; WebGLRenderingContext !== null &amp;&amp; image instanceof WebGLRenderingContext) &#123; if (options.copy) &#123; frame.data = this.getContextData(image) &#125; else &#123; frame.context = image &#125; &#125; else if (image.childNodes != null) &#123; if (options.copy) &#123; frame.data = this.getImageData(image) &#125; else &#123; frame.image = image &#125; &#125; else &#123; throw new Error("Invalid image") &#125; return this.frames.push(frame)&#125; instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性 很明显, 因为add时候参数没有传copy所以进入frame.context = image，看到context第一感觉是和执行上下文有关系，再打印一遍执行顺序发现gif.on(&#39;finish&#39;)是全部draw完后执行的，结合worker不难推出frame和canvas之间是类似引用的关系并且在子线程中不断执行… 最后就很简单了…render一下就ojbk 考虑到我服务器性能和网速… 我在这整个大函数外面套了个延时器…保证用户加载完图片后才开始drawImage，不然会报错 启动服务器使用node.js的express搭建 总结光是最后这个想法介绍起来都能看出来我踩了很多坑….之前的想法踩了多少坑就不提了23333，并且发现不对后整个代码都要重写emmm，不过收获还是很多，同样的问题不会犯第二次了]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS人人都能写自定义Checkbox（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F23%2FCSS%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89Checkbox%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景那一刻…无数前端开发者想起了自己曾经被Checkbox支配的恐惧…这种在绝大多数浏览器中几乎或完全不能进行样式替代的玩意让开发者们被迫选择默认样式，或者是找一些访问性极差的hack方案… 开始操作 先把基本结构搞出来12&lt;input type="checkbox" id="awesome" /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; 可能有部分人不知道label有啥用: 当label与checkbox关联后，就可以起到触发开关的作用，并且我们可以通过对其添加一些内容(下面会讲解)来模拟checkbox的样式，再把真正的checkbox隐藏，最终达到我们的目的 添加样式123456789101112input[type="checkbox"] + label::before&#123; content: '\a0'; /* 不换行空格 */ display: inline-block; /* 让元素和label处于同一行 */ vertical-align: .1em; /* 设置元素向上偏移.1em */ width: .8em; height: .8em; margin-right: .2em; /* 和label保持一定距离 */ border-radius: .2em; /* 加个圆角 */ background-color: lightcoral; text-indent: .15em; /* 设置元素内content(下文模拟的✓)的缩进 */ line-height: .65; /* 设置行高 */&#125; ‘+’ 选择器指相邻同胞选择器，例子中指选择紧挨在checkbox后面的label~ 对于content这个属性，这里有篇博客大家可以看一下编码 关于em这里就不再讲解啦~ 不过还是推荐大家出门拐拐拐去学习一下emmmmm. 展示 这个淡珊瑚色的框框就是我们设置的label::before 加个选中状态 1234input[type="checkbox"]:checked + label::before&#123; content: '\2713'; background: lightblue;&#125; 展示 这个对勾的位置受到了上面样式text-indent: .15em的影响 这里用到了CSS3的checked伪对象选择器 隐藏默认的checkbox 1234input[type="checkbox"]&#123; position: absolute; clip: rect(0,0,0,0); /* 剪裁绝对定位元素 */&#125; 展示 注意, 这里使用display:none虽然也能隐藏,但是会将checkbox从tab切换焦点的队列中删除(比如你输入完账号密码后使用tab不会使checkbox获得焦点) 结果 Html 12&lt;input type="checkbox" id="awesome" /&gt;&lt;label for="awesome"&gt;Awesome!&lt;/label&gt; Css 1234567891011121314151617181920input[type="checkbox"] + label::before&#123; content: '\a0'; display: inline-block; vertical-align: .1em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background-color: lightcoral; text-indent: .15em; line-height: .65;&#125;input[type="checkbox"]:checked + label::before&#123; content: '\2713'; background: lightblue;&#125;input[type="checkbox"]&#123; position: absolute; clip: rect(0,0,0,0);&#125; 了解了基础操作后，相信各位能自己独立写一个自定义checkbox啦，各位也可以自由修改content或者添加动画做出酷炫的效果~]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(吐槽)学生把代码作业放到博客里有错么?]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%90%90%E6%A7%BD-%E5%AD%A6%E7%94%9F%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%BD%9C%E4%B8%9A%E6%94%BE%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%87%8C%E6%9C%89%E9%94%99%E4%B9%88%2F</url>
    <content type="text"><![CDATA[起因事情发生在我的周围，某位同学(以下称为X总)把实验课布置的课设某一阶段的代码放到了博客里，并注解了自己的理解等等….听起来是一件值得表扬的事情，然而结果并不如此… 高潮当实验课助教检查收上来的作业报告时，发现有十多个人的代码是相同的…!经过调查，确定了是那些同学上网搜到了X总的博客，发现写的真好还有自己的理解，于是就开心的抄了下来 结果X总和抄作业的同学都受到了扣分或零分的处置，并且X总获得和助教私聊的机会一次(内容不得而知) 调查特派员addone对助教和X总进行了间接调查 助教: 因为我们不会去看是谁写的博客，所以只能对代码相同的同学同样处置 X总: (我: X总下一阶段还写博客么)我K谁还敢写啊.. 舆论群内活跃人员(敢说话的大佬们)倾向于X总 个人想法写博客的X总没有任何错误，错误都在于抄博客的同学，助教应该去找明是谁被抄(本来也不是难事)并且严厉警告那些抄代码的同学，而不是这种酷酷的说:”分不清是谁抄谁”那句”我K谁还敢写啊”真是令人寒心.. 各位看官你们的想法呢?]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码简明宝典]]></title>
    <url>%2F2018%2F03%2F18%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍状态码的职责是当客户端向服务端发送请求时候，描述返回的请求内容 状态码如200 OK ，以三位数字和原因短语组成 状态码 类别 原因短语 1XX informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 本文只介绍具有代表性的14个状态码 2XX成功2XX的响应结果表明请求被正常处理了 200 OK从客户端发来的请求在服务端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变(GET/HEAD) 204 No Content服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体 一般在只需要从客户端往服务端发送信息，而对客户端不需要发送新信息内容的情况下使用 206 Partial Content客户端进行了范围请求，而服务器成功执行了这部分的GET请求 响应报文中包含由Content-Range指定范围的实体内容 3XX 重定向3XX的响应结果表明浏览器需要执行某些特殊的处理来正确处理请求 301 Moved Permanently永久性重定向。请求的资源已经被分配了新的URI，以后应该使用资源现在所指向的URI 如果已经把资源对应URI保存为书签，这时应该按Location首部字段提示的URI重新保存 302 Found临时性重定向。请求的资源已经被分配了新的URI，希望用户(本次)使用新的URI访问 只是临时性质的移动。如果已经把URI保存为书签，不会像301那样去更新，而是仍旧保留返回302状态码的页面对应URI 303 See Other请求对应的资源存在着另一个URI，应使用GET方法定向获取请求资源。 303与302有相同的功能，但是303明确表明应该使用GET方法 304 Not Modified客户端发送附带条件的请求时，服务器允许请求访问资源。但若请求未满足条件，则直接返回304(服务端资源未改变，可直接使用客户端未过期的缓存) 307 Temporary Redirect临时重定向。与302 Found有相同的含义 307会遵照浏览器标准，不会从POST变成GET 4XX 客户端错误4XX的响应结果表明客户端是发生错误的原因所在 400 Bad Request请求报文中存在语法错误，需修改请求内容再次发送 浏览器会像对待200 OK一样对待该状态码 401 Unauthorized发送的请求需要有通过HTTP认证的认证信息，若之前已进行过一次请求，则表示认证失败。 返回该响应必须包含一个适用于被请求资源的WWW-Authenticate首部以质询用户信息。浏览器初次接收到401响应会弹出认证用的对话窗口 403 Forbidden请求资源的访问被服务器拒绝。服务器没有必要给出拒绝的详细理由。 未获得文件系统的访问授权，访问权限出现某些问题等情况都有可能触发403 404 Not Found服务器上无法找到请求的资源 也可在服务端拒绝请求且不想说明理由时使用 5XX 服务器错误5XX的响应结果表明服务器本身发生错误 500 Internal Server Error服务端在执行请求时发生了错误，也有可能是Web应用的Bug或临时故障 503 Service Unavailable服务器处于超负载或正在停机维护，无法处理请求。 补充 返回的状态码可能和信息不对等 URI是什么? 参考于《HTTP图解》]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期简明宝典]]></title>
    <url>%2F2018%2F03%2F16%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E6%98%8E%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[介绍React的生命周期是我们掌握React工作过程所必须掌握的知识，同时也是部分公司的面试考点 概要React严格定义了组件的生命周期，其主要经历了如下三个过程 装载过程(Mount): 组件第一次在DOM树中渲染的过程 更新过程(Update): 组件重新渲染的过程 卸载过程(Unmount): 组件从DOM中删除的过程 装载过程组件第一次被渲染的时候，依次调用的函数为： constructor getInitialState getDefaultProps componentWillMount render componentDidMount 1. constructorES6中每个类的构造函数，要创建一个组件的实例就要调用相应的构造函数。但是并不是每个组件都要定义自己的构造函数，比如无状态的React组件。一个组件调用构造函数，往往是为了两个目的： 初始化state 绑定成员函数的this环境 getInitialState和getDefaultPropsgetInitialState：该函数返回值用来初始化stategetDefaultProps: 该函数返回值用来初始化props 这两者只有用React.createClass方法创造的组件类才会发生作用，并且React.createClass已经被Fb官方废弃，所以这里不细讲了 2. componentWillMount这个函数没什么存在感，因为在这个时候没有任何渲染出来的结果，调用setState修改状态也不会触发重新渲染，并且在这里做的事情完全可以提前到constructor中去做 3. render可以说React组件中最重要的函数，因为React组件的父类React.Component类对除render之外的生命周期函数都有默认实现 render并不做渲染工作，只是返回一个JSX描述的结构，最终由React库根据返回对象决定如何渲染 render应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的，因为纯函数不应该引起状态的改变 4. componentDidMount componentDidMount并不是在render调用后立即调用，其调用的时候render返回的JSX已经渲染了 componentWillMount可以在服务端和浏览器端调用，但是componentDidMount只能在浏览器端调用(因为”装载”过程是不可能在服务端完成的) 异步请求数据一般都在该函数内进行。 更新过程更新过程会依次调用以下生命周期函数： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 更新过程并不总是执行所有函数 1. componentWillReceiveProps只要是父组件的render函数被调用，在render里渲染的子组件就会经历更新过程，不管父组件传递给子组件的props有没有改变，都会触发componentWillReceiveProps。 注意通过setState触发的更新过程不会调用这个函数，不然岂不是死循环了? 2. shouldComponentUpdate应该是除了render之外最重要的函数了。它决定了一个组件什么时候需不需要渲染。render和shouldComponentUpdate是React中唯二需要有返回值的函数，shouldComponentUpdate返回一个布尔值，告诉React是否需要继续更新，若为true则继续，为false则停止更新，不会触发之后的重新渲染。 3. componentWillUpdate即将render时执行，初始化render时不执行。在这里同样不能setState，这个函数调用之后，就会把nextProps和nextState分别设置到rops和state中，紧接着调用render 4. render同上 5. componentDidUpdate组件更新完成后执行，初始化render时不执行 卸载过程卸载过程只有一个函数componentWillUnmount，当react组件要从DOM树上删除前，该函数会被调用，所以这个函数适合做一些清理工作。 eg: 在componentDidMount中用非react方法创建的DOM元素，如果不处理可能会发生内存泄漏，因此可以在该函数中将其清理干净 总结React的生命周期函数并没有想象中的那么复杂 参考于《深入理解React》]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单CSS实现闪烁动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%AE%80%E5%8D%95CSS%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%83%81%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景本文承接自上文《CSS实现文字打字动画（+1白话讲解）》 介绍提到闪烁动画，很多人可能会想起 &lt;blink&gt; 这个标签，亦或者是text-decoration: blink这个东西，但是这两者都有很大的局限性，身为”专业”前端开发者的我们怎么能满足于此呢？所以我们不得不去寻找一些其他的方法。 开始操作原图 字体调回正常啦~ 想法1:让元素变成透明再变回原样 12345678.title&#123; animation: blink 1s 3;&#125;@keyframes blink&#123; to &#123; color: transparent; &#125;&#125; 我们用Chrome开发者工具中的Animation看一看这个动画 可以发现..这个元素在变成透明之后会瞬间显现到原来的样子，很江硬，我想把他变成平滑的显现出来，于是想到了一个办法：通过修改关键帧，让其在循环周期中进行状态切换12345678.title&#123; animation: blink 1s 3;&#125;@keyframes blink&#123; 50% &#123; color: transparent; &#125;&#125; 舒服了一点 但是长了眼睛的读者一定能从图中发现这个动画的过程是加速的，导致这个动画看起来不是很自然 读了我上一篇文章的童鞋们一定会想到steps这个东西~ 让我们来试一哈12345678.title&#123; animation: blink 1s 3 steps(1);&#125;@keyframes blink&#123; 50% &#123; color: transparent; &#125;&#125; 完美 在这里用to的童鞋注意了，steps(1)表示颜色值的切换只发生在动画周期的末尾，所以效果会变成这样 傻了吧，你的动画是一下都不会闪的 回顾上一篇文章末尾提到了添加一个闪烁的光标，那么我们就用上面学到的知识来实现一下吧~12345678910111213141516171819.title&#123; ... width: 17ch; white-space: nowrap; overflow: hidden; border-right: 2px solid; //不指定颜色，使光标和文字颜色一致 animation: typing 10s steps(17), blink 1s steps(1) infinite; //infinite用来使动画无限循环&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125;@keyframes blink&#123; 50% &#123; border-color: transparent; &#125;&#125; 肥肠完美 因为字体等原因效果展示不是肥肠好，但是应该是最优解啦，还可以通过JS进行维护，这里就不讲啦 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器从输入URL到页面加载过程（+1白话精简讲解）]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88-1%E7%99%BD%E8%AF%9D%E7%B2%BE%E7%AE%80%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍:这是一个很常见的问题，我们每天都在经历这件事，但是却不能说出具体的过程，同时这也是前端面试的一个考点，所以每个学习前端的人都应该了解这个过程。 本文以Chrome浏览器为例，其渲染引擎为Webkit 接下来让我们一步一步走 输入URL后可概括为以下几个过程: 浏览器从DNS服务器获取域名的IP地址(DNS解析) 浏览器与该IP服务器建立TCP连接 浏览器发送HTTP请求 服务器接收请求并返回HTTP报文 浏览器接收返回内容 拿到返回内容后先放两张很容易搜到的流程图 可概括为以下几个过程: 渲染引擎同时解析HTML文档和样式(CSS和Style中)，两者分别生成DOM树和CSSOM树 将DOM中的”可见内容”(除head或display: none等等)和CSSOM合并(attachment)成RenderTree(渲染树) RenderTree构建完毕后进行布局(layout)，即为每个节点分配坐标 遍历RenderTree，Painting(绘制)每个节点 解析器遇到 script 标记时会立即解析并执行脚本，文档的解析将停止，直到脚本执行完毕 补充什么是CSSOM? CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动 为什么Script会阻碍文档的解析? 因为这两者公用同一个线程，且Script优先级较高 如何避免上一个问题? defer: 当浏览器遇到具有defer属性的脚本时，它会阻止加载和执行脚本，直到HTML文档中的所有元素都已解析为止 async: 使用 async 属性时，浏览器会异步加载和执行脚本，同时继续解析HTML中的其他元素，包括其他脚本元素 HTML都解析完成后才会绘制RenderTree么? 并不是。浏览器会尽早的把内容显示出来，所以每解析一部分就会绘制一部分。 希望你看完能有所收获]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道简单面试题理解JS事件机制（+1白话讲解)]]></title>
    <url>%2F2018%2F03%2F14%2F%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E9%9D%A2%E8%AF%95%E9%A2%98%E7%90%86%E8%A7%A3JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[定义 同步: 一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去 异步: 进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率 线程: 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位。指运行中的程序的调度单位 单线程: 单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。单线程就是进程里只有一个线程 问题123456789console.log(100)setTimeout(function () &#123; console.log(200)&#125;, 0)console.log(300)输出:// 100// 300// 200 解析 JS为单线程, 但是任务执行分为同步任务和异步任务 代码中console.log为同步任务, setTimeout为异步任务(这些基础东西就不过多解释了) 为了方便理解，我们可以认为JS这条单线程中有两条事件队列, 一条为同步队列(主事件大循环 Event Loop)，一条为异步队列，同步任务在同步队列中依次执行，异步任务在异步队列中依次执行，并且这两个队列是同时执行的。但是，JavaScript引擎只会执行同步队列中的任务，那么异步队列中的任务什么时候执行呢？ JavaScript引擎会不断遍历同步队列，当同步队列为空时，会将异步队列中执行完毕的异步事件的回调函数放入同步队列执行。 回顾现在让我们回来看看上面的面试题就很容易理解了，同步队列中console.log(100)和console.log(300)执行后，console.log(200)被推入同步队列执行，所以结果依次为100-&gt; 300-&gt;200 PS: setTimeout(fun, 0)中的0不是立即执行的意思, 而是同步队列为空时立即将fun推入同步队列 额外1234567var flag = 1setTimeout(function()&#123; flag = 0&#125;, 0)while(flag)&#123; console.log('running')&#125; 结果是什么? 答案为死循环，因为while(flag)中的代码将一直在同步队列中执行，而flag = 0没有机会被推入同步队列]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现文字打字动画（+1白话讲解）]]></title>
    <url>%2F2018%2F03%2F14%2FCSS%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%89%93%E5%AD%97%E5%8A%A8%E7%94%BB%EF%BC%88-1%E7%99%BD%E8%AF%9D%E8%AE%B2%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍很多时候，我们会有一些奇怪的骚想法，比如让网页中的一些特定文本像敲代码一样一个一个显示出来，有一种命令行的感觉，增加设计感，很多人觉得这个效果要用很长一段JS来实现…. 正好手头有个例子，我决定用CSS实验一下 开始操作原图 emmmmmm…请忽略我的字体 想法1: 让这段文字从宽度0变成实际宽度 123456789.title&#123; ... animation: typing 6s;&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125; emmmm, 忘记禁止折行和剪切超出部分文本了 修改1234567891011.title&#123; ... white-space: nowrap; overflow: hidden; animation: typing 6s;&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125; 看起来还不错，但是还不够，我们希望字符能一个一个出来，想了想，Animation里面有个叫steps的东西，各位可以简单的理解(具体的这里就不介绍啦)为: 里面放多大的数字就是分多少帧执行，比如steps(5)就是将动画分成5帧执行。 就算我们能让动画一帧一帧执行，但是怎么让字符一个一个出现呢? 答案是…. 无人问津的ch单位，这是CSS3的新单位，表示”0”的宽度，到这我想真正的解决方案就出现啦！ 在等宽字体中，”0”字形的宽度和其他所有字形的宽度是一样的 修改123456789101112.title&#123; ... width: 17ch; //别忘了把空格算上! white-space: nowrap; overflow: hidden; animation: typing 6s steps(17); //steps里为你的字符数&#125;@keyframes typing&#123; from &#123; width: 0; &#125;&#125; 或许我们还需要一个闪烁的光标？那就留着下次讲好了(如果我没忘的话) 文章翻译改编于CSS揭秘]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native实现NbaApp]]></title>
    <url>%2F2018%2F03%2F13%2FReact-Native%E5%AE%9E%E7%8E%B0NbaApp%2F</url>
    <content type="text"><![CDATA[介绍本项目为react-native构建的Nba App 设计灵感参考于:灵感来源( 其实就是参考样式 功能简单了很多,因为比较懒233333 功能 nba比分查询 球员数据查询 球队排名查询 项目地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序模仿网易云音乐]]></title>
    <url>%2F2018%2F03%2F13%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[介绍使用微信小程序模仿网易云音乐,接口来源于: 接口地址 功能 网易云账号登录 歌单查看 每日推荐 歌曲随机,单曲,列表循环 歌词滚动 …. 项目地址 图片在github里我就不放在这啦~]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React在线编辑简历]]></title>
    <url>%2F2018%2F03%2F13%2FReact%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[简介闲来无事写了几个小时… 代码还有许多问题, 以及保存为pdf功能未实现 功能 任何地方点击即可修改, 项目可以增加删除 图片就长这个样子 项目地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017自我总结]]></title>
    <url>%2F2018%2F01%2F03%2F2017%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知道该说什么相比于大一，失去了很多，也获得了很多 暑假 自学了Vue全家桶 练手了数个微信小程序 自学后端nodejs 我觉得这是我做过的最正确的决定..告别了jQuery等..这些技术也为我之后学习react等技术铺平了道路,也确定了我向全栈发展的目标 开学后, 我离开了陪伴我将近整个大一的项目组。 我认为这个项目组除了微薄的工资外已经不能给我带来什么了 一些琐碎的事情以及老套的技术栈只会拖累我 氛围也失去了成立之初的热情，当然这是无可避免的 但我仍然感激这个项目组,实话实说,这里帮我度过了小白阶段,我在这的每一次项目都尽职尽责,但为了自己终究会离开 决定 放弃了许多事情, 走好自己的路, 坚持下去, 不好高骛远, 我觉得有句话说的很对：“你只要比昨天的自己更好就行,一辈子都在跟别人攀比是人生的悲剧”。 每天坚持补充前端只是, 不只是会写代码, js深入浏览器原理缓存http等等前端概念技术不断学习 机遇偶然遇见了一份xxxx的招聘信息, 看到远程实习什么什么的就心动了,于是就投了简历。 但是公司要求的react和django我并不会 但是公司给你7天时间自学作为二面结果 思考了一下, 有些机会错过了就不会来了, 于是3天入门, 提前完成任务, 也很顺利的进入公司,老板人很好还给配了macpro 但是 只有看看外面的世界才知道自己有多垃圾 项目难度比想象中大很多 团队协作方式不熟悉 代码太不规范,刚开始几行代码都要review好几次 但是你的付出终会得到回报, 一切都会慢慢变好, 永远不要轻言放弃 展望 好好工作 抓住每个适合自己的机会 拒绝每个不合适的邀请 坚持自己的道路 照顾好她]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++2016上机题及咸鱼代码]]></title>
    <url>%2F2017%2F04%2F22%2FC-2016%E4%B8%8A%E6%9C%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2016年程序设计（2）实验考试题目及弱鸡代码本人C++水平较差,若嫌弃则只看题目即可 （30分）已有二进制文件“student.dat”和“a.dat”，分别存放着10个学生的基本信息。请将“student.dat”文件中第五个学生的所有基本信息连接到 “a.dat”的尾部，并将修改后的文件“a.dat”的内容输出显示在屏幕上。学生信息由以下结构体来描述： 123456struct student&#123; char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生&#125;; （35分）如下student类的成员：（1）请完善该类中的函数；（2）编写主函数，要求：（a）创建student类对象s1（”zhangsan”,80），创建对象s2并用s1初始化s2。（b）输出s1的name，score；输出s2的name，score；（c）利用重载函数实现计算，并在主函数输出s1，s2的分数之和。 123456789101112class student&#123; private: char *name;//学生姓名 intscore;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 intgetScore();//获取分数&#125;; （35分）已知一个抽象类Shape，其定义为： 12345678class Shape&#123; protected: float area; //面积 public: float getarea() &#123; return area; &#125;//获取面积 virtual void calcarea()=0; //计算面积 virtual void show()=0; //显示基本信息&#125;; 要求：(1) 由它派生出圆类Circle，它包含数据成员半径（radius）以及相关的成员函数getradius();还包含一个构造函数，对成员radius进行初始化，并实现继承自Shape的纯虚函数。(2) 再由圆类Circle派生出圆柱类Cylinder，它包含数据成员高度（height）以及相关的成员函数getheight();还包含一个构造函数对成员height进行初始化并显式调用父类Circle类的构造函数，要求覆盖继承自Circle类的函数calcarea()和show()。圆柱类Cylinder继承自Shape类的数据成员area表示圆柱体的表面积。(3) 在main函数中用“圆——半径2.5，圆柱——底面半径2.0，高度6.0”进行测试（π取3.14），调用函数calcarea()计算面积，并调用函数show()输出对象的基本信息，要求Circle类show() 函数输出圆的半径和面积，Cylinder类的show()函数输出圆柱底面圆半径，高度以及表面积。 咸鱼题解,仅供参考和吐槽 第一题123456789101112131415161718192021222324252627282930313233#include&lt;fstream&gt;using namespace std;struct student&#123; char num[11]; //学号 char name[10]; // 姓名 int age; // 年龄 char gender; // 性别，其中M表示男生，F表示女生&#125;;int main()&#123; student std[10]; fstream stu; stu.open("student.dat",ios::in|ios::binary); if(stu.fail())&#123; cout&lt;&lt;"打开a.dat文件失败"&lt;&lt;endl; exit(0); &#125; for(int i=0;i&lt;5;i++) stu.read((char*)&amp;std[i],sizeof(std[i])); stu.close(); stu.open("b.dat",ios::out|ios::binary|ios::app); stu.write((char*)&amp;std[4],sizeof(std[4])); stu.close(); stu.open("b.dat",ios::in|ios::binary); stu.read((char*)&amp;std,sizeof(std)); for(int i=0;i&lt;7;i++)&#123; stu.read((char*)&amp;std[i],sizeof(std)[i]); cout&lt;&lt;std[i].name&lt;&lt;" "&lt;&lt;std[i].age&lt;&lt;" "&lt;&lt;std[i].gender&lt;&lt;" "&lt;&lt;std[i].num&lt;&lt;endl; &#125; stu.close(); return 0;&#125; 第二题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class student&#123; private: char *name;//学生姓名 int score;//学生分数 public: student(char *a,int b);//构造函数 student(student &amp;obj);//拷贝构造函数 ~student();//析构函数 int operator +(student &amp;right);//重载函数，返回两个student对象的分数之和 char *getName();//获取姓名 int getScore();//获取分数&#125;;student::student(char *a,int b)&#123; name = new char[strlen(a)+1]; strcpy(name,a); score = b;&#125;student::student(student &amp;obj)&#123; name = new char[strlen(obj.name)+1]; strcpy(name,obj.name); score = obj.score;&#125;student::~student()&#123; delete []name;&#125;int student::operator+(student &amp;right)&#123; int sum; sum = this-&gt;score + right.score; return sum; &#125;char *student::getName()&#123; return name;&#125;int student::getScore()&#123; return score;&#125;int main()&#123; student s1("zhangsan",80),s2 = s1; int sum; sum = s1 + s2; cout&lt;&lt;s1.getName()&lt;&lt;" "&lt;&lt;s1.getScore()&lt;&lt;endl; cout&lt;&lt;s2.getName()&lt;&lt;" "&lt;&lt;s2.getScore()&lt;&lt;endl; cout&lt;&lt;"总分："&lt;&lt;sum; return 0;&#125; 第三题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;#define pai 3.14class Shape&#123; protected: float area; public: float getArea()&#123; return area; &#125; virtual void calcarea()=0; virtual void show()=0; &#125;;class Circle:public Shape&#123; protected: double radius; public: Circle(double r):Shape()&#123; radius = r; &#125; double getRadius()&#123; return radius; &#125; void calcarea()&#123; area = radius*radius*pai; &#125; void show()&#123; cout&lt;&lt;"半径: "&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;"面积："&lt;&lt;area&lt;&lt;endl; &#125;&#125;;class Cylinder:public Circle&#123; private: double height; public: Cylinder(double height,double r):Circle(r)&#123; this-&gt;height = height; &#125; void calcarea()&#123; area = radius*radius*pai*2 + 2*pai*radius*height; &#125; void show()&#123; cout&lt;&lt;"半径："&lt;&lt;radius&lt;&lt;endl; cout&lt;&lt;"高："&lt;&lt;height&lt;&lt;endl; cout&lt;&lt;"表面积："&lt;&lt;area&lt;&lt;endl; &#125; double getHeight()&#123; return height; &#125;&#125;;int main()&#123; Circle c1(2.5); Cylinder c2(6.0,2.0); c1.calcarea();c2.calcarea(); cout&lt;&lt;"圆的信息：";c1.show(); cout&lt;&lt;"--------------"&lt;&lt;endl; cout&lt;&lt;"圆柱的信息：";c2.show(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>上机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于三种css垂直居中]]></title>
    <url>%2F2017%2F04%2F22%2Fcss%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[目的写前端的时候总是忘记垂直居中…每次都要去搜代码 既然有了博客，就干脆整理一下写在这里吧 基于绝对定位123456789main&#123; position: absolute; top: 50%; left: 50%; margin-top: -3em; margin-left: -9em; width: 18em; height: 6em;&#125; 如果借助calc()函数的话…. 1234567main&#123; position: absolute; top: calc(50% - 3em); left: calc(50% - 9em); width: 18em; height: 6em;&#125; PS: 然而这种方法只局限于固定宽高的元素… 所以我们还可以选择translate()变形函数 123456main&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; ..缺陷自寻.. 基于视口单位123456main&#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%);&#125; ..vw,vh这里不再赘述.. PS: 只适用于在视口中居中的场景 基于Flexbox12345678body&#123; display: flex; min-height: 100vh; margin: 0;&#125;main&#123; margin: auto;&#125; 或者… 1234567main&#123; display: flex; align-items: center; justify-content: center; width: 18em; height: 10em;&#125; PS: 要求你的浏览器支持Flexbox…. 或许你可以尝试一下…1align-self: center; 参考: 《CSS揭秘》]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-2]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle2%2F</url>
    <content type="text"><![CDATA[时光匆匆轻轻地打开书本，低声诵起了朱自清的《匆匆》：“燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候……”多么优美，多么富于哲理的话语，我一遍又一遍地读着、读着……屈指一算，已有四千多个日夜从我身边流过，还有三个月就要小学毕业了。如果再过三千多个日夜我就该大学毕业走向社会了，成为一个来建设祖国的建设者了。如何才能做一个合格的小学生呢？如何做才能成为一个合格的建设者呢？我们这代青少年有理想，又有抱负，但不能坐享其成。有些青年靠幻想来度日：想着以后该做什么，怎样为国家做贡献，就是不开始行动，甚至相信天上会掉下馅饼来。让时间在幻想当中白白流失了。有的人，总把事情推到明天再做，要知道“明日复明日，明日何其多。我生待明日，万事成蹉跎”啊！时光冉冉，我已从嗷嗷待哺的婴儿成长到乖巧懂事的六年级学生，时间就这样溜走――早晨，当我开始洗漱时，时间从水盆里溜走；中午，当我放学回家时，时间从脚下溜走；晚上，当我观望星空时，时间从眼前溜走……“光阴似箭，日月如梭。”每时每刻，时间都从我身边溜走，而且去而不返。“一寸光阴一寸金，寸金难买寸光阴。”这使我加倍珍惜它，把握分分秒秒。直至现在，它还在催促我长大，但是我并不感谢它，因为它在催促我长大的同时，也让生命点滴流逝。我总是追赶它，渴望与它同起同作，同止同息，但是，那却是可望而不可及的。今年的春天一定在想——去年的春天寄托了什么样的理想，明年的春天又会是一个怎样的景象？这一切我都无法作答，但愿像欧阳修所说的那样：今年花胜去年红，明年花更好，更与我同！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的作文-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle1%2F</url>
    <content type="text"><![CDATA[珍爱生命 让人生更精彩一个生命从春天走过，至少它美丽过； 一个生命从夏天走过，至少它辉煌过； 一个生命从秋天走过，至少它绚烂过； 一个生命从冬天走过，至少它坚强过。吟起这首诗，我自问：“生命是什么？”它不是一场雨，雨下在地上蒸发成水汽还会再落下；它不是一棵小草，小草枯了春天还会再荣；生命是无意间爬上额间的河流，当我们懂得珍惜时，河道已很深，深深的河道里有深深的遗憾。生命犹如单行道，没有回头的机会；生命是宇宙时间，永远无法找到两个相同时刻。“人，最宝贵的东西是生命。生命属于人只有一次。”汶川地震，警察妈妈哺育受灾幼儿；玉树天灾，护士妈妈再现慈爱。珍爱生命，人生将更精彩。感悟生命从连绵上浮起，从一点一滴中渗出，在细微处藏身。生命的长河倒映着红花绿叶、飘零积雪，变迁着湖畔边丝丝色泽，并渐渐地前行。大江东去，璀璨的生命镌刻着历史的痕迹，激荡着颗颗璀璨的明珠。生活中不可能处处有鲜花，时时有掌声。在你留意生命、珍惜生命的旅程中，你会发现，当生命被生活推向极致的地方，往往会展现出一些从容之美，临乱世而不惊，处方舟而不躁，喜迎阴晴圆缺，笑傲风霜雨雪；你更会明白，只有抱着一颗常人的平常之心，去看待生命，去珍惜生命，生命才会更有意义。生命是一种神秘的力量，说它脆弱，它就像薄冰一样不堪一击；说它坚强，它又像大山一般坚韧不拔。像海伦·凯勒，她是一位双耳失聪、双目失明的残疾人，但她凭着自己的毅力和信念，凭着对生命的热爱，先后掌握了四门外语，成为哈佛大学的一名学生，你能不说这是生命所创造的奇迹吗？去追寻你的梦想，去你想去的地方，做一个你想做的人。因为，生命只有一次，亦只得一次机会去做你所想做的事。我们应让自己的生命在理智的搏击中度过，就像落叶、谢花一样，潇洒地来，潇洒地去，做到对生命无怨无悔，让生命之光永远辉煌。珍爱生命吧，哪怕生命只有一霎那，那也让它成为一种永恒！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[addone]]></title>
    <url>%2F2017%2F04%2F20%2Faddone%2F</url>
    <content type="text"><![CDATA[欢迎各位来到我的简单博客 其实这里什么都没有2333333333333333]]></content>
      <categories>
        <category>关于我</category>
      </categories>
      <tags>
        <tag>我</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某位小少女的散文诗-1]]></title>
    <url>%2F2017%2F04%2F20%2FgwyhArticle3%2F</url>
    <content type="text"><![CDATA[我 想我想把耳朵，贴在溪边的小树上。听小溪清脆地演奏，听小鸟欢快地啼叫。听啊，听——来到梦一般的仙境。我想把鼻子，放在鲜花上。闻鲜花的芳香，嗅生命的清爽。闻啊，闻——使我更加舒爽。我想把双手，装在飞机上。捉住柔软的白云，逮住太阳的光。玩啊，玩——蓝天是我的乐园。我想把自己，变成一条鱼。在海底，与小鱼嬉戏，与海藻玩耍。无忧无虑，尽情畅游。游啊，游——海底就是我的家。我想把自己，化为一只雄鹰。俯看长城的雄伟，再瞧草原的辽阔。飞啊，飞——见证祖国的欣荣繁茂。我想张开双臂，把祖国的山川揽入怀中。尽享山之静，水之美。我想有一百张，一千张嘴，来歌唱我的祖国——祖国，我为你骄傲！]]></content>
      <categories>
        <category>我爱的人</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
</search>
